///////////////////////////////////////////////////////////////////////////
//  Copyright (C) Wizardry and Steamworks 2013 - License: GNU GPLv3      //
//  Please see: http://www.gnu.org/licenses/gpl.html for legal details,  //
//  rights of fair usage, the disclaimer and warranty conditions.        //
///////////////////////////////////////////////////////////////////////////

#region

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Management;
using System.Net;
using System.Net.Http.Headers;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Cryptography;
using System.ServiceModel.Syndication;
using System.ServiceProcess;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Serialization;
using CorradeConfiguration;
using NTextCat;
using OpenMetaverse;
using Syn.Bot.Siml;
using Syn.Bot.Siml.Events;
using wasOpenMetaverse;
using wasSharp;
using Group = OpenMetaverse.Group;
using Helpers = OpenMetaverse.Helpers;
using Inventory = wasOpenMetaverse.Inventory;
using Parallel = System.Threading.Tasks.Parallel;
using ThreadState = System.Threading.ThreadState;

#endregion

namespace Corrade
{
    public partial class Corrade : ServiceBase
    {
        public delegate bool EventHandler(NativeMethods.CtrlType ctrlType);

        /// <summary>
        ///     The type of threads managed by Corrade.
        /// </summary>
        public enum CorradeThreadType : uint
        {
            [Reflection.NameAttribute("command")] COMMAND = 1,
            [Reflection.NameAttribute("rlv")] RLV = 2,
            [Reflection.NameAttribute("notification")] NOTIFICATION = 3,
            [Reflection.NameAttribute("im")] INSTANT_MESSAGE = 4,
            [Reflection.NameAttribute("log")] LOG = 5,
            [Reflection.NameAttribute("post")] POST = 6
        }

        /// <summary>
        ///     Structure containing errors returned to scripts.
        /// </summary>
        /// <remarks>
        ///     Status is generated by:
        ///     1.) jot -r 900 0 65535 | uniq | xargs printf "%05d\n" | pbcopy
        ///     2.) paste codes.txt status.txt | awk -F"\n" '{print $1,$2}' | pbcopy
        ///     Removals: 43508 - could not get land users
        ///     Removals: 42240 - no notification provided
        ///     Removals: 56462 - texture not found
        ///     Removals: 57429 - timeout waiting for estate list
        ///     Removals: 14951 - timeout joining group chat
        ///     Removals: 36716 - timeout retrieving item
        ///     Removals: 11869 - timeout getting primitive data
        ///     Removals: 20238 - parcel must be owned
        ///     Removals: 22961 - could not add mute entry
        ///     Removals: 12181 - no database key specified
        ///     Removals: 44994 - no database value specified
        ///     Removals: 19142 - unknown database action
        ///     Removals: 24951 - feature only available in secondlife
        /// </remarks>
        public enum ScriptError : uint
        {
            [Status(0)] [Reflection.DescriptionAttribute("none")] NONE = 0,
            [Status(35392)] [Reflection.DescriptionAttribute("could not join group")] COULD_NOT_JOIN_GROUP,
            [Status(20900)] [Reflection.DescriptionAttribute("could not leave group")] COULD_NOT_LEAVE_GROUP,
            [Status(57961)] [Reflection.DescriptionAttribute("agent not found")] AGENT_NOT_FOUND,
            [Status(28002)] [Reflection.DescriptionAttribute("group not found")] GROUP_NOT_FOUND,
            [Status(15345)] [Reflection.DescriptionAttribute("already in group")] ALREADY_IN_GROUP,
            [Status(11502)] [Reflection.DescriptionAttribute("not in group")] NOT_IN_GROUP,
            [Status(32472)] [Reflection.DescriptionAttribute("role not found")] ROLE_NOT_FOUND,
            [Status(08653)] [Reflection.DescriptionAttribute("command not found")] COMMAND_NOT_FOUND,
            [Status(14634)] [Reflection.DescriptionAttribute("could not eject agent")] COULD_NOT_EJECT_AGENT,
            [Status(30473)] [Reflection.DescriptionAttribute("no group power for command")] NO_GROUP_POWER_FOR_COMMAND,
            [Status(27605)] [Reflection.DescriptionAttribute("cannot eject owners")] CANNOT_EJECT_OWNERS,
            [Status(25984)] [Reflection.DescriptionAttribute("inventory item not found")] INVENTORY_ITEM_NOT_FOUND,
            [Status(43982)] [Reflection.DescriptionAttribute("invalid amount")] INVALID_AMOUNT,
            [Status(02169)] [Reflection.DescriptionAttribute("insufficient funds")] INSUFFICIENT_FUNDS,
            [Status(47624)] [Reflection.DescriptionAttribute("invalid pay target")] INVALID_PAY_TARGET,
            [Status(32164)] [Reflection.DescriptionAttribute("teleport failed")] TELEPORT_FAILED,
            [Status(22693)] [Reflection.DescriptionAttribute("primitive not found")] PRIMITIVE_NOT_FOUND,
            [Status(28613)] [Reflection.DescriptionAttribute("could not sit")] COULD_NOT_SIT,
            [Status(48467)] [Reflection.DescriptionAttribute("no Corrade permissions")] NO_CORRADE_PERMISSIONS,
            [Status(54214)] [Reflection.DescriptionAttribute("could not create group")] COULD_NOT_CREATE_GROUP,
            [Status(11287)] [Reflection.DescriptionAttribute("could not create role")] COULD_NOT_CREATE_ROLE,
            [Status(12758)] [Reflection.DescriptionAttribute("no role name specified")] NO_ROLE_NAME_SPECIFIED,
            [Status(34084)] [Reflection.DescriptionAttribute("timeout getting group roles members")] TIMEOUT_GETING_GROUP_ROLES_MEMBERS,
            [Status(11050)] [Reflection.DescriptionAttribute("timeout getting group roles")] TIMEOUT_GETTING_GROUP_ROLES,
            [Status(39016)] [Reflection.DescriptionAttribute("timeout getting role powers")] TIMEOUT_GETTING_ROLE_POWERS,
            [Status(64390)] [Reflection.DescriptionAttribute("could not find parcel")] COULD_NOT_FIND_PARCEL,
            [Status(17019)] [Reflection.DescriptionAttribute("unable to set home")] UNABLE_TO_SET_HOME,
            [Status(31493)] [Reflection.DescriptionAttribute("unable to go home")] UNABLE_TO_GO_HOME,
            [Status(32923)] [Reflection.DescriptionAttribute("timeout getting profile")] TIMEOUT_GETTING_PROFILE,
            [Status(36068)] [Reflection.DescriptionAttribute("type can only be voice or text")] TYPE_CAN_BE_VOICE_OR_TEXT,
            [Status(19862)] [Reflection.DescriptionAttribute("agent not in group")] AGENT_NOT_IN_GROUP,
            [Status(29345)] [Reflection.DescriptionAttribute("empty attachments")] EMPTY_ATTACHMENTS,
            [Status(48899)] [Reflection.DescriptionAttribute("empty pick name")] EMPTY_PICK_NAME,
            [Status(22733)] [Reflection.DescriptionAttribute("unable to join group chat")] UNABLE_TO_JOIN_GROUP_CHAT,
            [Status(59524)] [Reflection.DescriptionAttribute("invalid position")] INVALID_POSITION,
            [Status(02707)] [Reflection.DescriptionAttribute("could not find title")] COULD_NOT_FIND_TITLE,
            [Status(43713)] [Reflection.DescriptionAttribute("fly action can only be start or stop")] FLY_ACTION_START_OR_STOP,
            [Status(64868)] [Reflection.DescriptionAttribute("invalid proposal text")] INVALID_PROPOSAL_TEXT,
            [Status(03098)] [Reflection.DescriptionAttribute("invalid proposal quorum")] INVALID_PROPOSAL_QUORUM,
            [Status(41810)] [Reflection.DescriptionAttribute("invalid proposal majority")] INVALID_PROPOSAL_MAJORITY,
            [Status(07628)] [Reflection.DescriptionAttribute("invalid proposal duration")] INVALID_PROPOSAL_DURATION,
            [Status(64123)] [Reflection.DescriptionAttribute("invalid mute target")] INVALID_MUTE_TARGET,
            [Status(59526)] [Reflection.DescriptionAttribute("unknown action")] UNKNOWN_ACTION,
            [Status(28087)] [Reflection.DescriptionAttribute("no database file configured")] NO_DATABASE_FILE_CONFIGURED,
            [Status(01253)] [Reflection.DescriptionAttribute("cannot remove owner role")] CANNOT_REMOVE_OWNER_ROLE,
            [Status(47808)] [Reflection.DescriptionAttribute("cannot remove user from owner role")] CANNOT_REMOVE_USER_FROM_OWNER_ROLE,
            [Status(47469)] [Reflection.DescriptionAttribute("timeout getting picks")] TIMEOUT_GETTING_PICKS,
            [Status(41256)] [Reflection.DescriptionAttribute("maximum number of roles exceeded")] MAXIMUM_NUMBER_OF_ROLES_EXCEEDED,
            [Status(40908)] [Reflection.DescriptionAttribute("cannot delete a group member from the everyone role")] CANNOT_DELETE_A_GROUP_MEMBER_FROM_THE_EVERYONE_ROLE,
            [Status(00458)] [Reflection.DescriptionAttribute("group members are by default in the everyone role")] GROUP_MEMBERS_ARE_BY_DEFAULT_IN_THE_EVERYONE_ROLE,
            [Status(33413)] [Reflection.DescriptionAttribute("cannot delete the everyone role")] CANNOT_DELETE_THE_EVERYONE_ROLE,
            [Status(65303)] [Reflection.DescriptionAttribute("invalid url provided")] INVALID_URL_PROVIDED,
            [Status(65327)] [Reflection.DescriptionAttribute("invalid notification types")] INVALID_NOTIFICATION_TYPES,
            [Status(49640)] [Reflection.DescriptionAttribute("notification not allowed")] NOTIFICATION_NOT_ALLOWED,
            [Status(44447)] [Reflection.DescriptionAttribute("unknown directory search type")] UNKNOWN_DIRECTORY_SEARCH_TYPE,
            [Status(65101)] [Reflection.DescriptionAttribute("no search text provided")] NO_SEARCH_TEXT_PROVIDED,
            [Status(14337)] [Reflection.DescriptionAttribute("unknown restart action")] UNKNOWN_RESTART_ACTION,
            [Status(28429)] [Reflection.DescriptionAttribute("unknown move action")] UNKNOWN_MOVE_ACTION,
            [Status(20541)] [Reflection.DescriptionAttribute("timeout getting top scripts")] TIMEOUT_GETTING_TOP_SCRIPTS,
            [Status(47172)] [Reflection.DescriptionAttribute("timeout getting top colliders")] TIMEOUT_GETTING_TOP_COLLIDERS,
            [Status(41676)] [Reflection.DescriptionAttribute("unknown top type")] UNKNOWN_TOP_TYPE,
            [Status(25897)] [Reflection.DescriptionAttribute("unknown estate list action")] UNKNOWN_ESTATE_LIST_ACTION,
            [Status(46990)] [Reflection.DescriptionAttribute("unknown estate list")] UNKNOWN_ESTATE_LIST,
            [Status(43156)] [Reflection.DescriptionAttribute("no item specified")] NO_ITEM_SPECIFIED,
            [Status(09348)] [Reflection.DescriptionAttribute("unknown animation action")] UNKNOWN_ANIMATION_ACTION,
            [Status(42216)] [Reflection.DescriptionAttribute("no channel specified")] NO_CHANNEL_SPECIFIED,
            [Status(31049)] [Reflection.DescriptionAttribute("no button index specified")] NO_BUTTON_INDEX_SPECIFIED,
            [Status(38931)] [Reflection.DescriptionAttribute("no button specified")] NO_BUTTON_SPECIFIED,
            [Status(19059)] [Reflection.DescriptionAttribute("no land rights")] NO_LAND_RIGHTS,
            [Status(61113)] [Reflection.DescriptionAttribute("unknown entity")] UNKNOWN_ENTITY,
            [Status(58183)] [Reflection.DescriptionAttribute("invalid rotation")] INVALID_ROTATION,
            [Status(45364)] [Reflection.DescriptionAttribute("could not set script state")] COULD_NOT_SET_SCRIPT_STATE,
            [Status(50218)] [Reflection.DescriptionAttribute("item is not a script")] ITEM_IS_NOT_A_SCRIPT,
            [Status(49722)] [Reflection.DescriptionAttribute("failed to get display name")] FAILED_TO_GET_DISPLAY_NAME,
            [Status(40665)] [Reflection.DescriptionAttribute("no name provided")] NO_NAME_PROVIDED,
            [Status(35198)] [Reflection.DescriptionAttribute("could not set display name")] COULD_NOT_SET_DISPLAY_NAME,
            [Status(63713)] [Reflection.DescriptionAttribute("timeout joining group")] TIMEOUT_JOINING_GROUP,
            [Status(32404)] [Reflection.DescriptionAttribute("timeout creating group")] TIMEOUT_CREATING_GROUP,
            [Status(00616)] [Reflection.DescriptionAttribute("timeout ejecting agent")] TIMEOUT_EJECTING_AGENT,
            [Status(25426)] [Reflection.DescriptionAttribute("timeout getting group role members")] TIMEOUT_GETTING_GROUP_ROLE_MEMBERS,
            [Status(31237)] [Reflection.DescriptionAttribute("timeout leaving group")] TIMEOUT_LEAVING_GROUP,
            [Status(43780)] [Reflection.DescriptionAttribute("timeout during teleport")] TIMEOUT_DURING_TELEPORT,
            [Status(46316)] [Reflection.DescriptionAttribute("timeout requesting sit")] TIMEOUT_REQUESTING_SIT,
            [Status(09111)] [Reflection.DescriptionAttribute("timeout getting land users")] TIMEOUT_GETTING_LAND_USERS,
            [Status(23364)] [Reflection.DescriptionAttribute("timeout getting script state")] TIMEOUT_GETTING_SCRIPT_STATE,
            [Status(26393)] [Reflection.DescriptionAttribute("timeout updating mute list")] TIMEOUT_UPDATING_MUTE_LIST,
            [Status(32362)] [Reflection.DescriptionAttribute("timeout getting parcels")] TIMEOUT_GETTING_PARCELS,
            [Status(46942)] [Reflection.DescriptionAttribute("empty classified name")] EMPTY_CLASSIFIED_NAME,
            [Status(38184)] [Reflection.DescriptionAttribute("invalid price")] INVALID_PRICE,
            [Status(59103)] [Reflection.DescriptionAttribute("timeout getting classifieds")] TIMEOUT_GETTING_CLASSIFIEDS,
            [Status(08241)] [Reflection.DescriptionAttribute("could not find classified")] COULD_NOT_FIND_CLASSIFIED,
            [Status(53947)] [Reflection.DescriptionAttribute("invalid days")] INVALID_DAYS,
            [Status(18490)] [Reflection.DescriptionAttribute("invalid interval")] INVALID_INTERVAL,
            [Status(53829)] [Reflection.DescriptionAttribute("timeout getting group account summary")] TIMEOUT_GETTING_GROUP_ACCOUNT_SUMMARY,
            [Status(30207)] [Reflection.DescriptionAttribute("friend not found")] FRIEND_NOT_FOUND,
            [Status(32366)] [Reflection.DescriptionAttribute("the agent already is a friend")] AGENT_ALREADY_FRIEND,
            [Status(04797)] [Reflection.DescriptionAttribute("friendship offer not found")] FRIENDSHIP_OFFER_NOT_FOUND,
            [Status(65003)] [Reflection.DescriptionAttribute("friend does not allow mapping")] FRIEND_DOES_NOT_ALLOW_MAPPING,
            [Status(10691)] [Reflection.DescriptionAttribute("timeout mapping friend")] TIMEOUT_MAPPING_FRIEND,
            [Status(23309)] [Reflection.DescriptionAttribute("friend offline")] FRIEND_OFFLINE,
            [Status(34964)] [Reflection.DescriptionAttribute("timeout getting region")] TIMEOUT_GETTING_REGION,
            [Status(35447)] [Reflection.DescriptionAttribute("region not found")] REGION_NOT_FOUND,
            [Status(00337)] [Reflection.DescriptionAttribute("no map items found")] NO_MAP_ITEMS_FOUND,
            [Status(53549)] [Reflection.DescriptionAttribute("no description provided")] NO_DESCRIPTION_PROVIDED,
            [Status(43982)] [Reflection.DescriptionAttribute("no folder specified")] NO_FOLDER_SPECIFIED,
            [Status(29512)] [Reflection.DescriptionAttribute("empty wearables")] EMPTY_WEARABLES,
            [Status(35316)] [Reflection.DescriptionAttribute("parcel not for sale")] PARCEL_NOT_FOR_SALE,
            [Status(42051)] [Reflection.DescriptionAttribute("unknown access list type")] UNKNOWN_ACCESS_LIST_TYPE,
            [Status(29438)] [Reflection.DescriptionAttribute("no task specified")] NO_TASK_SPECIFIED,
            [Status(37470)] [Reflection.DescriptionAttribute("timeout getting group members")] TIMEOUT_GETTING_GROUP_MEMBERS,
            [Status(24939)] [Reflection.DescriptionAttribute("group not open")] GROUP_NOT_OPEN,
            [Status(30384)] [Reflection.DescriptionAttribute("timeout downloading terrain")] TIMEOUT_DOWNLOADING_ASSET,
            [Status(57005)] [Reflection.DescriptionAttribute("timeout uploading terrain")] TIMEOUT_UPLOADING_ASSET,
            [Status(16667)] [Reflection.DescriptionAttribute("empty terrain data")] EMPTY_ASSET_DATA,
            [Status(34749)] [Reflection.DescriptionAttribute("the specified folder contains no equipable items")] NO_EQUIPABLE_ITEMS,
            [Status(42249)] [Reflection.DescriptionAttribute("inventory offer not found")] INVENTORY_OFFER_NOT_FOUND,
            [Status(23805)] [Reflection.DescriptionAttribute("no session specified")] NO_SESSION_SPECIFIED,
            [Status(61018)] [Reflection.DescriptionAttribute("folder not found")] FOLDER_NOT_FOUND,
            [Status(37211)] [Reflection.DescriptionAttribute("timeout creating item")] TIMEOUT_CREATING_ITEM,
            [Status(09541)] [Reflection.DescriptionAttribute("timeout uploading item")] TIMEOUT_UPLOADING_ITEM,
            [Status(36684)] [Reflection.DescriptionAttribute("unable to upload item")] UNABLE_TO_UPLOAD_ITEM,
            [Status(05034)] [Reflection.DescriptionAttribute("unable to create item")] UNABLE_TO_CREATE_ITEM,
            [Status(44397)] [Reflection.DescriptionAttribute("timeout uploading item data")] TIMEOUT_UPLOADING_ITEM_DATA,
            [Status(12320)] [Reflection.DescriptionAttribute("unable to upload item data")] UNABLE_TO_UPLOAD_ITEM_DATA,
            [Status(55979)] [Reflection.DescriptionAttribute("unknown direction")] UNKNOWN_DIRECTION,
            [Status(22576)] [Reflection.DescriptionAttribute("timeout requesting to set home")] TIMEOUT_REQUESTING_TO_SET_HOME,
            [Status(07255)] [Reflection.DescriptionAttribute("timeout transferring asset")] TIMEOUT_TRANSFERRING_ASSET,
            [Status(60269)] [Reflection.DescriptionAttribute("asset upload failed")] ASSET_UPLOAD_FAILED,
            [Status(57085)] [Reflection.DescriptionAttribute("failed to download asset")] FAILED_TO_DOWNLOAD_ASSET,
            [Status(60025)] [Reflection.DescriptionAttribute("unknown asset type")] UNKNOWN_ASSET_TYPE,
            [Status(59048)] [Reflection.DescriptionAttribute("invalid asset data")] INVALID_ASSET_DATA,
            [Status(32709)] [Reflection.DescriptionAttribute("unknown wearable type")] UNKNOWN_WEARABLE_TYPE,
            [Status(06097)] [Reflection.DescriptionAttribute("unknown inventory type")] UNKNOWN_INVENTORY_TYPE,
            [Status(64698)] [Reflection.DescriptionAttribute("could not compile regular expression")] COULD_NOT_COMPILE_REGULAR_EXPRESSION,
            [Status(18680)] [Reflection.DescriptionAttribute("no pattern provided")] NO_PATTERN_PROVIDED,
            [Status(11910)] [Reflection.DescriptionAttribute("no executable file provided")] NO_EXECUTABLE_FILE_PROVIDED,
            [Status(31381)] [Reflection.DescriptionAttribute("timeout waiting for execution")] TIMEOUT_WAITING_FOR_EXECUTION,
            [Status(04541)] [Reflection.DescriptionAttribute("group invite not found")] GROUP_INVITE_NOT_FOUND,
            [Status(38125)] [Reflection.DescriptionAttribute("unable to obtain money balance")] UNABLE_TO_OBTAIN_MONEY_BALANCE,
            [Status(20048)] [Reflection.DescriptionAttribute("timeout getting avatar data")] TIMEOUT_GETTING_AVATAR_DATA,
            [Status(13712)] [Reflection.DescriptionAttribute("timeout retrieving estate list")] TIMEOUT_RETRIEVING_ESTATE_LIST,
            [Status(37559)] [Reflection.DescriptionAttribute("destination too close")] DESTINATION_TOO_CLOSE,
            [Status(11229)] [Reflection.DescriptionAttribute("timeout getting group titles")] TIMEOUT_GETTING_GROUP_TITLES,
            [Status(47101)] [Reflection.DescriptionAttribute("no message provided")] NO_MESSAGE_PROVIDED,
            [Status(04075)] [Reflection.DescriptionAttribute("could not remove SIML package file")] COULD_NOT_REMOVE_SIML_PACKAGE_FILE,
            [Status(54456)] [Reflection.DescriptionAttribute("unknown effect")] UNKNOWN_EFFECT,
            [Status(48775)] [Reflection.DescriptionAttribute("no effect UUID provided")] NO_EFFECT_UUID_PROVIDED,
            [Status(38858)] [Reflection.DescriptionAttribute("effect not found")] EFFECT_NOT_FOUND,
            [Status(16572)] [Reflection.DescriptionAttribute("invalid viewer effect")] INVALID_VIEWER_EFFECT,
            [Status(19011)] [Reflection.DescriptionAttribute("ambiguous path")] AMBIGUOUS_PATH,
            [Status(53066)] [Reflection.DescriptionAttribute("path not found")] PATH_NOT_FOUND,
            [Status(13857)] [Reflection.DescriptionAttribute("unexpected item in path")] UNEXPECTED_ITEM_IN_PATH,
            [Status(59282)] [Reflection.DescriptionAttribute("no path provided")] NO_PATH_PROVIDED,
            [Status(26623)] [Reflection.DescriptionAttribute("unable to create folder")] UNABLE_TO_CREATE_FOLDER,
            [Status(28866)] [Reflection.DescriptionAttribute("no permissions provided")] NO_PERMISSIONS_PROVIDED,
            [Status(43615)] [Reflection.DescriptionAttribute("setting permissions failed")] SETTING_PERMISSIONS_FAILED,
            [Status(39391)] [Reflection.DescriptionAttribute("expected item as source")] EXPECTED_ITEM_AS_SOURCE,
            [Status(22655)] [Reflection.DescriptionAttribute("expected folder as target")] EXPECTED_FOLDER_AS_TARGET,
            [Status(63024)] [Reflection.DescriptionAttribute("unable to load configuration")] UNABLE_TO_LOAD_CONFIGURATION,
            [Status(33564)] [Reflection.DescriptionAttribute("unable to save configuration")] UNABLE_TO_SAVE_CONFIGURATION,
            [Status(20900)] [Reflection.DescriptionAttribute("invalid xml path")] INVALID_XML_PATH,
            [Status(03638)] [Reflection.DescriptionAttribute("no data provided")] NO_DATA_PROVIDED,
            [Status(42903)] [Reflection.DescriptionAttribute("unknown image format requested")] UNKNOWN_IMAGE_FORMAT_REQUESTED,
            [Status(02380)] [Reflection.DescriptionAttribute("unknown image format provided")] UNKNOWN_IMAGE_FORMAT_PROVIDED,
            [Status(04994)] [Reflection.DescriptionAttribute("unable to decode asset data")] UNABLE_TO_DECODE_ASSET_DATA,
            [Status(61067)] [Reflection.DescriptionAttribute("unable to convert to requested format")] UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT,
            [Status(08411)] [Reflection.DescriptionAttribute("could not start process")] COULD_NOT_START_PROCESS,
            [Status(22737)] [Reflection.DescriptionAttribute("object not found")] OBJECT_NOT_FOUND,
            [Status(19143)] [Reflection.DescriptionAttribute("timeout meshmerizing object")] COULD_NOT_MESHMERIZE_OBJECT,
            [Status(37841)] [Reflection.DescriptionAttribute("could not get primitive properties")] COULD_NOT_GET_PRIMITIVE_PROPERTIES,
            [Status(54854)] [Reflection.DescriptionAttribute("avatar not in range")] AVATAR_NOT_IN_RANGE,
            [Status(03475)] [Reflection.DescriptionAttribute("invalid scale")] INVALID_SCALE,
            [Status(30129)] [Reflection.DescriptionAttribute("could not get current groups")] COULD_NOT_GET_CURRENT_GROUPS,
            [Status(39613)] [Reflection.DescriptionAttribute("maximum number of groups reached")] MAXIMUM_NUMBER_OF_GROUPS_REACHED,
            [Status(43003)] [Reflection.DescriptionAttribute("unknown syntax type")] UNKNOWN_SYNTAX_TYPE,
            [Status(13053)] [Reflection.DescriptionAttribute("too many characters for group name")] TOO_MANY_CHARACTERS_FOR_GROUP_NAME,
            [Status(19325)] [Reflection.DescriptionAttribute("too many characters for group title")] TOO_MANY_CHARACTERS_FOR_GROUP_TITLE,
            [Status(26178)] [Reflection.DescriptionAttribute("too many characters for notice message")] TOO_MANY_CHARACTERS_FOR_NOTICE_MESSAGE,
            [Status(35277)] [Reflection.DescriptionAttribute("notecard message body too large")] NOTECARD_MESSAGE_BODY_TOO_LARGE,
            [Status(47571)] [Reflection.DescriptionAttribute("too many or too few characters for display name")] TOO_MANY_OR_TOO_FEW_CHARACTERS_FOR_DISPLAY_NAME,
            [Status(30293)] [Reflection.DescriptionAttribute("name too large")] NAME_TOO_LARGE,
            [Status(60515)] [Reflection.DescriptionAttribute("position would exceed maximum rez altitude")] POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE,
            [Status(43683)] [Reflection.DescriptionAttribute("description too large")] DESCRIPTION_TOO_LARGE,
            [Status(54154)] [Reflection.DescriptionAttribute("scale would exceed building constraints")] SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS,
            [Status(29745)] [Reflection.DescriptionAttribute("attachments would exceed maximum attachment limit")] ATTACHMENTS_WOULD_EXCEED_MAXIMUM_ATTACHMENT_LIMIT,
            [Status(52299)] [Reflection.DescriptionAttribute("too many or too few characters in message")] TOO_MANY_OR_TOO_FEW_CHARACTERS_IN_MESSAGE,
            [Status(50593)] [Reflection.DescriptionAttribute("maximum ban list length reached")] MAXIMUM_BAN_LIST_LENGTH_REACHED,
            [Status(09935)] [Reflection.DescriptionAttribute("maximum group list length reached")] MAXIMUM_GROUP_LIST_LENGTH_REACHED,
            [Status(42536)] [Reflection.DescriptionAttribute("maximum user list length reached")] MAXIMUM_USER_LIST_LENGTH_REACHED,
            [Status(28625)] [Reflection.DescriptionAttribute("maximum manager list length reached")] MAXIMUM_MANAGER_LIST_LENGTH_REACHED,
            [Status(28126)] [Reflection.DescriptionAttribute("auto return time outside limit range")] AUTO_RETURN_TIME_OUTSIDE_LIMIT_RANGE,
            [Status(56379)] [Reflection.DescriptionAttribute("second life text too large")] SECOND_LIFE_TEXT_TOO_LARGE,
            [Status(09924)] [Reflection.DescriptionAttribute("first life text too large")] FIRST_LIFE_TEXT_TOO_LARGE,
            [Status(50405)] [Reflection.DescriptionAttribute("maximum amount of picks reached")] MAXIMUM_AMOUNT_OF_PICKS_REACHED,
            [Status(17894)] [Reflection.DescriptionAttribute("description would exceed maximum size")] DESCRIPTION_WOULD_EXCEED_MAXIMUM_SIZE,
            [Status(28247)] [Reflection.DescriptionAttribute("maximum amount of classifieds reached")] MAXIMUM_AMOUNT_OF_CLASSIFIEDS_REACHED,
            [Status(38609)] [Reflection.DescriptionAttribute("timeout changing links")] TIMEOUT_CHANGING_LINKS,
            [Status(45074)] [Reflection.DescriptionAttribute("link would exceed maximum link limit")] LINK_WOULD_EXCEED_MAXIMUM_LINK_LIMIT,
            [Status(40773)] [Reflection.DescriptionAttribute("invalid number of items specified")] INVALID_NUMBER_OF_ITEMS_SPECIFIED,
            [Status(52751)] [Reflection.DescriptionAttribute("timeout requesting price")] TIMEOUT_REQUESTING_PRICE,
            [Status(01536)] [Reflection.DescriptionAttribute("primitive not for sale")] PRIMITIVE_NOT_FOR_SALE,
            [Status(36123)] [Reflection.DescriptionAttribute("teleport throttled")] TELEPORT_THROTTLED,
            [Status(06617)] [Reflection.DescriptionAttribute("no matching dialog found")] NO_MATCHING_DIALOG_FOUND,
            [Status(08842)] [Reflection.DescriptionAttribute("unknown tree type")] UNKNOWN_TREE_TYPE,
            [Status(62130)] [Reflection.DescriptionAttribute("invalid texture coordinates")] INVALID_TEXTURE_COORDINATES,
            [Status(10945)] [Reflection.DescriptionAttribute("invalid surface coordinates")] INVALID_SURFACE_COORDINATES,
            [Status(28487)] [Reflection.DescriptionAttribute("invalid normal vector")] INVALID_NORMAL_VECTOR,
            [Status(13296)] [Reflection.DescriptionAttribute("invalid binormal vector")] INVALID_BINORMAL_VECTOR,
            [Status(44554)] [Reflection.DescriptionAttribute("primitives not in same region")] PRIMITIVES_NOT_IN_SAME_REGION,
            [Status(38798)] [Reflection.DescriptionAttribute("invalid face specified")] INVALID_FACE_SPECIFIED,
            [Status(61473)] [Reflection.DescriptionAttribute("invalid status supplied")] INVALID_STATUS_SUPPLIED,
            [Status(13764)] [Reflection.DescriptionAttribute("status not found")] STATUS_NOT_FOUND,
            [Status(30556)] [Reflection.DescriptionAttribute("no description for status")] NO_DESCRIPTION_FOR_STATUS,
            [Status(64368)] [Reflection.DescriptionAttribute("unknown grass type")] UNKNOWN_GRASS_TYPE,
            [Status(53274)] [Reflection.DescriptionAttribute("unknown material type")] UNKNOWN_MATERIAL_TYPE,
            [Status(18463)] [Reflection.DescriptionAttribute("could not retrieve object media")] COULD_NOT_RETRIEVE_OBJECT_MEDIA,
            [Status(02193)] [Reflection.DescriptionAttribute("no avatars to ban or unban")] NO_AVATARS_TO_BAN_OR_UNBAN,
            [Status(45568)] [Reflection.DescriptionAttribute("could not retrieve broup ban list")] COULD_NOT_RETRIEVE_GROUP_BAN_LIST,
            [Status(15719)] [Reflection.DescriptionAttribute("timeout retrieving group ban list")] TIMEOUT_RETRIEVING_GROUP_BAN_LIST,
            [Status(26749)] [Reflection.DescriptionAttribute("timeout modifying group ban list")] TIMEOUT_MODIFYING_GROUP_BAN_LIST,
            [Status(26715)] [Reflection.DescriptionAttribute("mute entry not found")] MUTE_ENTRY_NOT_FOUND,
            [Status(51086)] [Reflection.DescriptionAttribute("no name or UUID provided")] NO_NAME_OR_UUID_PROVIDED,
            [Status(16450)] [Reflection.DescriptionAttribute("could not retrieve mute list")] COULD_NOT_RETRIEVE_MUTE_LIST,
            [Status(39647)] [Reflection.DescriptionAttribute("mute entry already exists")] MUTE_ENTRY_ALREADY_EXISTS,
            [Status(39787)] [Reflection.DescriptionAttribute("timeout reaching destination")] TIMEOUT_REACHING_DESTINATION,
            [Status(10776)] [Reflection.DescriptionAttribute("group schedules exceeded")] GROUP_SCHEDULES_EXCEEDED,
            [Status(36896)] [Reflection.DescriptionAttribute("no index provided")] NO_INDEX_PROVIDED,
            [Status(56094)] [Reflection.DescriptionAttribute("no schedule found")] NO_SCHEDULE_FOUND,
            [Status(41612)] [Reflection.DescriptionAttribute("unknown date time stamp")] UNKNOWN_DATE_TIME_STAMP,
            [Status(07457)] [Reflection.DescriptionAttribute("no permissions for item")] NO_PERMISSIONS_FOR_ITEM,
            [Status(10374)] [Reflection.DescriptionAttribute("timeout retrieving estate covenant")] TIMEOUT_RETRIEVING_ESTATE_COVENANT,
            [Status(56901)] [Reflection.DescriptionAttribute("no terraform action specified")] NO_TERRAFORM_ACTION_SPECIFIED,
            [Status(41211)] [Reflection.DescriptionAttribute("no terraform brush specified")] NO_TERRAFORM_BRUSH_SPECIFIED,
            [Status(63486)] [Reflection.DescriptionAttribute("invalid height")] INVALID_HEIGHT,
            [Status(20547)] [Reflection.DescriptionAttribute("invalid width")] INVALID_WIDTH,
            [Status(28891)] [Reflection.DescriptionAttribute("invalid terraform action")] INVALID_TERRAFORM_ACTION,
            [Status(41190)] [Reflection.DescriptionAttribute("invalid terraform brush")] INVALID_TERRAFORM_BRUSH,
            [Status(58619)] [Reflection.DescriptionAttribute("could not terraform")] COULD_NOT_TERRAFORM,
            [Status(38289)] [Reflection.DescriptionAttribute("timeout waiting for display name")] TIMEOUT_WAITING_FOR_DISPLAY_NAME,
            [Status(51050)] [Reflection.DescriptionAttribute("script permission request not found")] SCRIPT_PERMISSION_REQUEST_NOT_FOUND,
            [Status(60073)] [Reflection.DescriptionAttribute("teleport lure not found")] TELEPORT_LURE_NOT_FOUND,
            [Status(42248)] [Reflection.DescriptionAttribute("unable to save Corrade configuration")] UNABLE_TO_SAVE_CORRADE_CONFIGURATION,
            [Status(26356)] [Reflection.DescriptionAttribute("timeout retrieving group notices")] TIMEOUT_RETRIEVING_GROUP_NOTICES,
            [Status(42798)] [Reflection.DescriptionAttribute("timeout retrieving notice")] TIMEOUT_RETRIEVING_NOTICE,
            [Status(06330)] [Reflection.DescriptionAttribute("no notice found")] NO_NOTICE_FOUND,
            [Status(20303)] [Reflection.DescriptionAttribute("notice does not contain attachment")] NOTICE_DOES_NOT_CONTAIN_ATTACHMENT,
            [Status(10522)] [Reflection.DescriptionAttribute("failed to read log file")] FAILED_TO_READ_LOG_FILE,
            [Status(62646)] [Reflection.DescriptionAttribute("effect UUID belongs to different effect")] EFFECT_UUID_BELONGS_TO_DIFFERENT_EFFECT,
            [Status(25252)] [Reflection.DescriptionAttribute("no SQL string provided")] NO_SQL_STRING_PROVIDED,
            [Status(45173)] [Reflection.DescriptionAttribute("invalid angle provided")] INVALID_ANGLE_PROVIDED,
            [Status(32453)] [Reflection.DescriptionAttribute("could not get parcel info data")] COULD_NOT_GET_PARCEL_INFO,
            [Status(02188)] [Reflection.DescriptionAttribute("could not get parcel info data")] NO_TARGET_SPECIFIED,
            [Status(47350)] [Reflection.DescriptionAttribute("no type provided")] NO_TYPE_PROVIDED,
            [Status(64450)] [Reflection.DescriptionAttribute("unknown sift")] UNKNOWN_SIFT,
            [Status(28353)] [Reflection.DescriptionAttribute("invalid feed provided")] INVALID_FEED_PROVIDED,
            [Status(34869)] [Reflection.DescriptionAttribute("already subscribed to feed")] ALREADY_SUBSCRIBED_TO_FEED,
            [Status(32157)] [Reflection.DescriptionAttribute("no consumer key provided")] NO_CONSUMER_KEY_PROVIDED,
            [Status(40762)] [Reflection.DescriptionAttribute("no consumer secret provided")] NO_CONSUMER_SECRET_PROVIDED,
            [Status(13399)] [Reflection.DescriptionAttribute("no access token provided")] NO_ACCESS_TOKEN_PROVIDED,
            [Status(55091)] [Reflection.DescriptionAttribute("no access token secret provided")] NO_ACCESS_TOKEN_SECRET_PROVIDED,
            [Status(55051)] [Reflection.DescriptionAttribute("message too long")] MESSAGE_TOO_LONG,
            [Status(18672)] [Reflection.DescriptionAttribute("could not post tweet")] COULD_NOT_POST_TWEET,
            [Status(25119)] [Reflection.DescriptionAttribute("unable to retrieve transactions")] UNABLE_TO_RETRIEVE_TRANSACTIONS,
            [Status(54668)] [Reflection.DescriptionAttribute("unable to authenticate")] UNABLE_TO_AUTHENTICATE,
            [Status(40491)] [Reflection.DescriptionAttribute("no transactions found")] NO_TRANSACTIONS_FOUND,
            [Status(41007)] [Reflection.DescriptionAttribute("no secret provided")] NO_SECRET_PROVIDED,
            [Status(21833)] [Reflection.DescriptionAttribute("invalid date")] INVALID_DATE,
            [Status(33381)] [Reflection.DescriptionAttribute("unable to reach events page")] UNABLE_TO_REACH_EVENTS_PAGE,
            [Status(54450)] [Reflection.DescriptionAttribute("unable to agree to ToS")] UNABLE_TO_AGREE_TO_TOS,
            [Status(01691)] [Reflection.DescriptionAttribute("unable to post event")] UNABLE_TO_POST_EVENT,
            [Status(44059)] [Reflection.DescriptionAttribute("unable to get event identifier")] UNABLE_TO_GET_EVENT_IDENTIFIER,
            [Status(63915)] [Reflection.DescriptionAttribute("no time provided")] NO_TIME_PROVIDED,
            [Status(57196)] [Reflection.DescriptionAttribute("no duration provided")] NO_DURATION_PROVIDED,
            [Status(63597)] [Reflection.DescriptionAttribute("no date provided")] NO_DATE_PROVIDED,
            [Status(25003)] [Reflection.DescriptionAttribute("no category provided")] NO_CATEGORY_PROVIDED,
            [Status(21718)] [Reflection.DescriptionAttribute("no location provided")] NO_LOCATION_PROVIDED,
            [Status(23926)] [Reflection.DescriptionAttribute("unable to delete event")] UNABLE_TO_DELETE_EVENT,
            [Status(08339)] [Reflection.DescriptionAttribute("no event identifier provided")] NO_EVENT_IDENTIFIER_PROVIDED,
            [Status(33994)] [Reflection.DescriptionAttribute("unable to retrieve form parameters")] UNABLE_TO_RETRIEVE_FORM_PARAMETERS,
            [Status(53494)] [Reflection.DescriptionAttribute("too many characters for event description")] TOO_MANY_CHARACTERS_FOR_EVENT_DESCRIPTION,
            [Status(58751)] [Reflection.DescriptionAttribute("name may not contain HTML")] NAME_MAY_NOT_CONTAIN_HTML,
            [Status(54528)] [Reflection.DescriptionAttribute("description may not contain HTML")] DESCRIPTION_MAY_NOT_CONTAIN_HTML,
            [Status(21743)] [Reflection.DescriptionAttribute("event posting rejected")] EVENT_POSTING_REJECTED,
            [Status(43671)] [Reflection.DescriptionAttribute("unable to revoke proposal")] UNABLE_TO_REVOKE_PROPOSAL,
            [Status(50003)] [Reflection.DescriptionAttribute("unable to reject proposal")] UNABLE_TO_REJECT_PROPOSAL,
            [Status(56345)] [Reflection.DescriptionAttribute("unable to reach partnership page")] UNABLE_TO_REACH_PARTNERSHIP_PAGE,
            [Status(00303)] [Reflection.DescriptionAttribute("unable to post proposal")] UNABLE_TO_POST_PROPOSAL,
            [Status(61983)] [Reflection.DescriptionAttribute("unable to accept proposal")] UNABLE_TO_ACCEPT_PROPOSAL,
            [Status(31126)] [Reflection.DescriptionAttribute("too many characters for proposal message")] TOO_MANY_CHARACTERS_FOR_PROPOSAL_MESSAGE,
            [Status(34379)] [Reflection.DescriptionAttribute("proposal rejected")] PROPOSAL_REJECTED,
            [Status(43767)] [Reflection.DescriptionAttribute("proposal already sent")] PROPOSAL_ALREADY_SENT,
            [Status(22119)] [Reflection.DescriptionAttribute("no proposal to reject")] NO_PROPOSAL_TO_REJECT,
            [Status(21106)] [Reflection.DescriptionAttribute("message may not contain HTML")] MESSAGE_MAY_NOT_CONTAIN_HTML,
            [Status(46612)] [Reflection.DescriptionAttribute("no partner found")] NO_PARTNER_FOUND,
            [Status(41257)] [Reflection.DescriptionAttribute("unable to post divorce")] UNABLE_TO_POST_DIVORCE,
            [Status(58870)] [Reflection.DescriptionAttribute("unable to divorce")] UNABLE_TO_DIVORCE,
            [Status(31267)] [Reflection.DescriptionAttribute("agent has been banned")] AGENT_HAS_BEEN_BANNED,
            [Status(16927)] [Reflection.DescriptionAttribute("no estate powers for command")] NO_ESTATE_POWERS_FOR_COMMAND,
            [Status(21160)] [Reflection.DescriptionAttribute("unable to write file")] UNABLE_TO_WRITE_FILE,
            [Status(38278)] [Reflection.DescriptionAttribute("unable to read file")] UNABLE_TO_READ_FILE,
            [Status(19343)] [Reflection.DescriptionAttribute("unable to retrive data")] UNABLE_TO_RETRIEVE_DATA,
            [Status(18737)] [Reflection.DescriptionAttribute("unable to process data")] UNABLE_TO_PROCESS_DATA,
            [Status(33047)] [Reflection.DescriptionAttribute("failed rezzing root primitive")] FAILED_REZZING_ROOT_PRIMITIVE,
            [Status(25329)] [Reflection.DescriptionAttribute("failed rezzing child primitive")] FAILED_REZZING_CHILD_PRIMITIVE,
            [Status(29530)] [Reflection.DescriptionAttribute("could not read XML file")] COULD_NOT_READ_XML_FILE,
            [Status(40901)] [Reflection.DescriptionAttribute("SIML not enabled")] SIML_NOT_ENABLED,
            [Status(14989)] [Reflection.DescriptionAttribute("no avatars found")] NO_AVATARS_FOUND,
            [Status(42351)] [Reflection.DescriptionAttribute("timeout starting conference")] TIMEOUT_STARTING_CONFERENCE,
            [Status(41969)] [Reflection.DescriptionAttribute("unable to start conference")] UNABLE_TO_START_CONFERENCE,
            [Status(43898)] [Reflection.DescriptionAttribute("session not found")] SESSION_NOT_FOUND,
            [Status(22786)] [Reflection.DescriptionAttribute("conference member not found")] CONFERENCE_MEMBER_NOT_FOUND,
            [Status(46804)] [Reflection.DescriptionAttribute("could not send message")] COULD_NOT_SEND_MESSAGE
        }

        /// <summary>
        ///     Semaphores that sense the state of the connection. When any of these semaphores fail,
        ///     Corrade does not consider itself connected anymore and terminates.
        /// </summary>
        private static readonly Dictionary<char, ManualResetEvent> ConnectionSemaphores = new Dictionary
            <char, ManualResetEvent>
        {
            {'l', new ManualResetEvent(false)},
            {'s', new ManualResetEvent(false)},
            {'u', new ManualResetEvent(false)}
        };

        public static string InstalledServiceName;
        private static Configuration corradeConfiguration = new Configuration();
        private static Thread programThread;
        private static Thread HTTPListenerThread;
        private static Thread TCPNotificationsThread;
        private static TcpListener TCPListener;
        private static HttpListener HTTPListener;
        private static Thread EffectsExpirationThread;
        private static Thread GroupSchedulesThread;
        private static readonly Random CorradeRandom = new Random();
        private static readonly EventLog CorradeEventLog = new EventLog();
        private static readonly GridClient Client = new GridClient();
        private static InventoryFolder CurrentOutfitFolder;
        private static readonly SimlBot SynBot = new SimlBot();
        private static RankedLanguageIdentifier rankedLanguageIdentifier;
        private static readonly FileSystemWatcher SIMLBotConfigurationWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher ConfigurationWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher NotificationsWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher SchedulesWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher GroupFeedWatcher = new FileSystemWatcher();
        private static readonly object SIMLBotLock = new object();
        private static readonly object ConfigurationFileLock = new object();
        private static readonly object ClientLogFileLock = new object();
        private static readonly object GroupLogFileLock = new object();
        private static readonly object LocalLogFileLock = new object();
        private static readonly object RegionLogFileLock = new object();
        private static readonly object InstantMessageLogFileLock = new object();
        private static readonly object ConferenceMessageLogFileLock = new object();

        private static readonly Time.TimedThrottle TimedTeleportThrottle =
            new Time.TimedThrottle(Constants.TELEPORTS.THROTTLE.MAX_TELEPORTS,
                Constants.TELEPORTS.THROTTLE.GRACE_SECONDS);

        private static readonly object GroupNotificationsLock = new object();
        private static HashSet<Notification> GroupNotifications = new HashSet<Notification>();

        private static readonly Dictionary<Configuration.Notifications, HashSet<Notification>> GroupNotificationsCache =
            new Dictionary<Configuration.Notifications, HashSet<Notification>>();

        private static readonly Collections.SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>
            InventoryOffers =
                new Collections.SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>();

        private static readonly object InventoryOffersLock = new object();

        private static readonly
            Collections.SerializableDictionary<string, Collections.SerializableDictionary<UUID, string>> GroupFeeds =
                new Collections.SerializableDictionary<string, Collections.SerializableDictionary<UUID, string>>();

        private static readonly object GroupFeedsLock = new object();

        private static readonly BlockingQueue<CallbackQueueElement> CallbackQueue =
            new BlockingQueue<CallbackQueueElement>();

        private static readonly BlockingQueue<NotificationQueueElement> NotificationQueue =
            new BlockingQueue<NotificationQueueElement>();

        private static readonly BlockingQueue<NotificationTCPQueueElement> NotificationTCPQueue =
            new BlockingQueue<NotificationTCPQueueElement>();

        private static readonly HashSet<GroupInvite> GroupInvites = new HashSet<GroupInvite>();
        private static readonly object GroupInviteLock = new object();
        private static readonly HashSet<GroupNotice> GroupNotices = new HashSet<GroupNotice>();
        private static readonly object GroupNoticeLock = new object();
        private static readonly HashSet<TeleportLure> TeleportLures = new HashSet<TeleportLure>();
        private static readonly object TeleportLureLock = new object();
        // permission requests can be identical
        private static readonly List<ScriptPermissionRequest> ScriptPermissionRequests =
            new List<ScriptPermissionRequest>();

        private static readonly object ScriptPermissionRequestLock = new object();
        // script dialogs can be identical
        private static readonly List<ScriptDialog> ScriptDialogs = new List<ScriptDialog>();
        private static readonly object ScriptDialogLock = new object();

        private static readonly HashSet<KeyValuePair<UUID, int>> CurrentAnimations =
            new HashSet<KeyValuePair<UUID, int>>();

        private static readonly object CurrentAnimationsLock = new object();

        private static readonly Collections.SerializableDictionary<UUID, HashSet<UUID>> GroupMembers =
            new Collections.SerializableDictionary<UUID, HashSet<UUID>>();

        private static readonly object GroupMembersLock = new object();
        private static readonly Hashtable GroupWorkers = new Hashtable();
        private static readonly object GroupWorkersLock = new object();
        private static readonly Hashtable GroupDirectoryTrackers = new Hashtable();
        private static readonly object GroupDirectoryTrackersLock = new object();
        private static readonly HashSet<LookAtEffect> LookAtEffects = new HashSet<LookAtEffect>();
        private static readonly HashSet<PointAtEffect> PointAtEffects = new HashSet<PointAtEffect>();
        private static readonly HashSet<SphereEffect> SphereEffects = new HashSet<SphereEffect>();
        private static readonly object SphereEffectsLock = new object();
        private static readonly HashSet<BeamEffect> BeamEffects = new HashSet<BeamEffect>();
        private static readonly Dictionary<uint, Primitive> RadarObjects = new Dictionary<uint, Primitive>();
        private static readonly object LookAtEffectsLock = new object();
        private static readonly object PointAtEffectsLock = new object();
        private static readonly object RadarObjectsLock = new object();
        private static readonly object BeamEffectsLock = new object();
        private static readonly object InputFiltersLock = new object();
        private static readonly object OutputFiltersLock = new object();
        private static readonly HashSet<GroupSchedule> GroupSchedules = new HashSet<GroupSchedule>();
        private static readonly object GroupSchedulesLock = new object();
        private static readonly HashSet<Conference> Conferences = new HashSet<Conference>();
        private static readonly object ConferencesLock = new object();

        private static readonly Dictionary<UUID, CookieContainer> GroupCookieContainers =
            new Dictionary<UUID, CookieContainer>();

        private static readonly object GroupCookieContainersLock = new object();

        private static readonly Dictionary<UUID, Web.wasHTTPClient> GroupHTTPClients =
            new Dictionary<UUID, Web.wasHTTPClient>();

        private static readonly object GroupHTTPClientsLock = new object();

        private static string CorradePOSTMediaType;

        private static readonly Dictionary<string, Action<CorradeCommandParameters, Dictionary<string, string>>>
            corradeCommands = typeof (CorradeCommands).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel()
                .Where(
                    o =>
                        o.FieldType ==
                        typeof (Action<CorradeCommandParameters, Dictionary<string, string>>))
                .ToDictionary(
                    o => o.Name, o =>
                        (Action<CorradeCommandParameters, Dictionary<string, string>>) o.GetValue(null));

        private static readonly Dictionary<string, Action<CorradeNotificationParameters, Dictionary<string, string>>>
            corradeNotifications = typeof (CorradeNotifications).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel()
                .Where(
                    o =>
                        o.FieldType ==
                        typeof (Action<CorradeNotificationParameters, Dictionary<string, string>>))
                .ToDictionary(
                    o => o.Name, o =>
                        (Action<CorradeNotificationParameters, Dictionary<string, string>>) o.GetValue(null));

        private static readonly Dictionary<string, Action<string, RLVRule, UUID>>
            rlvBehaviours = typeof (RLVBehaviours).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel()
                .Where(
                    o =>
                        o.FieldType ==
                        typeof (Action<string, RLVRule, UUID>))
                .ToDictionary(
                    o => o.Name, o =>
                        (Action<string, RLVRule, UUID>) o.GetValue(null));

        /// <summary>
        ///     The various types of threads created by Corrade.
        /// </summary>
        private static readonly Dictionary<CorradeThreadType, CorradeThread> CorradeThreadPool =
            new Dictionary<CorradeThreadType, CorradeThread>
            {
                {CorradeThreadType.COMMAND, new CorradeThread(CorradeThreadType.COMMAND)},
                {CorradeThreadType.RLV, new CorradeThread(CorradeThreadType.RLV)},
                {CorradeThreadType.NOTIFICATION, new CorradeThread(CorradeThreadType.NOTIFICATION)},
                {CorradeThreadType.INSTANT_MESSAGE, new CorradeThread(CorradeThreadType.INSTANT_MESSAGE)},
                {CorradeThreadType.LOG, new CorradeThread(CorradeThreadType.LOG)},
                {CorradeThreadType.POST, new CorradeThread(CorradeThreadType.POST)}
            };

        /// <summary>
        ///     Group membership sweep thread.
        /// </summary>
        private static Thread GroupMembershipSweepThread;

        /// <summary>
        ///     Group feed thread.
        /// </summary>
        private static Thread GroupFeedThread;

        /// <summary>
        ///     Group feed thread starter.
        /// </summary>
        private static readonly System.Action StartGroupFeedThread = () =>
        {
            if (GroupFeedThread != null &&
                (GroupFeedThread.ThreadState.Equals(ThreadState.Running) ||
                 GroupFeedThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            runGroupFeedThread = true;
            GroupFeedThread = new Thread(CheckGroupFeeds)
            {
                IsBackground = true
            };
            GroupFeedThread.Start();
        };

        /// <summary>
        ///     Group feed thread stopper.
        /// </summary>
        private static readonly System.Action StopGroupFeedThread = () =>
        {
            // Stop the notification thread.
            runGroupFeedThread = false;
            if (GroupFeedThread == null ||
                (!GroupFeedThread.ThreadState.Equals(ThreadState.Running) &&
                 !GroupFeedThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            if (GroupFeedThread.Join(1000)) return;
            try
            {
                GroupFeedThread.Abort();
                GroupFeedThread.Join();
            }
            catch (ThreadStateException)
            {
            }
        };

        /// <summary>
        ///     Group membership sweep thread starter.
        /// </summary>
        private static readonly System.Action StartGroupMembershipSweepThread = () =>
        {
            if (GroupMembershipSweepThread != null &&
                (GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) ||
                 GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            runGroupMembershipSweepThread = true;
            GroupMembershipSweepThread = new Thread(GroupMembershipSweep)
            {
                IsBackground = true,
                Priority = ThreadPriority.Lowest
            };
            GroupMembershipSweepThread.Start();
        };

        /// <summary>
        ///     Group membership sweep thread stopper.
        /// </summary>
        private static readonly System.Action StopGroupMembershipSweepThread = () =>
        {
            // Stop the notification thread.
            runGroupMembershipSweepThread = false;
            if (GroupMembershipSweepThread == null ||
                (!GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) &&
                 !GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            if (GroupMembershipSweepThread.Join(1000)) return;
            try
            {
                GroupMembershipSweepThread.Abort();
                GroupMembershipSweepThread.Join();
            }
            catch (ThreadStateException)
            {
            }
        };

        /// <summary>
        ///     Schedules a load of the configuration file.
        /// </summary>
        private static readonly Timer ConfigurationChangedTimer =
            new Timer(ConfigurationChanged =>
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CONFIGURATION_FILE_MODIFIED));
                lock (ConfigurationFileLock)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READING_CORRADE_CONFIGURATION));
                    try
                    {
                        corradeConfiguration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE, ref corradeConfiguration);
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            Reflection.GetDescriptionFromEnumValue(
                                ConsoleError.UNABLE_TO_LOAD_CORRADE_CONFIGURATION),
                            ex.Message);
                        return;
                    }
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READ_CORRADE_CONFIGURATION));
                }
                if (!corradeConfiguration.Equals(default(Configuration)))
                {
                    UpdateDynamicConfiguration(corradeConfiguration);
                }
            });

        /// <summary>
        ///     Schedules a load of the notifications file.
        /// </summary>
        private static readonly Timer NotificationsChangedTimer =
            new Timer(NotificationsChanged =>
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.NOTIFICATIONS_FILE_MODIFIED));
                LoadNotificationState.Invoke();
            });

        /// <summary>
        ///     Schedules a load of the SIML configuration file.
        /// </summary>
        private static readonly Timer SIMLConfigurationChangedTimer =
            new Timer(SIMLConfigurationChanged =>
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.SIML_CONFIGURATION_MODIFIED));
                new Thread(
                    () =>
                    {
                        lock (SIMLBotLock)
                        {
                            LoadChatBotFiles.Invoke();
                        }
                    })
                {IsBackground = true}.Start();
            });

        /// <summary>
        ///     Schedules a load of the group schedules file.
        /// </summary>
        private static readonly Timer GroupSchedulesChangedTimer =
            new Timer(GroupSchedulesChanged =>
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.GROUP_SCHEDULES_FILE_MODIFIED));
                LoadGroupSchedulesState.Invoke();
            });

        /// <summary>
        ///     Schedules a load of the group feeds file.
        /// </summary>
        private static readonly Timer GroupFeedsChangedTimer =
            new Timer(GroupFeedsChanged =>
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.GROUP_FEEDS_FILE_MODIFIED));
                LoadGroupFeedState.Invoke();
            });

        /// <summary>
        ///     Global rebake timer.
        /// </summary>
        private static readonly Timer RebakeTimer = new Timer(Rebake =>
        {
            lock (Locks.ClientInstanceAppearanceLock)
            {
                var AppearanceSetEvent = new ManualResetEvent(false);
                EventHandler<AppearanceSetEventArgs> HandleAppearanceSet = (sender, args) => AppearanceSetEvent.Set();
                Client.Appearance.AppearanceSet += HandleAppearanceSet;
                Client.Appearance.RequestSetAppearance(true);
                AppearanceSetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false);
                Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            }
        });

        /// <summary>
        ///     Current land group activation timer.
        /// </summary>
        private static readonly Timer ActivateCurrentLandGroupTimer =
            new Timer(ActivateCurrentLandGroup =>
            {
                Parcel parcel = null;
                if (
                    !Services.GetParcelAtPosition(Client, Client.Network.CurrentSim, Client.Self.SimPosition,
                        corradeConfiguration.ServicesTimeout, ref parcel)) return;
                var groups = new HashSet<UUID>(corradeConfiguration.Groups.Select(o => o.UUID));
                if (!groups.Contains(parcel.GroupID)) return;
                Client.Groups.ActivateGroup(parcel.GroupID);
            });

        public static EventHandler ConsoleEventHandler;

        /// <summary>
        ///     Corrade's input filter function.
        /// </summary>
        private static readonly Func<string, string> wasInput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Configuration.Filter> safeFilters;
            lock (InputFiltersLock)
            {
                safeFilters = corradeConfiguration.InputFilters;
            }
            foreach (var filter in safeFilters)
            {
                switch (filter)
                {
                    case Configuration.Filter.RFC1738:
                        o = Web.URLUnescapeDataString(o);
                        break;
                    case Configuration.Filter.RFC3986:
                        o = Web.URIUnescapeDataString(o);
                        break;
                    case Configuration.Filter.ENIGMA:
                        o = Cryptography.ENIGMA(o, corradeConfiguration.ENIGMAConfiguration.rotors.ToArray(),
                            corradeConfiguration.ENIGMAConfiguration.plugs.ToArray(),
                            corradeConfiguration.ENIGMAConfiguration.reflector);
                        break;
                    case Configuration.Filter.VIGENERE:
                        o = Cryptography.DecryptVIGENERE(o, corradeConfiguration.VIGENERESecret);
                        break;
                    case Configuration.Filter.ATBASH:
                        o = Cryptography.ATBASH(o);
                        break;
                    case Configuration.Filter.AES:
                        o = wasAESDecrypt(o, corradeConfiguration.AESKey, corradeConfiguration.AESIV);
                        break;
                    case Configuration.Filter.BASE64:
                        o = Encoding.UTF8.GetString(Convert.FromBase64String(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Corrade's output filter function.
        /// </summary>
        private static readonly Func<string, string> wasOutput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Configuration.Filter> safeFilters;
            lock (OutputFiltersLock)
            {
                safeFilters = corradeConfiguration.OutputFilters;
            }
            foreach (var filter in safeFilters)
            {
                switch (filter)
                {
                    case Configuration.Filter.RFC1738:
                        o = Web.URLEscapeDataString(o);
                        break;
                    case Configuration.Filter.RFC3986:
                        o = Web.URIEscapeDataString(o);
                        break;
                    case Configuration.Filter.ENIGMA:
                        o = Cryptography.ENIGMA(o, corradeConfiguration.ENIGMAConfiguration.rotors.ToArray(),
                            corradeConfiguration.ENIGMAConfiguration.plugs.ToArray(),
                            corradeConfiguration.ENIGMAConfiguration.reflector);
                        break;
                    case Configuration.Filter.VIGENERE:
                        o = Cryptography.EncryptVIGENERE(o, corradeConfiguration.VIGENERESecret);
                        break;
                    case Configuration.Filter.ATBASH:
                        o = Cryptography.ATBASH(o);
                        break;
                    case Configuration.Filter.AES:
                        o = wasAESEncrypt(o, corradeConfiguration.AESKey, corradeConfiguration.AESIV);
                        break;
                    case Configuration.Filter.BASE64:
                        o = Convert.ToBase64String(Encoding.UTF8.GetBytes(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Determines whether a string is a Corrade command.
        /// </summary>
        /// <returns>true if the string is a Corrade command</returns>
        private static readonly Func<string, bool> IsCorradeCommand = o =>
        {
            var data = KeyValue.Decode(o);
            return data.Any() && data.ContainsKey(Reflection.GetNameFromEnumValue(ScriptKeys.COMMAND)) &&
                   data.ContainsKey(Reflection.GetNameFromEnumValue(ScriptKeys.GROUP)) &&
                   data.ContainsKey(Reflection.GetNameFromEnumValue(ScriptKeys.PASSWORD));
        };

        /// <summary>
        ///     Loads the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action LoadInventoryCache = () =>
        {
            int itemsLoaded;
            lock (Locks.ClientInstanceInventoryLock)
            {
                itemsLoaded = Client.Inventory.Store.RestoreFromDisk(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                    CORRADE_CONSTANTS.INVENTORY_CACHE_FILE));
            }

            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_LOADED),
                itemsLoaded < 0 ? "0" : itemsLoaded.ToString(Utils.EnUsCulture));
        };

        /// <summary>
        ///     Saves the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action SaveInventoryCache = () =>
        {
            var path = Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                CORRADE_CONSTANTS.INVENTORY_CACHE_FILE);
            int itemsSaved;
            lock (Locks.ClientInstanceInventoryLock)
            {
                itemsSaved = Client.Inventory.Store.Items.Count;
                Client.Inventory.Store.SaveToDisk(path);
            }

            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_SAVED),
                itemsSaved.ToString(Utils.EnUsCulture));
        };

        /// <summary>
        ///     Loads Corrade's caches.
        /// </summary>
        private static readonly System.Action LoadCorradeCache = () =>
        {
            new Thread(() =>
            {
                try
                {
                    Cache.AgentCache =
                        Cache.Load(
                            Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                            Cache.AgentCache);
                }
                catch (Exception ex)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_CACHE),
                        ex.Message);
                }
            })
            {IsBackground = true}.Start();

            new Thread(() =>
            {
                try
                {
                    Cache.GroupCache =
                        Cache.Load(
                            Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                            Cache.GroupCache);
                }
                catch (Exception ex)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_CACHE),
                        ex.Message);
                }
            })
            {IsBackground = true}.Start();
        };

        /// <summary>
        ///     Saves Corrade's caches.
        /// </summary>
        private static readonly System.Action SaveCorradeCache = () =>
        {
            new Thread(() =>
            {
                try
                {
                    Cache.Save(
                        Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                        Cache.AgentCache);
                }
                catch (Exception e)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_CACHE),
                        e.Message);
                }
            })
            {IsBackground = true}.Start();

            new Thread(() =>
            {
                try
                {
                    Cache.Save(
                        Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                        Cache.GroupCache);
                }
                catch (Exception e)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_CACHE),
                        e.Message);
                }
            })
            {IsBackground = true}.Start();
        };

        /// <summary>
        ///     Saves Corrade group members.
        /// </summary>
        private static readonly System.Action SaveGroupMembersState = () =>
        {
            try
            {
                lock (GroupMembersLock)
                {
                    using (
                        var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                            CORRADE_CONSTANTS.GROUP_MEMBERS_STATE_FILE), FileMode.Create,
                            FileAccess.Write, FileShare.None))
                    {
                        using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                        {
                            var serializer =
                                new XmlSerializer(typeof (Collections.SerializableDictionary<UUID, HashSet<UUID>>));
                            serializer.Serialize(writer, GroupMembers);
                            writer.Flush();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_GROUP_MEMBERS_STATE),
                    e.Message);
            }
        };

        /// <summary>
        ///     Loads Corrade group members.
        /// </summary>
        private static readonly System.Action LoadGroupMembersState = () =>
        {
            var groupMembersStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.GROUP_MEMBERS_STATE_FILE);
            if (File.Exists(groupMembersStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(groupMembersStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            var groups = new HashSet<UUID>(corradeConfiguration.Groups.Select(o => o.UUID));
                            ((Collections.SerializableDictionary<UUID, HashSet<UUID>>)
                                new XmlSerializer(typeof (Collections.SerializableDictionary<UUID, HashSet<UUID>>))
                                    .Deserialize(streamReader))
                                .AsParallel()
                                .Where(
                                    o => groups.Contains(o.Key))
                                .ForAll(o =>
                                {
                                    lock (GroupMembersLock)
                                    {
                                        if (!GroupMembers.ContainsKey(o.Key))
                                        {
                                            GroupMembers.Add(o.Key, o.Value);
                                        }
                                    }
                                });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_GROUP_MEMBERS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Saves Corrade notifications.
        /// </summary>
        private static readonly System.Action SaveGroupSchedulesState = () =>
        {
            SchedulesWatcher.EnableRaisingEvents = false;
            try
            {
                lock (GroupSchedulesLock)
                {
                    using (
                        var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                            CORRADE_CONSTANTS.GROUP_SCHEDULES_STATE_FILE), FileMode.Create,
                            FileAccess.Write, FileShare.None))
                    {
                        using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                        {
                            var serializer = new XmlSerializer(typeof (HashSet<GroupSchedule>));
                            serializer.Serialize(writer, GroupSchedules);
                            writer.Flush();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_GROUP_SCHEDULES_STATE),
                    e.Message);
            }
            SchedulesWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadGroupSchedulesState = () =>
        {
            SchedulesWatcher.EnableRaisingEvents = false;
            var groupSchedulesStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.GROUP_SCHEDULES_STATE_FILE);
            if (File.Exists(groupSchedulesStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(groupSchedulesStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            var groups =
                                new HashSet<UUID>(
                                    corradeConfiguration.Groups
                                        .AsParallel()
                                        .Where(
                                            o =>
                                                !o.Schedules.Equals(0) &&
                                                !(o.PermissionMask & (ulong) Configuration.Permissions.Schedule).Equals(
                                                    0))
                                        .Select(o => o.UUID));
                            ((HashSet<GroupSchedule>)
                                new XmlSerializer(typeof (HashSet<GroupSchedule>)).Deserialize(streamReader))
                                .AsParallel()
                                .Where(o => groups.Contains(o.Group.UUID)).ForAll(o =>
                                {
                                    lock (GroupSchedulesLock)
                                    {
                                        if (!GroupSchedules.Contains(o))
                                        {
                                            GroupSchedules.Add(o);
                                        }
                                    }
                                });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(
                            ConsoleError.UNABLE_TO_LOAD_CORRADE_GROUP_SCHEDULES_STATE),
                        ex.Message);
                }
            }
            SchedulesWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Saves Corrade notifications.
        /// </summary>
        private static readonly System.Action SaveNotificationState = () =>
        {
            NotificationsWatcher.EnableRaisingEvents = false;
            try
            {
                lock (GroupNotificationsLock)
                {
                    using (
                        var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                            CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE), FileMode.Create,
                            FileAccess.Write, FileShare.None))
                    {
                        using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                        {
                            var serializer = new XmlSerializer(typeof (HashSet<Notification>));
                            serializer.Serialize(writer, GroupNotifications);
                            writer.Flush();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE),
                    e.Message);
            }
            NotificationsWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadNotificationState = () =>
        {
            NotificationsWatcher.EnableRaisingEvents = false;
            var groupNotificationsStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE);
            if (File.Exists(groupNotificationsStateFile))
            {
                var groups = new HashSet<UUID>(corradeConfiguration.Groups.Select(o => o.UUID));
                try
                {
                    using (
                        var fileStream = File.Open(groupNotificationsStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            ((HashSet<Notification>)
                                new XmlSerializer(typeof (HashSet<Notification>)).Deserialize(streamReader))
                                .AsParallel()
                                .Where(
                                    o => groups.Contains(o.GroupUUID))
                                .ForAll(o =>
                                {
                                    lock (GroupNotificationsLock)
                                    {
                                        if (!GroupNotifications.Contains(o))
                                        {
                                            GroupNotifications.Add(o);
                                        }
                                    }
                                });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(
                            ConsoleError.UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE),
                        ex.Message);
                }

                // Build the group notification cache.
                var LockObject = new object();
                new List<Configuration.Notifications>(Reflection.GetEnumValues<Configuration.Notifications>())
                    .AsParallel().ForAll(o =>
                    {
                        lock (GroupNotificationsLock)
                        {
                            GroupNotifications.AsParallel()
                                .Where(p => !((ulong) o & p.NotificationMask).Equals(0)).ForAll(p =>
                                {
                                    lock (LockObject)
                                    {
                                        if (GroupNotificationsCache.ContainsKey(o))
                                        {
                                            GroupNotificationsCache[o].Add(p);
                                            return;
                                        }
                                        GroupNotificationsCache.Add(o, new HashSet<Notification> {p});
                                    }
                                });
                        }
                    });
            }
            NotificationsWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Saves Corrade movement state.
        /// </summary>
        private static readonly System.Action SaveMovementState = () =>
        {
            try
            {
                using (
                    var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                        CORRADE_CONSTANTS.MOVEMENT_STATE_FILE), FileMode.Create,
                        FileAccess.Write, FileShare.None))
                {
                    using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                    {
                        var serializer = new XmlSerializer(typeof (AgentMovement));
                        lock (Locks.ClientInstanceSelfLock)
                        {
                            serializer.Serialize(writer, new AgentMovement
                            {
                                AlwaysRun = Client.Self.Movement.AlwaysRun,
                                AutoResetControls = Client.Self.Movement.AutoResetControls,
                                Away = Client.Self.Movement.Away,
                                BodyRotation = Client.Self.Movement.BodyRotation,
                                Flags = Client.Self.Movement.Flags,
                                Fly = Client.Self.Movement.Fly,
                                HeadRotation = Client.Self.Movement.HeadRotation,
                                Mouselook = Client.Self.Movement.Mouselook,
                                SitOnGround = Client.Self.Movement.SitOnGround,
                                StandUp = Client.Self.Movement.StandUp,
                                State = Client.Self.Movement.State
                            });
                        }
                        writer.Flush();
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_MOVEMENT_STATE),
                    e.Message);
            }
        };

        /// <summary>
        ///     Loads Corrade movement state.
        /// </summary>
        private static readonly System.Action LoadMovementState = () =>
        {
            var movementStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.MOVEMENT_STATE_FILE);
            if (File.Exists(movementStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(movementStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            var serializer = new XmlSerializer(typeof (AgentMovement));
                            var movement = (AgentMovement) serializer.Deserialize(streamReader);
                            lock (Locks.ClientInstanceSelfLock)
                            {
                                Client.Self.Movement.AlwaysRun = movement.AlwaysRun;
                                Client.Self.Movement.AutoResetControls = movement.AutoResetControls;
                                Client.Self.Movement.Away = movement.Away;
                                Client.Self.Movement.BodyRotation = movement.BodyRotation;
                                Client.Self.Movement.Flags = movement.Flags;
                                Client.Self.Movement.Fly = movement.Fly;
                                Client.Self.Movement.HeadRotation = movement.HeadRotation;
                                Client.Self.Movement.Mouselook = movement.Mouselook;
                                Client.Self.Movement.SitOnGround = movement.SitOnGround;
                                Client.Self.Movement.StandUp = movement.StandUp;
                                Client.Self.Movement.State = movement.State;
                                Client.Self.Movement.SendUpdate(true);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_MOVEMENT_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Saves Corrade movement state.
        /// </summary>
        private static readonly System.Action SaveConferenceState = () =>
        {
            try
            {
                using (
                    var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                        CORRADE_CONSTANTS.CONFERENCE_STATE_FILE), FileMode.Create,
                        FileAccess.Write, FileShare.None))
                {
                    using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                    {
                        var serializer = new XmlSerializer(typeof (HashSet<Conference>));
                        lock (ConferencesLock)
                        {
                            serializer.Serialize(writer, Conferences);
                        }
                        writer.Flush();
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CONFERENCE_STATE),
                    e.Message);
            }
        };

        /// <summary>
        ///     Loads Corrade movement state.
        /// </summary>
        private static readonly System.Action LoadConferenceState = () =>
        {
            var conferenceStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.CONFERENCE_STATE_FILE);
            if (File.Exists(conferenceStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(conferenceStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            var serializer = new XmlSerializer(typeof (HashSet<Conference>));
                            ((HashSet<Conference>) serializer.Deserialize(streamReader)).AsParallel().ForAll(o =>
                            {
                                try
                                {
                                    // Attempt to rejoin the conference.
                                    lock (Locks.ClientInstanceSelfLock)
                                    {
                                        if (!Client.Self.GroupChatSessions.ContainsKey(o.Session))
                                            Client.Self.ChatterBoxAcceptInvite(o.Session);
                                    }
                                    // Add the conference to the list of conferences.
                                    lock (ConferencesLock)
                                    {
                                        if (!Conferences.AsParallel()
                                            .Any(
                                                p =>
                                                    p.Name.Equals(o.Name, StringComparison.Ordinal) &&
                                                    p.Session.Equals(o.Session)))
                                        {
                                            Conferences.Add(new Conference
                                            {
                                                Name = o.Name,
                                                Session = o.Session,
                                                Restored = true
                                            });
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Feedback(
                                        Reflection.GetDescriptionFromEnumValue(
                                            ConsoleError.UNABLE_TO_RESTORE_CONFERENCE), o.Name,
                                        ex.Message);
                                }
                            });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CONFERENCE_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Loads Corrade group cookies.
        /// </summary>
        private static readonly System.Action LoadGroupCookiesState = () =>
        {
            var groupCookiesStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.GROUP_COOKIES_STATE_FILE);
            if (File.Exists(groupCookiesStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(groupCookiesStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        var groups = new HashSet<UUID>(corradeConfiguration.Groups.Select(o => o.UUID));
                        var serializer = new BinaryFormatter();
                        ((Dictionary<UUID, CookieContainer>)
                            serializer.Deserialize(fileStream)).AsParallel()
                            .Where(o => groups.Contains(o.Key))
                            .ForAll(o =>
                            {
                                lock (GroupCookieContainersLock)
                                {
                                    if (!GroupCookieContainers.Contains(o))
                                    {
                                        GroupCookieContainers.Add(o.Key, o.Value);
                                        return;
                                    }
                                    GroupCookieContainers[o.Key] = o.Value;
                                }
                            });
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_GROUP_COOKIES_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Saves Corrade group cookies.
        /// </summary>
        private static readonly System.Action SaveGroupCookiesState = () =>
        {
            try
            {
                using (
                    var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                        CORRADE_CONSTANTS.GROUP_COOKIES_STATE_FILE), FileMode.Create,
                        FileAccess.Write, FileShare.None))
                {
                    var serializer = new BinaryFormatter();
                    lock (GroupCookieContainersLock)
                    {
                        serializer.Serialize(fileStream, GroupCookieContainers);
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_GROUP_COOKIES_STATE),
                    e.Message);
            }
        };

        /// <summary>
        ///     Saves Corrade feeds.
        /// </summary>
        private static readonly System.Action SaveGroupFeedState = () =>
        {
            GroupFeedWatcher.EnableRaisingEvents = false;
            try
            {
                using (
                    var fileStream = File.Open(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                        CORRADE_CONSTANTS.FEEDS_STATE_FILE), FileMode.Create,
                        FileAccess.Write, FileShare.None))
                {
                    using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                    {
                        var serializer =
                            new XmlSerializer(
                                typeof (Collections.SerializableDictionary
                                    <string, Collections.SerializableDictionary<UUID, string>>));
                        lock (GroupFeedsLock)
                        {
                            serializer.Serialize(writer, GroupFeeds);
                        }
                        writer.Flush();
                    }
                }
            }
            catch (Exception e)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_FEEDS_STATE),
                    e.Message);
            }
            GroupFeedWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadGroupFeedState = () =>
        {
            var feedStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.FEEDS_STATE_FILE);
            if (File.Exists(feedStateFile))
            {
                try
                {
                    using (
                        var fileStream = File.Open(feedStateFile, FileMode.Open, FileAccess.Read,
                            FileShare.Read))
                    {
                        using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                        {
                            var groups = new HashSet<UUID>(corradeConfiguration.Groups.Select(o => o.UUID));
                            var serializer =
                                new XmlSerializer(
                                    typeof (Collections.SerializableDictionary
                                        <string, Collections.SerializableDictionary<UUID, string>>));
                            ((Collections.SerializableDictionary
                                <string, Collections.SerializableDictionary<UUID, string>>)
                                serializer.Deserialize(streamReader)).AsParallel()
                                .Where(o => o.Value.Any(p => groups.Contains(p.Key)))
                                .ForAll(o =>
                                {
                                    lock (GroupFeedsLock)
                                    {
                                        if (!GroupFeeds.ContainsKey(o.Key))
                                        {
                                            GroupFeeds.Add(o.Key, o.Value);
                                            return;
                                        }
                                        GroupFeeds[o.Key].Clone().AsParallel().ForAll(p =>
                                        {
                                            if (!GroupFeeds[o.Key].ContainsKey(p.Key))
                                            {
                                                GroupFeeds[o.Key].Add(p.Key, p.Value);
                                                return;
                                            }
                                            GroupFeeds[o.Key][p.Key] = p.Value;
                                        });
                                    }
                                });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_FEEDS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Loads the chatbot configuration and SIML files.
        /// </summary>
        private static readonly System.Action LoadChatBotFiles = () =>
        {
            if (!string.IsNullOrEmpty(SIMLBotConfigurationWatcher.Path))
                SIMLBotConfigurationWatcher.EnableRaisingEvents = false;
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READING_SIML_BOT_CONFIGURATION));
            try
            {
                var SIMLPackage = Path.Combine(
                    Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY, SIML_BOT_CONSTANTS.PACKAGE_FILE);
                switch (File.Exists(SIMLPackage))
                {
                    case true:
                        SynBot.PackageManager.LoadFromString(File.ReadAllText(SIMLPackage));
                        break;
                    default:
                        var elementList = new List<XDocument>();
                        foreach (var simlDocument in Directory.GetFiles(Path.Combine(
                            Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                            SIML_BOT_CONSTANTS.SIML_DIRECTORY,
                            SIML_BOT_CONSTANTS.SIML_SETTINGS_DIRECTORY), @"*.siml")
                            .Select(XDocument.Load))
                        {
                            elementList.Add(simlDocument);
                            SynBot.AddSiml(simlDocument);
                        }
                        foreach (var simlDocument in Directory.GetFiles(Path.Combine(
                            Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                            SIML_BOT_CONSTANTS.SIML_DIRECTORY), @"*.siml")
                            .Select(XDocument.Load))
                        {
                            elementList.Add(simlDocument);
                            SynBot.AddSiml(simlDocument);
                        }
                        File.WriteAllText(Path.Combine(
                            Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                            SIML_BOT_CONSTANTS.PACKAGE_FILE), SynBot.PackageManager.ConvertToPackage(elementList));
                        break;
                }

                // Load learned and memorized.
                var SIMLLearned = Path.Combine(
                    Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                    SIML_BOT_CONSTANTS.EVOLVE_DIRECTORY,
                    SIML_BOT_CONSTANTS.LEARNED_FILE);
                if (File.Exists(SIMLLearned))
                {
                    SynBot.AddSiml(XDocument.Load(SIMLLearned));
                }
                var SIMLMemorized = Path.Combine(
                    Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                    SIML_BOT_CONSTANTS.EVOLVE_DIRECTORY,
                    SIML_BOT_CONSTANTS.MEMORIZED_FILE);
                if (File.Exists(SIMLMemorized))
                {
                    SynBot.AddSiml(XDocument.Load(SIMLMemorized));
                }
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_LOADING_SIML_BOT_FILES),
                    ex.Message);
                if (!string.IsNullOrEmpty(SIMLBotConfigurationWatcher.Path))
                    SIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                return;
            }
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READ_SIML_BOT_CONFIGURATION));
            if (!string.IsNullOrEmpty(SIMLBotConfigurationWatcher.Path))
                SIMLBotConfigurationWatcher.EnableRaisingEvents = true;
        };

        private static volatile bool runHTTPServer;
        private static volatile bool runTCPNotificationsServer;
        private static volatile bool runCallbackThread = true;
        private static volatile bool runNotificationThread = true;
        private static volatile bool runGroupSchedulesThread;
        private static volatile bool runGroupMembershipSweepThread;
        private static volatile bool runEffectsExpirationThread;
        private static volatile bool runGroupFeedThread;

        public Corrade()
        {
            if (Environment.UserInteractive) return;
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32NT:
                    try
                    {
                        InstalledServiceName = (string)
                            new ManagementObjectSearcher("SELECT * FROM Win32_Service where ProcessId = " +
                                                         Process.GetCurrentProcess().Id).Get()
                                .Cast<ManagementBaseObject>()
                                .First()["Name"];
                    }
                    catch (Exception)
                    {
                        InstalledServiceName = CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME;
                    }
                    break;
                default:
                    InstalledServiceName = CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME;
                    break;
            }
            CorradeEventLog.Source = InstalledServiceName;
            CorradeEventLog.Log = CORRADE_CONSTANTS.LOG_FACILITY;
            CorradeEventLog.BeginInit();
            if (!EventLog.SourceExists(CorradeEventLog.Source))
            {
                EventLog.CreateEventSource(CorradeEventLog.Source, CorradeEventLog.Log);
            }
            CorradeEventLog.EndInit();
        }

        /// <summary>
        ///     Group feed.
        /// </summary>
        private static void CheckGroupFeeds()
        {
            do
            {
                Thread.Sleep(TimeSpan.FromMilliseconds(corradeConfiguration.FeedsUpdateInterval));
                lock (GroupFeedsLock)
                {
                    GroupFeeds.AsParallel().ForAll(o =>
                    {
                        try
                        {
                            using (var reader = XmlReader.Create(o.Key))
                            {
                                var syndicationFeed = SyndicationFeed.Load(reader);
                                syndicationFeed?.Items.AsParallel()
                                    .Where(
                                        p =>
                                            p != null && p.PublishDate != null && p.Title != null && p.Summary != null &&
                                            p.PublishDate.CompareTo(
                                                DateTimeOffset.Now.Subtract(
                                                    TimeSpan.FromMilliseconds(corradeConfiguration.FeedsUpdateInterval))) >
                                            0)
                                    .ForAll(p =>
                                    {
                                        o.Value.AsParallel().ForAll(q =>
                                        {
                                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                                () => SendNotification(
                                                    Configuration.Notifications.Feed,
                                                    new FeedEventArgs
                                                    {
                                                        Title = p.Title.Text,
                                                        Summary = p.Summary.Text,
                                                        Date = p.PublishDate,
                                                        Name = q.Value,
                                                        GroupUUID = q.Key
                                                    }),
                                                corradeConfiguration.MaximumNotificationThreads);
                                        });
                                    });
                            }
                        }
                        catch (Exception ex)
                        {
                            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_LOADING_FEED), o.Key,
                                ex.Message);
                        }
                    });
                }
            } while (runGroupFeedThread);
        }

        /// <summary>
        ///     Sweep for group members.
        /// </summary>
        private static void GroupMembershipSweep()
        {
            // The queue of groups to scan.
            var groupUUIDs = new Queue<UUID>();
            // The total list of members.
            var groupMembers = new HashSet<UUID>();
            // New members that have joined the group.
            var joinedMembers = new HashSet<UUID>();
            // Members that have parted the group.
            var partedMembers = new HashSet<UUID>();

            var GroupMembersReplyEvent = new ManualResetEvent(false);
            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
            {
                lock (GroupMembersLock)
                {
                    if (GroupMembers.ContainsKey(args.GroupID))
                    {
                        joinedMembers.UnionWith(
                            args.Members.Values.AsParallel()
                                .Where(o => !GroupMembers[args.GroupID].Contains(o.ID))
                                .Select(o => o.ID));
                        partedMembers.UnionWith(GroupMembers[args.GroupID].AsParallel()
                            .Where(o => !args.Members.Values.Any(p => p.ID.Equals(o))));
                    }
                }
                groupMembers.UnionWith(args.Members.Values.Select(o => o.ID));
                GroupMembersReplyEvent.Set();
            };

            do
            {
                Thread.Sleep((int) corradeConfiguration.MembershipSweepInterval);
                if (!Client.Network.Connected) continue;

                var groups = Enumerable.Empty<UUID>();
                if (!Services.GetCurrentGroups(Client, corradeConfiguration.ServicesTimeout, ref groups))
                    continue;

                // Enqueue configured groups that are currently joined groups.
                groupUUIDs.Clear();
                var LockObject = new object();
                var currentGroups = new HashSet<UUID>(groups);
                corradeConfiguration.Groups.AsParallel().Select(o => new {group = o, groupUUID = o.UUID})
                    .Where(p => currentGroups.Contains(p.groupUUID))
                    .Select(o => o.group).ForAll(o =>
                    {
                        lock (LockObject)
                        {
                            groupUUIDs.Enqueue(o.UUID);
                        }
                    });
                currentGroups.Clear();

                // Bail if no configured groups are also joined.
                if (!groupUUIDs.Any()) continue;

                do
                {
                    // Pause between group sweeps.
                    Thread.Yield();
                    // Dequeue the first group.
                    var groupUUID = groupUUIDs.Dequeue();
                    // Clear the total list of members.
                    groupMembers.Clear();
                    // Clear the members that have joined the group.
                    joinedMembers.Clear();
                    // Clear the members that have left the group.
                    partedMembers.Clear();
                    lock (Locks.ClientInstanceGroupsLock)
                    {
                        Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                        GroupMembersReplyEvent.Reset();
                        Client.Groups.RequestGroupMembers(groupUUID);
                        if (!GroupMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                        {
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                            continue;
                        }
                        Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                    }

                    lock (GroupMembersLock)
                    {
                        if (!GroupMembers.ContainsKey(groupUUID))
                        {
                            GroupMembers.Add(groupUUID, new HashSet<UUID>(groupMembers));
                            continue;
                        }
                    }

                    var groupMembersChanged = false;
                    if (joinedMembers.Any())
                    {
                        groupMembersChanged = true;
                        joinedMembers.AsParallel().ForAll(
                            o =>
                            {
                                var agentName = string.Empty;
                                var groupName = string.Empty;
                                if (Resolvers.AgentUUIDToName(Client,
                                    o,
                                    corradeConfiguration.ServicesTimeout,
                                    ref agentName) &&
                                    Resolvers.GroupUUIDToName(Client, groupUUID,
                                        corradeConfiguration.ServicesTimeout,
                                        ref groupName))
                                {
                                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                        () => SendNotification(
                                            Configuration.Notifications.GroupMembership,
                                            new GroupMembershipEventArgs
                                            {
                                                AgentName = agentName,
                                                AgentUUID = o,
                                                Action = Action.JOINED,
                                                GroupName = groupName,
                                                GroupUUID = groupUUID
                                            }),
                                        corradeConfiguration.MaximumNotificationThreads);
                                }
                            });
                    }
                    if (partedMembers.Any())
                    {
                        groupMembersChanged = true;
                        partedMembers.AsParallel().ForAll(
                            o =>
                            {
                                var agentName = string.Empty;
                                var groupName = string.Empty;
                                if (Resolvers.AgentUUIDToName(Client,
                                    o,
                                    corradeConfiguration.ServicesTimeout,
                                    ref agentName) &&
                                    Resolvers.GroupUUIDToName(Client, groupUUID,
                                        corradeConfiguration.ServicesTimeout,
                                        ref groupName))
                                {
                                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                        () => SendNotification(
                                            Configuration.Notifications.GroupMembership,
                                            new GroupMembershipEventArgs
                                            {
                                                AgentName = agentName,
                                                AgentUUID = o,
                                                Action = Action.PARTED,
                                                GroupName = groupName,
                                                GroupUUID = groupUUID
                                            }),
                                        corradeConfiguration.MaximumNotificationThreads);
                                }
                            });
                    }

                    // If no new members joined or old members left then continue.
                    if (!groupMembersChanged) continue;

                    lock (GroupMembersLock)
                    {
                        // Remove parted members.
                        GroupMembers[groupUUID].ExceptWith(partedMembers);
                        // Add joined members.
                        GroupMembers[groupUUID].UnionWith(joinedMembers);
                    }

                    SaveGroupMembersState.Invoke();
                } while (groupUUIDs.Any() && runGroupMembershipSweepThread);
            } while (runGroupMembershipSweepThread);
        }

        private static bool ConsoleCtrlCheck(NativeMethods.CtrlType ctrlType)
        {
            // Set the user disconnect semaphore.
            ConnectionSemaphores['u'].Set();
            // Wait for threads to finish.
            Thread.Sleep((int) corradeConfiguration.ServicesTimeout);
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Serialize an RLV message to a string.
        /// </summary>
        /// <returns>in order: behaviours, options, parameters</returns>
        private static IEnumerable<string> wasRLVToString(string message)
        {
            if (string.IsNullOrEmpty(message)) yield break;

            // Split all commands.
            var unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            var first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            var match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            yield return match.Groups["behaviour"].ToString().ToLowerInvariant();
            yield return match.Groups["option"].ToString().ToLowerInvariant();
            yield return match.Groups["param"].ToString().ToLowerInvariant();

            CONTINUE:
            foreach (var slice in wasRLVToString(message))
            {
                yield return slice;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the fields of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<FieldInfo, object>> wasGetFields(object @object, string @namespace)
        {
            if (@object == null) yield break;

            foreach (var fi in @object.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public))
            {
                if (fi.FieldType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.OrdinalIgnoreCase))
                {
                    foreach (var sf in wasGetFields(fi.GetValue(@object), @namespace))
                    {
                        yield return sf;
                    }
                }
                yield return new KeyValuePair<FieldInfo, object>(fi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the properties of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<PropertyInfo, object>> wasGetProperties(object @object,
            string @namespace)
        {
            if (@object == null) yield break;

            foreach (var pi in @object.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public))
            {
                if (pi.PropertyType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.OrdinalIgnoreCase))
                {
                    var getMethod = pi.GetGetMethod();
                    if (getMethod.ReturnType.IsArray)
                    {
                        var array = (Array) getMethod.Invoke(@object, null);
                        foreach (var sp in
                            array.Cast<object>().SelectMany(element => wasGetProperties(element, @namespace)))
                        {
                            yield return sp;
                        }
                    }
                    foreach (
                        var sp in
                            wasGetProperties(pi.GetValue(@object, null), @namespace))
                    {
                        yield return sp;
                    }
                }
                yield return new KeyValuePair<PropertyInfo, object>(pi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo SetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="object">the object to set the value on</param>
        /// <param name="value">the value to set</param>
        private static void wasSetInfoValue<TK, TV>(TK info, ref TV @object, object value)
        {
            object o = @object;
            var fi = (object) info as FieldInfo;
            if (fi != null)
            {
                fi.SetValue(o, value);
                @object = (TV) o;
                return;
            }
            var pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                pi.SetValue(o, value, null);
                @object = (TV) o;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo GetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="value">the object to get from</param>
        /// <returns>the value of the field or property</returns>
        private static object wasGetInfoValue<T>(T info, object value)
        {
            var fi = (object) info as FieldInfo;
            if (fi != null)
            {
                return fi.GetValue(value);
            }
            var pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                if (pi.GetIndexParameters().Any())
                {
                    return value;
                }
                return pi.GetValue(value, null);
            }
            return null;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     The function gets the value from FieldInfo or PropertyInfo.
        /// </summary>
        /// <param name="info">a FieldInfo or PropertyInfo structure</param>
        /// <param name="value">the value to get</param>
        /// <returns>the value or values as a string</returns>
        private static IEnumerable<string> wasGetInfo(object info, object value)
        {
            if (info == null) yield break;
            var data = wasGetInfoValue(info, value);
            if (data == null) yield break;
            // Handle arrays and lists
            if (data is Array || data is IList)
            {
                var iList = (IList) data;
                foreach (var item in iList.Cast<object>().Where(o => o != null))
                {
                    // These are index collections so pre-prend an index.
                    yield return "Index";
                    yield return iList.IndexOf(item).ToString();
                    switch (item.GetType().IsPrimitive || item.GetType() == typeof (string))
                    {
                        case true: // Don't bother with primitive types.
                            yield return item.ToString();
                            break;
                        default:
                            foreach (var fi in wasGetFields(item, item.GetType().Name))
                            {
                                if (fi.Key != null)
                                {
                                    foreach (var fieldString in wasGetInfo(fi.Key, fi.Value))
                                    {
                                        yield return fi.Key.Name;
                                        yield return fieldString;
                                    }
                                }
                            }
                            foreach (var pi in wasGetProperties(item, item.GetType().Name))
                            {
                                if (pi.Key != null)
                                {
                                    foreach (var propertyString in wasGetInfo(pi.Key, pi.Value))
                                    {
                                        yield return pi.Key.Name;
                                        yield return propertyString;
                                    }
                                }
                            }
                            break;
                    }
                }
                yield break;
            }
            // Handle Dictionary
            if (data is IDictionary)
            {
                var dictionary = (IDictionary) data;
                foreach (DictionaryEntry entry in dictionary)
                {
                    // First the keys.
                    switch (entry.Key.GetType().IsPrimitive || entry.Key.GetType() == typeof (string))
                    {
                        case true: // Don't bother with primitive types.
                            yield return entry.Key.ToString();
                            break;
                        default:
                            foreach (var fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                            {
                                if (fi.Key != null)
                                {
                                    foreach (var fieldString in wasGetInfo(fi.Key, fi.Value))
                                    {
                                        yield return fi.Key.Name;
                                        yield return fieldString;
                                    }
                                }
                            }
                            foreach (
                                var pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                            {
                                if (pi.Key != null)
                                {
                                    foreach (var propertyString in wasGetInfo(pi.Key, pi.Value))
                                    {
                                        yield return pi.Key.Name;
                                        yield return propertyString;
                                    }
                                }
                            }
                            break;
                    }

                    // Then the values.
                    switch (entry.Value.GetType().IsPrimitive || entry.Value.GetType() == typeof (string))
                    {
                        case true: // Don't bother with primitive types.
                            yield return entry.Value.ToString();
                            break;
                        default:
                            foreach (var fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                                )
                            {
                                if (fi.Key != null)
                                {
                                    foreach (var fieldString in wasGetInfo(fi.Key, fi.Value))
                                    {
                                        yield return fi.Key.Name;
                                        yield return fieldString;
                                    }
                                }
                            }
                            foreach (
                                var pi in
                                    wasGetProperties(entry.Value, entry.Value.GetType().Name))
                            {
                                if (pi.Key != null)
                                {
                                    foreach (var propertyString in wasGetInfo(pi.Key, pi.Value))
                                    {
                                        yield return pi.Key.Name;
                                        yield return propertyString;
                                    }
                                }
                            }
                            break;
                    }
                }
                yield break;
            }
            // Handle InternalDictionary
            var internalDictionaryInfo = data.GetType()
                .GetField("Dictionary",
                    BindingFlags.Default | BindingFlags.CreateInstance | BindingFlags.Instance | BindingFlags.NonPublic);
            if (internalDictionaryInfo != null)
            {
                var iDictionary = internalDictionaryInfo.GetValue(data) as IDictionary;
                if (iDictionary == null) yield break;
                foreach (DictionaryEntry entry in iDictionary)
                {
                    // First the keys.
                    switch (entry.Key.GetType().IsPrimitive || entry.Key.GetType() == typeof (string))
                    {
                        case true: // Don't bother with primitive types.
                            yield return entry.Key.ToString();
                            break;
                        default:
                            foreach (var fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                            {
                                if (fi.Key != null)
                                {
                                    foreach (var fieldString in wasGetInfo(fi.Key, fi.Value))
                                    {
                                        yield return fi.Key.Name;
                                        yield return fieldString;
                                    }
                                }
                            }
                            foreach (
                                var pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                            {
                                if (pi.Key != null)
                                {
                                    foreach (var propertyString in wasGetInfo(pi.Key, pi.Value))
                                    {
                                        yield return pi.Key.Name;
                                        yield return propertyString;
                                    }
                                }
                            }
                            break;
                    }

                    // Then the values.
                    switch (entry.Value.GetType().IsPrimitive || entry.Value.GetType() == typeof (string))
                    {
                        case true: // Don't bother with primitive types.
                            yield return entry.Value.ToString();
                            break;
                        default:
                            foreach (var fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                                )
                            {
                                if (fi.Key != null)
                                {
                                    foreach (var fieldString in wasGetInfo(fi.Key, fi.Value))
                                    {
                                        yield return fi.Key.Name;
                                        yield return fieldString;
                                    }
                                }
                            }
                            foreach (
                                var pi in
                                    wasGetProperties(entry.Value, entry.Value.GetType().Name))
                            {
                                if (pi.Key != null)
                                {
                                    foreach (var propertyString in wasGetInfo(pi.Key, pi.Value))
                                    {
                                        yield return pi.Key.Name;
                                        yield return propertyString;
                                    }
                                }
                            }
                            break;
                    }
                }
                yield break;
            }
            // Handle date and time as an LSL timestamp.
            if (data is DateTime)
            {
                yield return ((DateTime) data).ToString(Constants.LSL.DATE_TIME_STAMP);
                yield break;
            }

            // Use the Corrade permission system instead.
            if (data is Permissions)
            {
                yield return Inventory.wasPermissionsToString((Permissions) data);
                yield break;
            }

            if (data is ParcelFlags)
            {
                var parcelFlags = (ParcelFlags) data;
                foreach (var flag in typeof (ParcelFlags).GetFields(BindingFlags.Public | BindingFlags.Static)
                    .AsParallel()
                    .Where(o => !((uint) o.GetValue(null) & (uint) parcelFlags).Equals(0))
                    .Select(o => o.Name))
                {
                    yield return flag;
                }
                yield break;
            }

            if (data is GroupPowers)
            {
                var groupPowers = (GroupPowers) data;
                foreach (var power in typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                    .AsParallel()
                    .Where(o => !((ulong) o.GetValue(null) & (ulong) groupPowers).Equals(0))
                    .Select(o => o.Name))
                {
                    yield return power;
                }
                yield break;
            }

            var @string = data.ToString();
            if (string.IsNullOrEmpty(@string)) yield break;
            yield return @string;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Sets the value of FieldInfo or PropertyInfo.
        /// </summary>
        /// <typeparam name="T">the type to set</typeparam>
        /// <param name="info">a FieldInfo or PropertyInfo object</param>
        /// <param name="value">the object's value</param>
        /// <param name="setting">the value to set to</param>
        /// <param name="object">the object to set the values for</param>
        private static void wasSetInfo<T>(object info, object value, string setting, ref T @object)
        {
            if (info == null) return;

            var data = wasGetInfoValue(info, value);

            // OpenMetaverse particular flags.
            if (data is ParcelFlags)
            {
                uint parcelFlags;
                switch (!uint.TryParse(setting, out parcelFlags))
                {
                    case true:
                        var allFlags =
                            typeof (ParcelFlags).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .ToDictionary(o => o.Name, o => (uint) o.GetValue(null));
                        CSV.ToEnumerable(setting).AsParallel().Where(o => !string.IsNullOrEmpty(o)).ForAll(
                            o =>
                            {
                                uint parcelFlag;
                                if (allFlags.TryGetValue(o, out parcelFlag))
                                {
                                    parcelFlags |= parcelFlag;
                                }
                            });
                        break;
                }
                wasSetInfoValue(info, ref @object, parcelFlags);
                return;
            }
            if (data is GroupPowers)
            {
                uint groupPowers;
                switch (!uint.TryParse(setting, out groupPowers))
                {
                    case true:
                        var allPowers =
                            typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .ToDictionary(o => o.Name, o => (uint) o.GetValue(null));
                        CSV.ToEnumerable(setting).AsParallel().Where(o => !string.IsNullOrEmpty(o)).ForAll(
                            o =>
                            {
                                uint groupPower;
                                if (allPowers.TryGetValue(o, out groupPower))
                                {
                                    groupPowers |= groupPower;
                                }
                            });
                        break;
                }
                wasSetInfoValue(info, ref @object, groupPowers);
                return;
            }
            if (data is AttachmentPoint)
            {
                byte attachmentPoint;
                switch (!byte.TryParse(setting, out attachmentPoint))
                {
                    case true:
                        var attachmentPointFieldInfo =
                            typeof (AttachmentPoint).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel()
                                .FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (attachmentPointFieldInfo == null) break;
                        attachmentPoint = (byte) attachmentPointFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, attachmentPoint);
                return;
            }
            if (data is Tree)
            {
                byte tree;
                switch (!byte.TryParse(setting, out tree))
                {
                    case true:
                        var treeFieldInfo = typeof (Tree).GetFields(BindingFlags.Public |
                                                                    BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (treeFieldInfo == null) break;
                        tree = (byte) treeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, tree);
                return;
            }
            if (data is Material)
            {
                byte material;
                switch (!byte.TryParse(setting, out material))
                {
                    case true:
                        var materialFieldInfo = typeof (Material).GetFields(BindingFlags.Public |
                                                                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (materialFieldInfo == null) break;
                        material = (byte) materialFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, material);
                return;
            }
            if (data is PathCurve)
            {
                byte pathCurve;
                switch (!byte.TryParse(setting, out pathCurve))
                {
                    case true:
                        var pathCurveFieldInfo = typeof (PathCurve).GetFields(BindingFlags.Public |
                                                                              BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (pathCurveFieldInfo == null) break;
                        pathCurve = (byte) pathCurveFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, pathCurve);
                return;
            }
            if (data is PCode)
            {
                byte pCode;
                switch (!byte.TryParse(setting, out pCode))
                {
                    case true:
                        var pCodeFieldInfo = typeof (PCode).GetFields(BindingFlags.Public | BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (pCodeFieldInfo == null) break;
                        pCode = (byte) pCodeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, pCode);
                return;
            }
            if (data is ProfileCurve)
            {
                byte profileCurve;
                switch (!byte.TryParse(setting, out profileCurve))
                {
                    case true:
                        var profileCurveFieldInfo =
                            typeof (ProfileCurve).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel()
                                .FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (profileCurveFieldInfo == null) break;
                        profileCurve = (byte) profileCurveFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, profileCurve);
                return;
            }
            if (data is HoleType)
            {
                byte holeType;
                switch (!byte.TryParse(setting, out holeType))
                {
                    case true:
                        var holeTypeFieldInfo = typeof (HoleType).GetFields(BindingFlags.Public |
                                                                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (holeTypeFieldInfo == null) break;
                        holeType = (byte) holeTypeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, holeType);
                return;
            }
            if (data is SculptType)
            {
                byte sculptType;
                switch (!byte.TryParse(setting, out sculptType))
                {
                    case true:
                        var sculptTypeFieldInfo = typeof (SculptType).GetFields(BindingFlags.Public |
                                                                                BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => string.Equals(setting, p.Name, StringComparison.Ordinal));
                        if (sculptTypeFieldInfo == null) break;
                        sculptType = (byte) sculptTypeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, sculptType);
                return;
            }
            // OpenMetaverse Primitive Types
            if (data is UUID)
            {
                UUID UUIDData;
                if (!UUID.TryParse(setting, out UUIDData))
                {
                    InventoryItem item;
                    lock (Locks.ClientInstanceInventoryLock)
                    {
                        item = Inventory.FindInventory<InventoryBase>(Client, Client.Inventory.Store.RootNode,
                            setting, corradeConfiguration.ServicesTimeout).FirstOrDefault() as InventoryItem;
                    }
                    if (item == null)
                    {
                        throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                    }
                    UUIDData = item.UUID;
                }
                switch (!UUIDData.Equals(UUID.Zero))
                {
                    case true:
                        wasSetInfoValue(info, ref @object, UUIDData);
                        return;
                    default:
                        throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                }
            }
            if (data is Vector3)
            {
                Vector3 vector3Data;
                if (Vector3.TryParse(setting, out vector3Data))
                {
                    wasSetInfoValue(info, ref @object, vector3Data);
                    return;
                }
            }
            if (data is Vector2)
            {
                Vector3 vector2Data;
                if (Vector2.TryParse(setting, out vector2Data))
                {
                    wasSetInfoValue(info, ref @object, vector2Data);
                    return;
                }
            }
            if (data is Vector3d)
            {
                Vector3d vector3DData;
                if (Vector3d.TryParse(setting, out vector3DData))
                {
                    wasSetInfoValue(info, ref @object, vector3DData);
                    return;
                }
            }
            if (data is Vector4)
            {
                Vector4 vector4Data;
                if (Vector4.TryParse(setting, out vector4Data))
                {
                    wasSetInfoValue(info, ref @object, vector4Data);
                    return;
                }
            }
            if (data is Quaternion)
            {
                Quaternion quaternionData;
                if (Quaternion.TryParse(setting, out quaternionData))
                {
                    wasSetInfoValue(info, ref @object, quaternionData);
                    return;
                }
            }
            // Primitive types.
            if (data is bool)
            {
                bool boolData;
                if (bool.TryParse(setting, out boolData))
                {
                    wasSetInfoValue(info, ref @object, boolData);
                    return;
                }
            }
            if (data is char)
            {
                char charData;
                if (char.TryParse(setting, out charData))
                {
                    wasSetInfoValue(info, ref @object, charData);
                    return;
                }
            }
            if (data is decimal)
            {
                decimal decimalData;
                if (decimal.TryParse(setting, out decimalData))
                {
                    wasSetInfoValue(info, ref @object, decimalData);
                    return;
                }
            }
            if (data is byte)
            {
                byte byteData;
                if (byte.TryParse(setting, out byteData))
                {
                    wasSetInfoValue(info, ref @object, byteData);
                    return;
                }
            }
            if (data is int)
            {
                int intData;
                if (int.TryParse(setting, out intData))
                {
                    wasSetInfoValue(info, ref @object, intData);
                    return;
                }
            }
            if (data is uint)
            {
                uint uintData;
                if (uint.TryParse(setting, out uintData))
                {
                    wasSetInfoValue(info, ref @object, uintData);
                    return;
                }
            }
            if (data is float)
            {
                float floatData;
                if (float.TryParse(setting, out floatData))
                {
                    wasSetInfoValue(info, ref @object, floatData);
                    return;
                }
            }
            if (data is long)
            {
                long longData;
                if (long.TryParse(setting, out longData))
                {
                    wasSetInfoValue(info, ref @object, longData);
                    return;
                }
            }
            if (data is float)
            {
                float singleData;
                if (float.TryParse(setting, out singleData))
                {
                    wasSetInfoValue(info, ref @object, singleData);
                    return;
                }
            }
            if (data is DateTime)
            {
                DateTime dateTimeData;
                if (DateTime.TryParse(setting, out dateTimeData))
                {
                    wasSetInfoValue(info, ref @object, dateTimeData);
                    return;
                }
            }
            if (data is string)
            {
                wasSetInfoValue(info, ref @object, setting);
            }
        }

        /// <summary>
        ///     Used to check whether a group name matches a group password.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="password">the password for the group</param>
        /// <returns>true if the agent has authenticated</returns>
        private static bool Authenticate(string group, string password)
        {
            /*
             * If the master override feature is enabled and the password matches the 
             * master override password then consider the request to be authenticated.
             * Otherwise, check that the password matches the password for the group.
             */
            return (corradeConfiguration.EnableMasterPasswordOverride &&
                    !string.IsNullOrEmpty(corradeConfiguration.MasterPasswordOverride) && (
                        string.Equals(corradeConfiguration.MasterPasswordOverride, password, StringComparison.Ordinal) ||
                        Utils.SHA1String(password).Equals(corradeConfiguration.MasterPasswordOverride))) ||
                   corradeConfiguration.Groups.AsParallel().Any(
                       o =>
                           string.Equals(group, o.Name, StringComparison.OrdinalIgnoreCase) &&
                           (string.Equals(o.Password, password, StringComparison.Ordinal) ||
                            Utils.SHA1String(password)
                                .Equals(o.Password, StringComparison.OrdinalIgnoreCase)));
        }

        /// <summary>
        ///     Used to check whether a group UUID matches a group password.
        /// </summary>
        /// <param name="group">the UUID of the group</param>
        /// <param name="password">the password for the group</param>
        /// <returns>true if the agent has authenticated</returns>
        private static bool Authenticate(UUID group, string password)
        {
            /*
             * If the master override feature is enabled and the password matches the 
             * master override password then consider the request to be authenticated.
             * Otherwise, check that the password matches the password for the group.
             */
            return (corradeConfiguration.EnableMasterPasswordOverride &&
                    !string.IsNullOrEmpty(corradeConfiguration.MasterPasswordOverride) && (
                        string.Equals(corradeConfiguration.MasterPasswordOverride, password, StringComparison.Ordinal) ||
                        Utils.SHA1String(password).Equals(corradeConfiguration.MasterPasswordOverride))) ||
                   corradeConfiguration.Groups.AsParallel().Any(
                       o =>
                           group.Equals(o.UUID) &&
                           (string.Equals(o.Password, password, StringComparison.Ordinal) ||
                            Utils.SHA1String(password)
                                .Equals(o.Password, StringComparison.OrdinalIgnoreCase)));
        }

        /// <summary>
        ///     Used to check whether a group has certain permissions for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="permission">the numeric Corrade permission</param>
        /// <returns>true if the group has permission</returns>
        private static bool HasCorradePermission(string group, ulong permission)
        {
            return !permission.Equals(0) && corradeConfiguration.Groups.AsParallel().Any(
                o =>
                    string.Equals(group, o.Name, StringComparison.OrdinalIgnoreCase) &&
                    !(o.PermissionMask & permission).Equals(0));
        }

        /// <summary>
        ///     Used to check whether a group has certain permissions for Corrade.
        /// </summary>
        /// <param name="group">the UUID of the group</param>
        /// <param name="permission">the numeric Corrade permission</param>
        /// <returns>true if the group has permission</returns>
        private static bool HasCorradePermission(UUID group, ulong permission)
        {
            return !permission.Equals(0) && corradeConfiguration.Groups.AsParallel()
                .Any(o => group.Equals(o.UUID) && !(o.PermissionMask & permission).Equals(0));
        }

        /// <summary>
        ///     Fetches a Corrade group from a key-value formatted message message.
        /// </summary>
        /// <param name="message">the message to inspect</param>
        /// <returns>the configured group</returns>
        private static Configuration.Group GetCorradeGroupFromMessage(string message)
        {
            var group =
                wasInput(KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.GROUP)),
                    message));
            UUID groupUUID;
            return UUID.TryParse(group, out groupUUID)
                ? corradeConfiguration.Groups.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID))
                : corradeConfiguration.Groups.AsParallel()
                    .FirstOrDefault(o => string.Equals(group, o.Name, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        ///     Used to check whether a group has a certain notification for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="notification">the numeric Corrade notification</param>
        /// <returns>true if the group has the notification</returns>
        private static bool GroupHasNotification(string group, ulong notification)
        {
            return !notification.Equals(0) && corradeConfiguration.Groups.AsParallel().Any(
                o => string.Equals(group, o.Name, StringComparison.OrdinalIgnoreCase) &&
                     !(o.NotificationMask & notification).Equals(0));
        }

        /// <summary>
        ///     Used to check whether a group has a certain notification for Corrade.
        /// </summary>
        /// <param name="group">the UUID of the group</param>
        /// <param name="notification">the numeric Corrade notification</param>
        /// <returns>true if the group has the notification</returns>
        private static bool GroupHasNotification(UUID group, ulong notification)
        {
            return !notification.Equals(0) && corradeConfiguration.Groups.AsParallel().Any(
                o => group.Equals(o.UUID) &&
                     !(o.NotificationMask & notification).Equals(0));
        }

        /// <summary>
        ///     Posts messages to console or log-files.
        /// </summary>
        /// <param name="messages">a list of messages</param>
        private static void Feedback(params string[] messages)
        {
            CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(
                () =>
                {
                    var output = new List<string>
                    {
                        !string.IsNullOrEmpty(InstalledServiceName)
                            ? InstalledServiceName
                            : CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME,
                        string.Format(Utils.EnUsCulture, "[{0}]",
                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                Utils.EnUsCulture.DateTimeFormat))
                    };

                    output.AddRange(messages.Select(o => o));

                    // Attempt to write to log file,
                    if (corradeConfiguration.ClientLogEnabled)
                    {
                        try
                        {
                            lock (ClientLogFileLock)
                            {
                                using (
                                    var fileStream = File.Open(corradeConfiguration.ClientLogFile,
                                        FileMode.Append,
                                        FileAccess.Write, FileShare.None))
                                {
                                    using (var logWriter = new StreamWriter(fileStream, Encoding.UTF8))
                                    {
                                        logWriter.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                            output.ToArray()));
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // or fail and append the fail message.
                            output.Add(string.Format(Utils.EnUsCulture, "{0} {1}",
                                Reflection.GetDescriptionFromEnumValue(
                                    ConsoleError.COULD_NOT_WRITE_TO_CLIENT_LOG_FILE),
                                ex.Message));
                        }
                    }

                    switch (Environment.UserInteractive)
                    {
                        case false:
                            switch (Environment.OSVersion.Platform)
                            {
                                case PlatformID.Win32NT:
                                    CorradeEventLog.WriteEntry(
                                        string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()),
                                        EventLogEntryType.Information);
                                    break;
                            }
                            break;
                        default:
                            Console.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()));
                            break;
                    }
                },
                corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
        }

        /// <summary>
        ///     Posts messages to console or log-files.
        /// </summary>
        /// <param name="multiline">whether to treat the messages as separate lines</param>
        /// <param name="messages">a list of messages</param>
        private static void Feedback(bool multiline, params string[] messages)
        {
            CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(
                () =>
                {
                    if (!multiline)
                    {
                        Feedback(messages);
                        return;
                    }

                    var output =
                        new List<string>(
                            messages.Select(
                                o => string.Format(Utils.EnUsCulture, "{0}{1}[{2}]{3}{4}",
                                    !string.IsNullOrEmpty(InstalledServiceName)
                                        ? InstalledServiceName
                                        : CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME, CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                        Utils.EnUsCulture.DateTimeFormat),
                                    CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                    o)));

                    // Attempt to write to log file,
                    if (corradeConfiguration.ClientLogEnabled)
                    {
                        try
                        {
                            lock (ClientLogFileLock)
                            {
                                using (
                                    var fileStream = File.Open(corradeConfiguration.ClientLogFile,
                                        FileMode.Append,
                                        FileAccess.Write, FileShare.None))
                                {
                                    using (var logWriter = new StreamWriter(fileStream, Encoding.UTF8))
                                    {
                                        foreach (var message in output)
                                        {
                                            logWriter.WriteLine(message);
                                        }
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // or fail and append the fail message.
                            output.Add(string.Format(Utils.EnUsCulture, "{0} {1}",
                                Reflection.GetDescriptionFromEnumValue(
                                    ConsoleError.COULD_NOT_WRITE_TO_CLIENT_LOG_FILE),
                                ex.Message));
                        }
                    }

                    switch (Environment.UserInteractive)
                    {
                        case false:
                            switch (Environment.OSVersion.Platform)
                            {
                                case PlatformID.Win32NT:
                                    foreach (var message in output)
                                    {
                                        CorradeEventLog.WriteEntry(message, EventLogEntryType.Information);
                                    }
                                    break;
                            }
                            break;
                        default:
                            foreach (var message in output)
                            {
                                Console.WriteLine(message);
                            }
                            break;
                    }
                },
                corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
        }

        public static int Main(string[] args)
        {
            if (Environment.UserInteractive)
            {
                if (args.Any())
                {
                    var action = string.Empty;
                    for (var i = 0; i < args.Length; ++i)
                    {
                        switch (args[i].ToUpper())
                        {
                            case "/INSTALL":
                                action = "INSTALL";
                                break;
                            case "/UNINSTALL":
                                action = "UNINSTALL";
                                break;
                            case "/NAME":
                                if (args.Length > i + 1)
                                {
                                    InstalledServiceName = args[++i];
                                }
                                break;
                        }
                    }

                    switch (action)
                    {
                        case "INSTALL":
                            return InstallService();
                        case "UNINSTALL":
                            return UninstallService();
                    }
                }
                // run interactively and log to console
                var corrade = new Corrade();
                corrade.OnStart(null);
                return 0;
            }

            // run as a standard service
            Run(new Corrade());
            return 0;
        }

        private static int InstallService()
        {
            try
            {
                // install the service with the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException != null && ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    var we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service already installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        private static int UninstallService()
        {
            try
            {
                // uninstall the service from the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {"/u", Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    var we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service not installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        protected override void OnStop()
        {
            base.OnStop();
            ConnectionSemaphores['u'].Set();
        }

        protected override void OnStart(string[] args)
        {
            base.OnStart(args);
            //Debugger.Break();
            programThread = new Thread(new Corrade().Program);
            programThread.Start();
        }

        // Main entry point.
        public void Program()
        {
            // Set the MTA to above normal for connection consistency.
            Thread.CurrentThread.Priority = ThreadPriority.AboveNormal;
            // Set the current directory to the service directory.
            Directory.SetCurrentDirectory(AppDomain.CurrentDomain.BaseDirectory);
            // Load the configuration file.
            lock (ConfigurationFileLock)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READING_CORRADE_CONFIGURATION));
                try
                {
                    corradeConfiguration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE, ref corradeConfiguration);
                }
                catch (Exception ex)
                {
                    Feedback(
                        Reflection.GetDescriptionFromEnumValue(
                            ConsoleError.UNABLE_TO_LOAD_CORRADE_CONFIGURATION),
                        ex.Message);
                    return;
                }
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READ_CORRADE_CONFIGURATION));
            }
            // Load group cookies.
            LoadGroupCookiesState.Invoke();
            if (!corradeConfiguration.Equals(default(Configuration)))
            {
                UpdateDynamicConfiguration(corradeConfiguration);
            }
            // Write the logo.
            Feedback(true, CORRADE_CONSTANTS.LOGO.ToArray());
            // Branch on platform and set-up termination handlers.
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32NT:
                    if (Environment.UserInteractive)
                    {
                        // Setup console handler.
                        ConsoleEventHandler += ConsoleCtrlCheck;
                        NativeMethods.SetConsoleCtrlHandler(ConsoleEventHandler, true);
                        if (Environment.UserInteractive)
                        {
                            Console.CancelKeyPress +=
                                (sender, args) => ConnectionSemaphores['u'].Set();
                        }
                    }
                    break;
            }
            // Load language detection
            try
            {
                rankedLanguageIdentifier =
                    new RankedLanguageIdentifierFactory().Load(IO.PathCombine(CORRADE_CONSTANTS.LIBS_DIRECTORY,
                        CORRADE_CONSTANTS.LANGUAGE_PROFILE_FILE));
            }
            catch (Exception ex)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_LOADING_LANGUAGE_DETECTION),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up watcher for dynamically reading the configuration file.
            FileSystemEventHandler HandleConfigurationFileChanged = null;
            try
            {
                ConfigurationWatcher.Path = Directory.GetCurrentDirectory();
                ConfigurationWatcher.Filter = CORRADE_CONSTANTS.CONFIGURATION_FILE;
                ConfigurationWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleConfigurationFileChanged = (sender, args) => ConfigurationChangedTimer.Change(1000, 0);
                ConfigurationWatcher.Changed += HandleConfigurationFileChanged;
                ConfigurationWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_CONFIGURATION_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up watcher for dynamically reading the notifications file.
            FileSystemEventHandler HandleNotificationsFileChanged = null;
            try
            {
                NotificationsWatcher.Path = Path.Combine(Directory.GetCurrentDirectory(),
                    CORRADE_CONSTANTS.STATE_DIRECTORY);
                NotificationsWatcher.Filter = CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE;
                NotificationsWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleNotificationsFileChanged = (sender, args) => NotificationsChangedTimer.Change(1000, 0);
                NotificationsWatcher.Changed += HandleNotificationsFileChanged;
                NotificationsWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_NOTIFICATIONS_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up watcher for dynamically reading the group schedules file.
            FileSystemEventHandler HandleGroupSchedulesFileChanged = null;
            try
            {
                SchedulesWatcher.Path = Path.Combine(Directory.GetCurrentDirectory(),
                    CORRADE_CONSTANTS.STATE_DIRECTORY);
                SchedulesWatcher.Filter = CORRADE_CONSTANTS.GROUP_SCHEDULES_STATE_FILE;
                SchedulesWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleGroupSchedulesFileChanged = (sender, args) => GroupSchedulesChangedTimer.Change(1000, 0);
                SchedulesWatcher.Changed += HandleGroupSchedulesFileChanged;
                SchedulesWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_SCHEDULES_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up watcher for dynamically reading the feeds file.
            FileSystemEventHandler HandleGroupFeedsFileChanged = null;
            try
            {
                GroupFeedWatcher.Path = Path.Combine(Directory.GetCurrentDirectory(),
                    CORRADE_CONSTANTS.STATE_DIRECTORY);
                GroupFeedWatcher.Filter = CORRADE_CONSTANTS.FEEDS_STATE_FILE;
                GroupFeedWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleGroupFeedsFileChanged = (sender, args) => GroupFeedsChangedTimer.Change(1000, 0);
                GroupFeedWatcher.Changed += HandleGroupFeedsFileChanged;
                GroupFeedWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_FEEDS_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up the SIML bot in case it has been enabled.
            FileSystemEventHandler HandleSIMLBotConfigurationChanged = null;
            try
            {
                SIMLBotConfigurationWatcher.Path = Path.Combine(Directory.GetCurrentDirectory(),
                    SIML_BOT_CONSTANTS.ROOT_DIRECTORY);
                SIMLBotConfigurationWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleSIMLBotConfigurationChanged = (sender, args) => SIMLConfigurationChangedTimer.Change(1000, 0);
                SIMLBotConfigurationWatcher.Changed += HandleSIMLBotConfigurationChanged;
                if (corradeConfiguration.EnableSIML)
                    SIMLBotConfigurationWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_SIML_CONFIGURATION_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Suppress standard OpenMetaverse logs, we have better ones.
            Settings.LOG_LEVEL = Helpers.LogLevel.None;
            Client.Settings.ALWAYS_REQUEST_PARCEL_ACL = true;
            Client.Settings.ALWAYS_DECODE_OBJECTS = true;
            Client.Settings.ALWAYS_REQUEST_OBJECTS = true;
            Client.Settings.SEND_AGENT_APPEARANCE = true;
            Client.Settings.AVATAR_TRACKING = true;
            Client.Settings.OBJECT_TRACKING = true;
            Client.Settings.PARCEL_TRACKING = true;
            Client.Settings.ALWAYS_REQUEST_PARCEL_DWELL = true;
            Client.Settings.SEND_AGENT_UPDATES = true;
            // Smoother movement for autopilot.
            Client.Settings.DISABLE_AGENT_UPDATE_DUPLICATE_CHECK = true;
            Client.Settings.ENABLE_CAPS = true;
            // Set the asset cache directory.
            Client.Settings.ASSET_CACHE_DIR = Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                CORRADE_CONSTANTS.ASSET_CACHE_DIRECTORY);
            Client.Settings.USE_ASSET_CACHE = true;
            Client.Assets.Cache.AutoPruneEnabled = false;
            // More precision for object and avatar tracking updates.
            Client.Settings.USE_INTERPOLATION_TIMER = true;
            Client.Settings.FETCH_MISSING_INVENTORY = true;
            // Transfer textures over HTTP if possible.
            Client.Settings.USE_HTTP_TEXTURES = true;
            // Needed for commands dealing with terrain height.
            Client.Settings.STORE_LAND_PATCHES = true;
            // Decode simulator statistics.
            Client.Settings.ENABLE_SIMSTATS = true;
            // Send pings for lag measurement.
            Client.Settings.SEND_PINGS = true;
            // Throttling.
            Client.Settings.SEND_AGENT_THROTTLE = true;
            // Enable multiple simulators.
            Client.Settings.MULTIPLE_SIMS = true;
            // Check TOS
            if (!corradeConfiguration.TOSAccepted)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TOS_NOT_ACCEPTED));
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Get the custom location.
            var startLocation = new
                wasOpenMetaverse.Helpers.StartLocationParser(corradeConfiguration.StartLocation);
            // Proceed to log-in.
            var login = new LoginParams(
                Client,
                corradeConfiguration.FirstName,
                corradeConfiguration.LastName,
                corradeConfiguration.Password,
                CORRADE_CONSTANTS.CLIENT_CHANNEL,
                CORRADE_CONSTANTS.CORRADE_VERSION.ToString(Utils.EnUsCulture),
                corradeConfiguration.LoginURL)
            {
                Author = CORRADE_CONSTANTS.WIZARDRY_AND_STEAMWORKS,
                AgreeToTos = corradeConfiguration.TOSAccepted,
                Start =
                    startLocation.isCustom
                        ? NetworkManager.StartLocation(startLocation.Sim, startLocation.X, startLocation.Y,
                            startLocation.Z)
                        : corradeConfiguration.StartLocation,
                UserAgent = CORRADE_CONSTANTS.USER_AGENT.ToString()
            };
            // Set the outgoing IP address if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.BindIPAddress))
            {
                try
                {
                    Settings.BIND_ADDR = IPAddress.Parse(corradeConfiguration.BindIPAddress);
                }
                catch (Exception ex)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNKNOWN_IP_ADDRESS), ex.Message);
                    Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
                }
            }
            // Set the ID0 if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.DriveIdentifierHash))
            {
                login.ID0 = Utils.MD5String(corradeConfiguration.DriveIdentifierHash);
            }
            // Set the MAC if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.NetworkCardMAC))
            {
                login.MAC = Utils.MD5String(corradeConfiguration.NetworkCardMAC);
            }
            // Load Corrade caches.
            LoadCorradeCache.Invoke();
            // Load group members.
            LoadGroupMembersState.Invoke();
            // Load notification state.
            LoadNotificationState.Invoke();
            // Load group scheduls state.
            LoadGroupSchedulesState.Invoke();
            // Load feeds state.
            LoadGroupFeedState.Invoke();
            // Start the callback thread to send callbacks.
            var CallbackThread = new Thread(() =>
            {
                do
                {
                    try
                    {
                        var callbackQueueElement = new CallbackQueueElement();
                        if (CallbackQueue.Dequeue((int) corradeConfiguration.CallbackThrottle, ref callbackQueueElement))
                        {
                            CorradeThreadPool[CorradeThreadType.POST].Spawn(async () =>
                            {
                                Web.wasHTTPClient wasHTTPClient;
                                lock (GroupHTTPClientsLock)
                                {
                                    GroupHTTPClients.TryGetValue(callbackQueueElement.GroupUUID,
                                        out wasHTTPClient);
                                }
                                if (wasHTTPClient != null)
                                {
                                    await wasHTTPClient.POST(callbackQueueElement.URL, callbackQueueElement.message);
                                }
                            }, corradeConfiguration.MaximumPOSTThreads);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CALLBACK_ERROR),
                            ex.Message);
                    }
                } while (runCallbackThread);
            })
            {IsBackground = true};
            CallbackThread.Start();
            // Start the notification thread for notifications.
            var NotificationThread = new Thread(() =>
            {
                do
                {
                    try
                    {
                        var notificationQueueElement = new NotificationQueueElement();
                        if (NotificationQueue.Dequeue((int) corradeConfiguration.NotificationThrottle,
                            ref notificationQueueElement))
                        {
                            CorradeThreadPool[CorradeThreadType.POST].Spawn(async () =>
                            {
                                Web.wasHTTPClient wasHTTPClient;
                                lock (GroupHTTPClientsLock)
                                {
                                    GroupHTTPClients.TryGetValue(notificationQueueElement.GroupUUID,
                                        out wasHTTPClient);
                                }
                                if (wasHTTPClient != null)
                                {
                                    await
                                        wasHTTPClient.POST(notificationQueueElement.URL,
                                            notificationQueueElement.message);
                                }
                            },
                                corradeConfiguration.MaximumPOSTThreads);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR),
                            ex.Message);
                    }
                } while (runNotificationThread);
            })
            {IsBackground = true};
            NotificationThread.Start();
            // Install non-dynamic global event handlers.
            Client.Inventory.InventoryObjectOffered += HandleInventoryObjectOffered;
            Client.Network.LoginProgress += HandleLoginProgress;
            Client.Appearance.AppearanceSet += HandleAppearanceSet;
            Client.Network.SimConnected += HandleSimulatorConnected;
            Client.Network.Disconnected += HandleDisconnected;
            Client.Network.SimDisconnected += HandleSimulatorDisconnected;
            Client.Network.EventQueueRunning += HandleEventQueueRunning;
            Client.Self.TeleportProgress += HandleTeleportProgress;
            Client.Self.ChatFromSimulator += HandleChatFromSimulator;
            Client.Groups.GroupJoinedReply += HandleGroupJoined;
            Client.Groups.GroupLeaveReply += HandleGroupLeave;
            // Each Instant Message is processed in its own thread.
            Client.Self.IM += (sender, args) => CorradeThreadPool[CorradeThreadType.INSTANT_MESSAGE].Spawn(
                () => HandleSelfIM(sender, args),
                corradeConfiguration.MaximumInstantMessageThreads);
            // Log-in to the grid.
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.LOGGING_IN));
            Client.Network.BeginLogin(login);
            /*
             * The main thread spins around waiting for the semaphores to become invalidated,
             * at which point Corrade will consider its connection to the grid severed and
             * will terminate.
             *
             */
            WaitHandle.WaitAny(ConnectionSemaphores.Values.Select(o => (WaitHandle) o).ToArray());
            // Now log-out.
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.LOGGING_OUT));
            // Disable the configuration watcher.
            try
            {
                ConfigurationWatcher.EnableRaisingEvents = false;
                ConfigurationWatcher.Changed -= HandleConfigurationFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the notifications watcher.
            try
            {
                NotificationsWatcher.EnableRaisingEvents = false;
                NotificationsWatcher.Changed -= HandleNotificationsFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the group schedule watcher.
            try
            {
                SchedulesWatcher.EnableRaisingEvents = false;
                SchedulesWatcher.Changed -= HandleGroupSchedulesFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the SIML bot configuration watcher.
            try
            {
                SIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                SIMLBotConfigurationWatcher.Changed -= HandleSIMLBotConfigurationChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the RSS feeds watcher.
            try
            {
                GroupFeedWatcher.EnableRaisingEvents = false;
                GroupFeedWatcher.Changed -= HandleGroupFeedsFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }

            // Uninstall all installed handlers
            Client.Self.IM -= HandleSelfIM;
            Client.Network.SimChanged -= HandleRadarObjects;
            Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
            Client.Objects.ObjectUpdate -= HandleObjectUpdate;
            Client.Objects.KillObject -= HandleKillObject;
            Client.Self.AnimationsChanged -= HandleAnimationsChanged;
            Client.Self.LoadURL -= HandleLoadURL;
            Client.Self.ScriptControlChange -= HandleScriptControlChange;
            Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
            Client.Network.SimChanged -= HandleSimChanged;
            Client.Self.RegionCrossed -= HandleRegionCrossed;
            Client.Self.MeanCollision -= HandleMeanCollision;
            Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffect -= HandleViewerEffect;
            Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
            Client.Self.ScriptDialog -= HandleScriptDialog;
            Client.Objects.AvatarSitChanged -= HandleAvatarSitChanged;
            Client.Self.ChatFromSimulator -= HandleChatFromSimulator;
            Client.Self.MoneyBalance -= HandleMoneyBalance;
            Client.Self.AlertMessage -= HandleAlertMessage;
            Client.Self.ScriptQuestion -= HandleScriptQuestion;
            Client.Self.TeleportProgress -= HandleTeleportProgress;
            Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
            Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
            Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
            Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
            Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
            Client.Network.EventQueueRunning -= HandleEventQueueRunning;
            Client.Network.SimDisconnected -= HandleSimulatorDisconnected;
            Client.Network.Disconnected -= HandleDisconnected;
            Client.Network.SimConnected -= HandleSimulatorConnected;
            Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            Client.Network.LoginProgress -= HandleLoginProgress;
            Client.Inventory.InventoryObjectOffered -= HandleInventoryObjectOffered;
            // Save conferences state.
            SaveConferenceState.Invoke();
            // Save feeds state.
            SaveGroupFeedState.Invoke();
            // Save notification states.
            SaveNotificationState.Invoke();
            // Save group members.
            SaveGroupMembersState.Invoke();
            // Save group schedules.
            SaveGroupSchedulesState.Invoke();
            // Save movement state.
            SaveMovementState.Invoke();
            // Save Corrade caches.
            SaveCorradeCache.Invoke();
            // Stop the sphere effects expiration thread.
            runEffectsExpirationThread = false;
            if (EffectsExpirationThread != null)
            {
                try
                {
                    if (
                        EffectsExpirationThread.ThreadState.Equals(ThreadState.Running) ||
                        EffectsExpirationThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                    {
                        if (!EffectsExpirationThread.Join(1000))
                        {
                            EffectsExpirationThread.Abort();
                            EffectsExpirationThread.Join();
                        }
                    }
                }
                catch (Exception)
                {
                    /* We are going down and we do not care. */
                }
                finally
                {
                    EffectsExpirationThread = null;
                }
            }
            // Stop the group member sweep thread.
            StopGroupMembershipSweepThread.Invoke();

            // Stop the group feed thread.
            StopGroupFeedThread.Invoke();

            // Stop the notification thread.
            try
            {
                runNotificationThread = false;
                if (
                    NotificationThread.ThreadState.Equals(ThreadState.Running) ||
                    NotificationThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                {
                    if (!NotificationThread.Join(1000))
                    {
                        NotificationThread.Abort();
                        NotificationThread.Join();
                    }
                }
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            finally
            {
                NotificationThread = null;
            }

            // Stop the callback thread.
            try
            {
                runCallbackThread = false;
                if (
                    CallbackThread.ThreadState.Equals(ThreadState.Running) ||
                    CallbackThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                {
                    if (!CallbackThread.Join(1000))
                    {
                        CallbackThread.Abort();
                        CallbackThread.Join();
                    }
                }
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            finally
            {
                NotificationThread = null;
            }

            // Save group cookies.
            SaveGroupCookiesState.Invoke();

            // Close HTTP server
            if (HttpListener.IsSupported && corradeConfiguration.EnableHTTPServer)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.STOPPING_HTTP_SERVER));
                runHTTPServer = false;
                try
                {
                    if (HTTPListenerThread != null)
                    {
                        HTTPListener.Stop();
                        if (
                            HTTPListenerThread.ThreadState.Equals(ThreadState.Running) ||
                            HTTPListenerThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                        {
                            if (!HTTPListenerThread.Join(1000))
                            {
                                HTTPListenerThread.Abort();
                                HTTPListenerThread.Join();
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    /* We are going down and we do not care. */
                }
                finally
                {
                    HTTPListenerThread = null;
                }
            }
            // Reject any inventory that has not been accepted.
            lock (InventoryOffersLock)
            {
                InventoryOffers.AsParallel().ForAll(o =>
                {
                    o.Key.Accept = false;
                    o.Value.Set();
                });
            }
            // Logout
            if (Client.Network.Connected)
            {
                // Full speed ahead; do not even attempt to grab a lock.
                var LoggedOutEvent = new ManualResetEvent(false);
                EventHandler<LoggedOutEventArgs> LoggedOutEventHandler = (sender, args) => LoggedOutEvent.Set();
                Client.Network.LoggedOut += LoggedOutEventHandler;
                Client.Network.RequestLogout();
                if (!LoggedOutEvent.WaitOne((int) corradeConfiguration.LogoutGrace, false))
                {
                    Client.Network.LoggedOut -= LoggedOutEventHandler;
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TIMEOUT_LOGGING_OUT));
                }
                Client.Network.LoggedOut -= LoggedOutEventHandler;
            }
            if (Client.Network.Connected)
            {
                Client.Network.Shutdown(NetworkManager.DisconnectType.ClientInitiated);
            }

            // Terminate.
            Environment.Exit(corradeConfiguration.ExitCodeExpected);
        }

        private static void HandleAvatarUpdate(object sender, AvatarUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.RadarAvatars, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleObjectUpdate(object sender, PrimEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.RadarPrimitives, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleKillObject(object sender, KillObjectEventArgs e)
        {
            Primitive primitive;
            lock (RadarObjectsLock)
            {
                if (!RadarObjects.TryGetValue(e.ObjectLocalID, out primitive)) return;
            }
            switch (primitive is Avatar)
            {
                case true:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.RadarAvatars, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                default:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.RadarPrimitives, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
            }
        }

        private static void HandleGroupJoined(object sender, GroupOperationEventArgs e)
        {
            // Add the group to the cache.
            Cache.AddCurrentGroup(e.GroupID);

            // Join group chat if possible.
            if (!Client.Self.GroupChatSessions.ContainsKey(e.GroupID) &&
                Services.HasGroupPowers(Client, Client.Self.AgentID, e.GroupID, GroupPowers.JoinChat,
                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                    new Time.DecayingAlarm(corradeConfiguration.DataDecayType)))
            {
                Services.JoinGroupChat(Client, e.GroupID, corradeConfiguration.ServicesTimeout);
            }
        }

        private static void HandleGroupLeave(object sender, GroupOperationEventArgs e)
        {
            // Remove the group from the cache.
            Cache.CurrentGroupsCache.Remove(e.GroupID);
        }

        private static void HandleLoadURL(object sender, LoadUrlEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.LoadURL, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleScriptControlChange(object sender, ScriptControlEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.ScriptControl, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleAppearanceSet(object sender, AppearanceSetEventArgs e)
        {
            switch (e.Success)
            {
                case true:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_SUCCEEDED));
                    break;
                default:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_FAILED));
                    break;
            }
        }

        private static void HandleRegionCrossed(object sender, RegionCrossedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.RegionCrossed, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMeanCollision(object sender, MeanCollisionEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.MeanCollision, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleViewerEffect(object sender, object e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.ViewerEffect, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        /// <summary>
        ///     Processes HTTP POST web-requests.
        /// </summary>
        /// <param name="ar">the async HTTP listener object</param>
        private static void ProcessHTTPRequest(IAsyncResult ar)
        {
            // We need to grab the context and everything else outside of the main request.
            HttpListenerContext httpContext = null;
            HttpListenerRequest httpRequest;
            string message;
            Configuration.Group commandGroup;
            // Now grab the message and check that the group is set or abandon.
            try
            {
                var httpListener = (HttpListener) ar.AsyncState;
                // bail if we are not listening
                if (httpListener == null || !httpListener.IsListening) return;
                httpContext = httpListener.EndGetContext(ar);
                if (httpContext.Request == null) throw new HTTPCommandException();
                httpRequest = httpContext.Request;
                // only accept POST requests
                if (
                    !string.Equals(WebRequestMethods.Http.Post, httpRequest.HttpMethod,
                        StringComparison.OrdinalIgnoreCase))
                    throw new HTTPCommandException();
                // only accept connected remote endpoints
                if (httpRequest.RemoteEndPoint == null) throw new HTTPCommandException();
                // Retrieve the message sent even if it is a compressed stream.
                switch (httpRequest.ContentEncoding.EncodingName.ToLower())
                {
                    case "gzip":
                        using (var inputStream = new MemoryStream())
                        {
                            using (var dataGZipStream = new GZipStream(httpRequest.InputStream,
                                CompressionMode.Decompress, false))
                            {
                                dataGZipStream.CopyTo(inputStream);
                                //dataGZipStream.Flush();
                            }
                            message = inputStream.ToString();
                        }
                        break;
                    case "deflate":
                        using (var inputStream = new MemoryStream())
                        {
                            using (
                                var dataDeflateStream = new DeflateStream(httpRequest.InputStream,
                                    CompressionMode.Decompress, false))
                            {
                                dataDeflateStream.CopyTo(inputStream);
                                //dataDeflateStream.Flush();
                            }
                            message = inputStream.ToString();
                        }
                        break;
                    default:
                        using (
                            var reader = new StreamReader(httpRequest.InputStream,
                                httpRequest.ContentEncoding))
                        {
                            message = reader.ReadToEnd();
                        }
                        break;
                }
                // ignore empty messages right-away.
                if (string.IsNullOrEmpty(message)) throw new HTTPCommandException();
                commandGroup = GetCorradeGroupFromMessage(message);
                // do not process anything from unknown groups.
                if (commandGroup.Equals(default(Configuration.Group))) throw new HTTPCommandException();
            }
            catch (HTTPCommandException)
            {
                /* Close the connection and bail if the preconditions are not satisifed for running the command. */
                httpContext?.Response.Close();
                return;
            }
            catch (HttpListenerException)
            {
                /* This happens when the server goes down, so do not scare the user since it is completely harmelss. */
                return;
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_PROCESSING_ABORTED),
                    ex.Message);
                return;
            }

            // We have the group so schedule the Corrade command though the group scheduler.
            CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(() =>
            {
                try
                {
                    var result = HandleCorradeCommand(message,
                        CORRADE_CONSTANTS.WEB_REQUEST,
                        httpRequest.RemoteEndPoint.ToString(), commandGroup);
                    using (var response = httpContext.Response)
                    {
                        // set the content type based on chosen output filers
                        switch (corradeConfiguration.OutputFilters.Last())
                        {
                            case Configuration.Filter.RFC1738:
                                response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                                break;
                            default:
                                response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                                break;
                        }
                        response.StatusCode = (int) HttpStatusCode.OK;
                        response.StatusDescription = "OK";
                        response.SendChunked = true;
                        switch (corradeConfiguration.HTTPServerKeepAlive)
                        {
                            case true:
                                response.ProtocolVersion = HttpVersion.Version11;
                                break;
                            default:
                                response.ProtocolVersion = HttpVersion.Version10;
                                response.KeepAlive = false;
                                break;
                        }
                        var data =
                            Encoding.UTF8.GetBytes(
                                KeyValue.Encode(KeyValue.Escape(result, wasOutput)));
                        using (var outputStream = new MemoryStream())
                        {
                            switch (corradeConfiguration.HTTPServerCompression)
                            {
                                case Configuration.HTTPCompressionMethod.GZIP:
                                    using (var dataGZipStream = new GZipStream(outputStream,
                                        CompressionMode.Compress, false))
                                    {
                                        dataGZipStream.Write(data, 0, data.Length);
                                        //dataGZipStream.Flush();
                                    }
                                    response.AddHeader("Content-Encoding", "gzip");
                                    data = outputStream.ToArray();
                                    break;
                                case Configuration.HTTPCompressionMethod.DEFLATE:
                                    using (
                                        var dataDeflateStream = new DeflateStream(outputStream,
                                            CompressionMode.Compress, false))
                                    {
                                        dataDeflateStream.Write(data, 0, data.Length);
                                        //dataDeflateStream.Flush();
                                    }
                                    response.AddHeader("Content-Encoding", "deflate");
                                    data = outputStream.ToArray();
                                    break;
                                default:
                                    response.AddHeader("Content-Encoding", "UTF-8");
                                    break;
                            }
                        }
                        using (var responseStream = response.OutputStream)
                        {
                            using (var responseBinaryWriter = new BinaryWriter(responseStream))
                            {
                                responseBinaryWriter.Write(data);
                            }
                        }
                    }
                }
                catch (HttpListenerException)
                {
                    /* This happens when the server goes down, so do not scare the user since it is completely harmless. */
                }
                catch (Exception ex)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_PROCESSING_ABORTED),
                        ex.Message);
                }
                finally
                {
                    /* Close the connection. */
                    httpContext?.Response.Close();
                }
            }, corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                corradeConfiguration.SchedulerExpiration);
        }

        /// <summary>
        ///     Sends a notification to each group with a configured and installed notification.
        /// </summary>
        /// <param name="notification">the notification to send</param>
        /// <param name="args">the event arguments</param>
        private static void SendNotification(Configuration.Notifications notification, object args)
        {
            // Create a list of groups that have the notification installed.
            HashSet<Notification> notifications;
            lock (GroupNotificationsLock)
            {
                if (!GroupNotificationsCache.TryGetValue(notification, out notifications) || !notifications.Any())
                    return;
            }

            // Find the notification action.
            var CorradeNotification =
                corradeNotifications[Reflection.GetNameFromEnumValue(notification)];
            if (CorradeNotification == null)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR),
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.UNKNOWN_NOTIFICATION_TYPE),
                    Reflection.GetNameFromEnumValue(notification));
                return;
            }

            // For each group build the notification.
            notifications.AsParallel().ForAll(z =>
            {
                // Create the notification data storage for this notification.
                var notificationData = new Dictionary<string, string>();

                try
                {
                    CorradeNotification.Invoke(new CorradeNotificationParameters
                    {
                        Notification = z,
                        Event = args
                    }, notificationData);
                }
                catch (Exception ex)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR), ex.Message);
                    return;
                }

                // Do not send empty notifications.
                if (!notificationData.Any()) return;

                // Add the notification type.
                notificationData.Add(Reflection.GetNameFromEnumValue(ScriptKeys.TYPE),
                    Reflection.GetNameFromEnumValue(notification));

                // Build the afterburn.
                if (z.Afterburn != null && z.Afterburn.Any())
                {
                    notificationData = notificationData.Concat(z.Afterburn).ToDictionary(o => o.Key, o => o.Value);
                }

                // Enqueue the notification for the group.
                if (z.NotificationURLDestination != null && z.NotificationURLDestination.Any())
                {
                    HashSet<string> URLdestinations;
                    if (z.NotificationURLDestination.TryGetValue(notification, out URLdestinations))
                    {
                        URLdestinations.AsParallel().ForAll(p =>
                        {
                            // Check that the notification queue is not already full.
                            switch (NotificationQueue.Count <= corradeConfiguration.NotificationQueueLength)
                            {
                                case true:
                                    NotificationQueue.Enqueue(new NotificationQueueElement
                                    {
                                        GroupUUID = z.GroupUUID,
                                        URL = p,
                                        message = KeyValue.Escape(notificationData, wasOutput)
                                    });
                                    break;
                                default:
                                    Feedback(
                                        Reflection.GetDescriptionFromEnumValue(
                                            ConsoleError.NOTIFICATION_THROTTLED));
                                    break;
                            }
                        });
                    }
                }

                // Enqueue the TCP notification for the group.
                if (z.NotificationTCPDestination != null && z.NotificationTCPDestination.Any())
                {
                    HashSet<IPEndPoint> TCPdestinations;
                    if (z.NotificationTCPDestination.TryGetValue(notification, out TCPdestinations))
                    {
                        TCPdestinations.AsParallel().ForAll(p =>
                        {
                            switch (
                                NotificationTCPQueue.Count <= corradeConfiguration.TCPNotificationQueueLength)
                            {
                                case true:
                                    NotificationTCPQueue.Enqueue(new NotificationTCPQueueElement
                                    {
                                        message = KeyValue.Escape(notificationData, wasOutput),
                                        IPEndPoint = p
                                    });
                                    break;
                                default:
                                    Feedback(
                                        Reflection.GetDescriptionFromEnumValue(
                                            ConsoleError.TCP_NOTIFICATION_THROTTLED));
                                    break;
                            }
                        });
                    }
                }
            });
        }

        private static void HandleScriptDialog(object sender, ScriptDialogEventArgs e)
        {
            lock (ScriptDialogLock)
            {
                ScriptDialogs.Add(new ScriptDialog
                {
                    Message = e.Message,
                    Agent = new Agent
                    {
                        FirstName = e.FirstName,
                        LastName = e.LastName,
                        UUID = e.OwnerID
                    },
                    Channel = e.Channel,
                    Name = e.ObjectName,
                    Item = e.ObjectID,
                    Button = e.ButtonLabels
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.ScriptDialog, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleAvatarSitChanged(object sender, AvatarSitChangedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.SitChanged, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleSoundTrigger(object sender, SoundTriggerEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Sound, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleAnimationsChanged(object sender, AnimationsChangedEventArgs e)
        {
            lock (CurrentAnimationsLock)
            {
                if (!e.Animations.Copy().Except(CurrentAnimations).Any())
                    return;
                CurrentAnimations.Clear();
                CurrentAnimations.UnionWith(e.Animations.Copy());
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.AnimationsChanged, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleChatFromSimulator(object sender, ChatEventArgs e)
        {
            // Check if message is from muted agent or object and ignore it.
            if (Cache.MutesCache != null && Cache.MutesCache.Any(o => o.ID.Equals(e.SourceID) || o.ID.Equals(e.OwnerID)))
                return;
            // Get the full name.
            var fullName = new List<string>(wasOpenMetaverse.Helpers.GetAvatarNames(e.FromName));
            Configuration.Group commandGroup;
            switch (e.Type)
            {
                case ChatType.StartTyping:
                case ChatType.StopTyping:
                    Cache.AddAgent(fullName.First(), fullName.Last(), e.SourceID);
                    // Send typing notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.Typing, new TypingEventArgs
                        {
                            Action = !e.Type.Equals(
                                ChatType.StartTyping)
                                ? Action.STOP
                                : Action.START,
                            AgentUUID = e.SourceID,
                            FirstName = fullName.First(),
                            LastName = fullName.Last(),
                            Entity = Entity.LOCAL
                        }),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                case ChatType.OwnerSay:
                    // If this is a message from an agent, add the agent to the cache.
                    if (e.SourceType.Equals(ChatSourceType.Agent))
                    {
                        Cache.AddAgent(fullName.First(), fullName.Last(), e.SourceID);
                    }
                    // If RLV is enabled, process RLV and terminate.
                    if (corradeConfiguration.EnableRLV && e.Message.StartsWith(RLV_CONSTANTS.COMMAND_OPERATOR))
                    {
                        // Send RLV message notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Configuration.Notifications.RLVMessage, e),
                            corradeConfiguration.MaximumNotificationThreads);
                        CorradeThreadPool[CorradeThreadType.RLV].SpawnSequential(
                            () => HandleRLVBehaviour(e.Message.Substring(1, e.Message.Length - 1), e.SourceID),
                            corradeConfiguration.MaximumRLVThreads, corradeConfiguration.ServicesTimeout);
                        break;
                    }
                    // If this is a Corrade command, process it and terminate.
                    if (IsCorradeCommand(e.Message))
                    {
                        // If the group was not set properly, then bail.
                        commandGroup = GetCorradeGroupFromMessage(e.Message);
                        switch (!commandGroup.Equals(default(Configuration.Group)))
                        {
                            case false:
                                return;
                        }
                        // Spawn the command.
                        CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                            () => HandleCorradeCommand(e.Message, e.FromName, e.OwnerID.ToString(), commandGroup),
                            corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                            corradeConfiguration.SchedulerExpiration);
                        return;
                    }
                    // Otherwise, send llOwnerSay notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.OwnerSay, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                case ChatType.Debug:
                    // Send debug notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.DebugMessage, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                case ChatType.Normal:
                case ChatType.Shout:
                case ChatType.Whisper:
                    // If this is a message from an agent, add the agent to the cache.
                    if (e.SourceType.Equals(ChatSourceType.Agent))
                    {
                        Cache.AddAgent(fullName.First(), fullName.Last(), e.SourceID);
                    }
                    // Send chat notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.LocalChat, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    // Log local chat if the message could be heard.
                    if (corradeConfiguration.LocalMessageLogEnabled && !string.IsNullOrEmpty(e.Message))
                    {
                        CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                        {
                            try
                            {
                                lock (LocalLogFileLock)
                                {
                                    using (
                                        var fileStream =
                                            File.Open(Path.Combine(corradeConfiguration.LocalMessageLogDirectory,
                                                Client.Network.CurrentSim.Name) +
                                                      "." +
                                                      CORRADE_CONSTANTS.LOG_FILE_EXTENSION, FileMode.Append,
                                                FileAccess.Write, FileShare.None))
                                    {
                                        using (var logWriter = new StreamWriter(fileStream, Encoding.UTF8))
                                        {
                                            logWriter.WriteLine(CORRADE_CONSTANTS.LOCAL_MESSAGE_LOG_MESSAGE_FORMAT,
                                                DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                    Utils.EnUsCulture.DateTimeFormat),
                                                fullName.First(), fullName.Last(),
                                                Enum.GetName(typeof (ChatType), e.Type),
                                                e.Message);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                // or fail and append the fail message.
                                Feedback(
                                    Reflection.GetDescriptionFromEnumValue(
                                        ConsoleError.COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE),
                                    ex.Message);
                            }
                        }, corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
                    }
                    break;
                case (ChatType) 9:
                    // Send llRegionSayTo notification in case we do not have a command.
                    if (!IsCorradeCommand(e.Message))
                    {
                        // Send chat notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Configuration.Notifications.RegionSayTo, e),
                            corradeConfiguration.MaximumNotificationThreads);
                        break;
                    }
                    // If the group was not set properly, then bail.
                    commandGroup = GetCorradeGroupFromMessage(e.Message);
                    switch (!commandGroup.Equals(default(Configuration.Group)))
                    {
                        case false:
                            return;
                    }
                    // Spawn the command.
                    CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                        () => HandleCorradeCommand(e.Message, e.FromName, e.OwnerID.ToString(), commandGroup),
                        corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                        corradeConfiguration.SchedulerExpiration);
                    break;
            }
        }

        private static void HandleAlertMessage(object sender, AlertMessageEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.AlertMessage, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleInventoryObjectOffered(object sender, InventoryObjectOfferedEventArgs e)
        {
            // Send notification
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Inventory, e),
                corradeConfiguration.MaximumNotificationThreads);

            // Accept anything from master avatars.
            if (
                corradeConfiguration.Masters.AsParallel().Select(
                    o => string.Format(Utils.EnUsCulture, "{0} {1}", o.FirstName, o.LastName))
                    .Any(p => string.Equals(e.Offer.FromAgentName, p, StringComparison.OrdinalIgnoreCase)))
            {
                e.Accept = true;
                // It is accepted, so update the inventory.
                try
                {
                    Inventory.UpdateInventoryRecursive(Client,
                        Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                            InventoryFolder, corradeConfiguration.ServicesTimeout);
                }
                catch (Exception)
                {
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_UPDATING_INVENTORY));
                }
                return;
            }

            // We need to block until we get a reply from a script.
            var wait = new ManualResetEvent(false);
            // Add the inventory offer to the list of inventory items.
            lock (InventoryOffersLock)
            {
                InventoryOffers.Add(e, wait);
            }

            // It is temporary, so update the inventory.
            try
            {
                Inventory.UpdateInventoryRecursive(Client,
                    Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                        InventoryFolder, corradeConfiguration.ServicesTimeout);
            }
            catch (Exception)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_UPDATING_INVENTORY));
            }

            // Find the item in the inventory.
            InventoryBase inventoryBaseItem;
            lock (Locks.ClientInstanceInventoryLock)
            {
                inventoryBaseItem =
                    Inventory.FindInventory<InventoryBase>(Client, Client.Inventory.Store.RootNode,
                        ((Func<string>) (() =>
                        {
                            var groups =
                                CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(e.Offer.Message).Groups;
                            return groups.Count > 0 ? groups[1].Value : e.Offer.Message;
                        }))(), corradeConfiguration.ServicesTimeout
                        ).FirstOrDefault();
            }

            if (inventoryBaseItem != null)
            {
                // Assume we do not want the item.
                lock (Locks.ClientInstanceInventoryLock)
                {
                    Client.Inventory.Move(
                        inventoryBaseItem,
                        Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(AssetType.TrashFolder)].Data as
                            InventoryFolder);
                }
            }

            // Wait for a reply.
            wait.WaitOne(Timeout.Infinite);

            if (!e.Accept) return;

            // If no folder UUID was specified, move it to the default folder for the asset type.
            if (inventoryBaseItem != null)
            {
                switch (!e.FolderID.Equals(UUID.Zero))
                {
                    case true:
                        InventoryBase inventoryBaseFolder;
                        lock (Locks.ClientInstanceInventoryLock)
                        {
                            // Locate the folder and move.
                            inventoryBaseFolder =
                                Inventory.FindInventory<InventoryBase>(Client, Client.Inventory.Store.RootNode,
                                    e.FolderID, corradeConfiguration.ServicesTimeout
                                    ).FirstOrDefault();
                            if (inventoryBaseFolder != null)
                            {
                                Client.Inventory.Move(inventoryBaseItem, inventoryBaseFolder as InventoryFolder);
                            }
                        }
                        if (inventoryBaseFolder != null)
                        {
                            Inventory.UpdateInventoryRecursive(Client, inventoryBaseFolder as InventoryFolder,
                                corradeConfiguration.ServicesTimeout);
                        }
                        break;
                    default:
                        lock (Locks.ClientInstanceInventoryLock)
                        {
                            Client.Inventory.Move(
                                inventoryBaseItem,
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                                    InventoryFolder);
                        }
                        try
                        {
                            Inventory.UpdateInventoryRecursive(Client,
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data
                                    as
                                    InventoryFolder, corradeConfiguration.ServicesTimeout);
                        }
                        catch (Exception)
                        {
                            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_UPDATING_INVENTORY));
                        }
                        break;
                }
            }
        }

        private static void HandleScriptQuestion(object sender, ScriptQuestionEventArgs e)
        {
            var owner = new List<string>(wasOpenMetaverse.Helpers.GetAvatarNames(e.ObjectOwnerName));
            var ownerUUID = UUID.Zero;
            // Don't add permission requests from unknown agents.
            if (
                !Resolvers.AgentNameToUUID(Client, owner.First(), owner.Last(), corradeConfiguration.ServicesTimeout,
                    corradeConfiguration.DataTimeout,
                    new Time.DecayingAlarm(corradeConfiguration.DataDecayType),
                    ref ownerUUID))
            {
                return;
            }

            lock (ScriptPermissionRequestLock)
            {
                ScriptPermissionRequests.Add(new ScriptPermissionRequest
                {
                    Name = e.ObjectName,
                    Agent = new Agent
                    {
                        FirstName = owner.First(),
                        LastName = owner.Last(),
                        UUID = ownerUUID
                    },
                    Item = e.ItemID,
                    Task = e.TaskID,
                    Permission = e.Questions,
                    Region = e.Simulator.Name
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.ScriptPermission, e),
                corradeConfiguration.MaximumNotificationThreads);

            // Handle RLV: acceptpermission
            lock (RLVRulesLock)
            {
                if (
                    !RLVRules.AsParallel()
                        .Any(o => o.Behaviour.Equals(Reflection.GetNameFromEnumValue(RLVBehaviour.ACCEPTPERMISSION))))
                    return;
                lock (Locks.ClientInstanceSelfLock)
                {
                    Client.Self.ScriptQuestionReply(e.Simulator, e.ItemID, e.TaskID, e.Questions);
                }
            }
        }

        private static void HandleDisconnected(object sender, DisconnectedEventArgs e)
        {
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.DISCONNECTED));
            ConnectionSemaphores['l'].Set();
        }

        private static void HandleEventQueueRunning(object sender, EventQueueRunningEventArgs e)
        {
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.EVENT_QUEUE_STARTED));
        }

        private static void HandleSimulatorConnected(object sender, SimConnectedEventArgs e)
        {
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.SIMULATOR_CONNECTED));
        }

        private static void HandleSimulatorDisconnected(object sender, SimDisconnectedEventArgs e)
        {
            // if any simulators are still connected, we are not disconnected
            lock (Locks.ClientInstanceNetworkLock)
            {
                if (Client.Network.Simulators.Any()) return;
            }
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ALL_SIMULATORS_DISCONNECTED));
            ConnectionSemaphores['s'].Set();
        }

        private static void HandleLoginProgress(object sender, LoginProgressEventArgs e)
        {
            switch (e.Status)
            {
                case LoginStatus.Success:
                    // Login succeeded so start all the updates.
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.LOGIN_SUCCEEDED));
                    // Load movement state.
                    LoadMovementState.Invoke();
                    // Start thread and wait on caps to restore conferences.
                    new Thread(() =>
                    {
                        var EventQueueRunningEvent = new ManualResetEvent(false);
                        EventHandler<EventQueueRunningEventArgs> EventQueueRunningHandler =
                            (o, p) => { EventQueueRunningEvent.Set(); };
                        Client.Network.EventQueueRunning += EventQueueRunningHandler;
                        if (EventQueueRunningEvent.WaitOne(Timeout.Infinite, false))
                        {
                            // Load conference state.
                            LoadConferenceState.Invoke();
                        }
                        Client.Network.EventQueueRunning -= EventQueueRunningHandler;
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Start inventory update thread.
                    new Thread(() =>
                    {
                        // First load the caches.
                        LoadInventoryCache.Invoke();
                        // Update the inventory.
                        try
                        {
                            // Update the inventory.
                            Inventory.UpdateInventoryRecursive(Client, Client.Inventory.Store.RootFolder,
                                corradeConfiguration.ServicesTimeout);
                            // Get COF.
                            lock (Locks.ClientInstanceInventoryLock)
                            {
                                CurrentOutfitFolder =
                                    Client.Inventory.Store[
                                        Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)
                                        ] as
                                        InventoryFolder;
                            }
                        }
                        catch (Exception)
                        {
                            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_UPDATING_INVENTORY));
                        }
                        // Now save the caches.
                        SaveInventoryCache.Invoke();
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Set current group to land group.
                    new Thread(() =>
                    {
                        if (!corradeConfiguration.AutoActivateGroup) return;
                        ActivateCurrentLandGroupTimer.Change(corradeConfiguration.AutoActivateGroupDelay, 0);
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Retrieve instant messages.
                    new Thread(() =>
                    {
                        lock (Locks.ClientInstanceSelfLock)
                        {
                            Client.Self.RetrieveInstantMessages();
                        }
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Request the mute list.
                    new Thread(() =>
                    {
                        var mutes = Enumerable.Empty<MuteEntry>();
                        if (!Services.GetMutes(Client, corradeConfiguration.ServicesTimeout, ref mutes))
                            return;
                        Cache.MutesCache.UnionWith(mutes);
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Set the camera on the avatar.
                    Client.Self.Movement.Camera.LookAt(
                        Client.Self.SimPosition,
                        Client.Self.SimPosition
                        );

                    break;
                case LoginStatus.Failed:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.LOGIN_FAILED), e.FailReason, e.Message);
                    ConnectionSemaphores['l'].Set();
                    break;
                case LoginStatus.ConnectingToLogin:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CONNECTING_TO_LOGIN_SERVER));
                    break;
                case LoginStatus.Redirecting:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.REDIRECTING));
                    break;
                case LoginStatus.ReadingResponse:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.READING_RESPONSE));
                    break;
                case LoginStatus.ConnectingToSim:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CONNECTING_TO_SIMULATOR));
                    break;
            }
        }

        private static void HandleFriendOnlineStatus(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendRightsUpdate(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendShipResponse(object sender, FriendshipResponseEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendshipOffered(object sender, FriendshipOfferedEventArgs e)
        {
            // Send friendship notifications
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleTeleportProgress(object sender, TeleportEventArgs e)
        {
            switch (e.Status)
            {
                case TeleportStatus.Finished:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TELEPORT_SUCCEEDED));
                    // Set current group to land group.
                    if (corradeConfiguration.AutoActivateGroup)
                    {
                        new Thread(
                            () =>
                            {
                                ActivateCurrentLandGroupTimer.Change(corradeConfiguration.AutoActivateGroupDelay, 0);
                            })
                        {IsBackground = true}.Start();
                    }
                    break;
                case TeleportStatus.Failed:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TELEPORT_FAILED));
                    break;
            }
        }

        private static void HandleSelfIM(object sender, InstantMessageEventArgs args)
        {
            // Check if message is from muted agent and ignore it.
            if (Cache.MutesCache != null && Cache.MutesCache.Any(o => o.ID.Equals(args.IM.FromAgentID)))
                return;
            var fullName =
                new List<string>(wasOpenMetaverse.Helpers.GetAvatarNames(args.IM.FromAgentName));
            // Process dialog messages.
            switch (args.IM.Dialog)
            {
                // Send typing notification.
                case InstantMessageDialog.StartTyping:
                case InstantMessageDialog.StopTyping:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.Typing, new TypingEventArgs
                        {
                            Action = !args.IM.Dialog.Equals(
                                InstantMessageDialog.StartTyping)
                                ? Action.STOP
                                : Action.START,
                            AgentUUID = args.IM.FromAgentID,
                            FirstName = fullName.First(),
                            LastName = fullName.Last(),
                            Entity = Entity.MESSAGE
                        }),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.FriendshipOffered:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    // Accept friendships only from masters (for the time being)
                    if (
                        !corradeConfiguration.Masters.AsParallel().Any(
                            o =>
                                string.Equals(fullName.First(), o.FirstName, StringComparison.OrdinalIgnoreCase) &&
                                string.Equals(fullName.Last(), o.LastName, StringComparison.OrdinalIgnoreCase)))
                        return;
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ACCEPTED_FRIENDSHIP),
                        args.IM.FromAgentName);
                    Client.Friends.AcceptFriendship(args.IM.FromAgentID, args.IM.IMSessionID);
                    break;
                case InstantMessageDialog.InventoryAccepted:
                case InstantMessageDialog.InventoryDeclined:
                case InstantMessageDialog.TaskInventoryOffered:
                case InstantMessageDialog.InventoryOffered:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.Inventory, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.MessageBox:
                    // Not used.
                    return;
                case InstantMessageDialog.RequestTeleport:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    // Handle RLV: acccepttp
                    lock (RLVRulesLock)
                    {
                        if (
                            RLVRules.AsParallel()
                                .Any(o => o.Behaviour.Equals(Reflection.GetNameFromEnumValue(RLVBehaviour.ACCEPTTP))))
                        {
                            if (wasOpenMetaverse.Helpers.IsSecondLife(Client) && !TimedTeleportThrottle.IsSafe)
                            {
                                // or fail and append the fail message.
                                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TELEPORT_THROTTLED));
                                return;
                            }
                            lock (Locks.ClientInstanceSelfLock)
                            {
                                Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                            }
                            return;
                        }
                    }
                    // Store teleport lure.
                    lock (TeleportLureLock)
                    {
                        TeleportLures.Add(new TeleportLure
                        {
                            Agent = new Agent
                            {
                                FirstName = fullName.First(),
                                LastName = fullName.Last(),
                                UUID = args.IM.FromAgentID
                            },
                            Session = args.IM.IMSessionID
                        });
                    }
                    // Send teleport lure notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.TeleportLure, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    // If we got a teleport request from a master, then accept it (for the moment).
                    lock (Locks.ClientInstanceConfigurationLock)
                    {
                        if (
                            !corradeConfiguration.Masters.AsParallel()
                                .Any(
                                    o =>
                                        string.Equals(fullName.First(), o.FirstName, StringComparison.OrdinalIgnoreCase) &&
                                        string.Equals(fullName.Last(), o.LastName, StringComparison.OrdinalIgnoreCase)))
                            return;
                    }
                    if (wasOpenMetaverse.Helpers.IsSecondLife(Client) && !TimedTeleportThrottle.IsSafe)
                    {
                        // or fail and append the fail message.
                        Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.TELEPORT_THROTTLED));
                        return;
                    }
                    lock (Locks.ClientInstanceSelfLock)
                    {
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        Client.Self.SignaledAnimations.Copy()
                            .Keys.AsParallel()
                            .Where(o => !wasOpenMetaverse.Helpers.LindenAnimations.Contains(o))
                            .ForAll(o => { Client.Self.AnimationStop(o, true); });
                        Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                    }
                    return;
                // Group invitations received
                case InstantMessageDialog.GroupInvitation:
                    var inviteGroup = new Group();
                    if (
                        !Services.RequestGroup(Client, args.IM.FromAgentID, corradeConfiguration.ServicesTimeout,
                            ref inviteGroup))
                        return;
                    // Add the group to the cache.
                    Cache.AddGroup(inviteGroup.Name, inviteGroup.ID);
                    var inviteGroupAgent = UUID.Zero;
                    if (
                        !Resolvers.AgentNameToUUID(Client, fullName.First(), fullName.Last(),
                            corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout,
                            new Time.DecayingAlarm(corradeConfiguration.DataDecayType),
                            ref inviteGroupAgent))
                        return;
                    // Add the group invite - have to track them manually.
                    lock (GroupInviteLock)
                    {
                        GroupInvites.Add(new GroupInvite
                        {
                            Agent = new Agent
                            {
                                FirstName = fullName.First(),
                                LastName = fullName.Last(),
                                UUID = inviteGroupAgent
                            },
                            Group = inviteGroup.Name,
                            Session = args.IM.IMSessionID,
                            Fee = inviteGroup.MembershipFee
                        });
                    }
                    // Send group invitation notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.GroupInvite, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    // If a master sends it, then accept.
                    lock (Locks.ClientInstanceConfigurationLock)
                    {
                        if (
                            !corradeConfiguration.Masters.AsParallel()
                                .Any(
                                    o =>
                                        string.Equals(fullName.First(), o.FirstName, StringComparison.OrdinalIgnoreCase) &&
                                        string.Equals(fullName.Last(), o.LastName, StringComparison.OrdinalIgnoreCase)))
                            return;
                    }
                    Client.Self.GroupInviteRespond(inviteGroup.ID, args.IM.IMSessionID, true);
                    return;
                // Notice received.
                case InstantMessageDialog.GroupNotice:
                    var noticeGroup = new Group();
                    if (
                        !Services.RequestGroup(Client,
                            args.IM.BinaryBucket.Length >= 18 ? new UUID(args.IM.BinaryBucket, 2) : args.IM.FromAgentID,
                            corradeConfiguration.ServicesTimeout, ref noticeGroup))
                        return;
                    // Add the group to the cache.
                    Cache.AddGroup(noticeGroup.Name, noticeGroup.ID);
                    var noticeGroupAgent = UUID.Zero;
                    if (
                        !Resolvers.AgentNameToUUID(Client, fullName.First(), fullName.Last(),
                            corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout,
                            new Time.DecayingAlarm(corradeConfiguration.DataDecayType),
                            ref noticeGroupAgent))
                        return;
                    // message contains an attachment
                    bool noticeAttachment;
                    var noticeAssetType = AssetType.Unknown;
                    var noticeFolder = UUID.Zero;
                    switch (args.IM.BinaryBucket.Length > 18 && !args.IM.BinaryBucket[0].Equals(0))
                    {
                        case true:
                            noticeAssetType = (AssetType) args.IM.BinaryBucket[1];
                            noticeFolder = Client.Inventory.FindFolderForType(noticeAssetType);
                            noticeAttachment = true;
                            break;
                        default:
                            noticeAttachment = false;
                            break;
                    }
                    // get the subject and the message
                    var noticeSubject = string.Empty;
                    var noticeMessage = string.Empty;
                    var noticeData = args.IM.Message.Split('|');
                    if (noticeData.Length > 0 && !string.IsNullOrEmpty(noticeData[0]))
                    {
                        noticeSubject = noticeData[0];
                    }
                    if (noticeData.Length > 1 && !string.IsNullOrEmpty(noticeData[1]))
                    {
                        noticeMessage = noticeData[1];
                    }
                    lock (GroupNoticeLock)
                    {
                        GroupNotices.Add(new GroupNotice
                        {
                            Agent = new Agent
                            {
                                FirstName = fullName.First(),
                                LastName = fullName.Last(),
                                UUID = noticeGroupAgent
                            },
                            Asset = noticeAssetType,
                            Attachment = noticeAttachment,
                            Folder = noticeFolder,
                            Group = noticeGroup,
                            Message = noticeMessage,
                            Subject = noticeSubject,
                            Session = args.IM.IMSessionID
                        });
                    }
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Configuration.Notifications.GroupNotice, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.SessionSend:
                case InstantMessageDialog.MessageFromAgent:
                    // Check if this is a group message.
                    // Note that this is a lousy way of doing it but libomv does not properly set the GroupIM field
                    // such that the only way to determine if we have a group message is to check that the UUID
                    // of the session is actually the UUID of a current group. Furthermore, what's worse is that
                    // group mesages can appear both through SessionSend and from MessageFromAgent. Hence the problem.
                    var currentGroups = Enumerable.Empty<UUID>();
                    if (
                        !Services.GetCurrentGroups(Client, corradeConfiguration.ServicesTimeout,
                            ref currentGroups))
                        return;
                    var messageGroups = new HashSet<UUID>(currentGroups);

                    // Check if this is a group message.
                    switch (messageGroups.Contains(args.IM.IMSessionID))
                    {
                        case true:
                            var messageGroup =
                                corradeConfiguration.Groups.AsParallel()
                                    .FirstOrDefault(p => p.UUID.Equals(args.IM.IMSessionID));
                            if (!messageGroup.Equals(default(Configuration.Group)))
                            {
                                // Add the group to the cache.
                                Cache.AddGroup(messageGroup.Name, messageGroup.UUID);
                                // Add the agent to the cache.
                                Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                                // Send group notice notifications.
                                CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                    () =>
                                        SendNotification(Configuration.Notifications.GroupMessage,
                                            new GroupMessageEventArgs
                                            {
                                                AgentUUID = args.IM.FromAgentID,
                                                FirstName = fullName.First(),
                                                LastName = fullName.Last(),
                                                GroupName = messageGroup.Name,
                                                GroupUUID = messageGroup.UUID,
                                                Message = args.IM.Message
                                            }),
                                    corradeConfiguration.MaximumNotificationThreads);
                                // Log group messages
                                corradeConfiguration.Groups.AsParallel().Where(
                                    o =>
                                        messageGroup.UUID.Equals(o.UUID) &&
                                        o.ChatLogEnabled).ForAll(o =>
                                        {
                                            // Attempt to write to log file,
                                            CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                            {
                                                try
                                                {
                                                    lock (GroupLogFileLock)
                                                    {
                                                        using (
                                                            var fileStream = File.Open(o.ChatLog, FileMode.Append,
                                                                FileAccess.Write, FileShare.None))
                                                        {
                                                            using (
                                                                var logWriter = new StreamWriter(fileStream,
                                                                    Encoding.UTF8))
                                                            {
                                                                logWriter.WriteLine(
                                                                    CORRADE_CONSTANTS.GROUP_MESSAGE_LOG_MESSAGE_FORMAT,
                                                                    DateTime.Now.ToString(
                                                                        CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                                        Utils.EnUsCulture.DateTimeFormat),
                                                                    fullName.First(),
                                                                    fullName.Last(),
                                                                    args.IM.Message);
                                                            }
                                                        }
                                                    }
                                                }
                                                catch (Exception ex)
                                                {
                                                    // or fail and append the fail message.
                                                    Feedback(
                                                        Reflection.GetDescriptionFromEnumValue(
                                                            ConsoleError.COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE),
                                                        ex.Message);
                                                }
                                            }, corradeConfiguration.MaximumLogThreads,
                                                corradeConfiguration.ServicesTimeout);
                                        });
                            }
                            return;
                    }
                    // Check if this is a conference message.
                    switch (
                        (args.IM.Dialog == InstantMessageDialog.SessionSend &&
                         !messageGroups.Contains(args.IM.IMSessionID)) ||
                        (args.IM.Dialog == InstantMessageDialog.MessageFromAgent && args.IM.BinaryBucket.Length > 1))
                    {
                        case true:
                            // Join the chat if not yet joined
                            lock (Locks.ClientInstanceSelfLock)
                            {
                                if (!Client.Self.GroupChatSessions.ContainsKey(args.IM.IMSessionID))
                                    Client.Self.ChatterBoxAcceptInvite(args.IM.IMSessionID);
                            }
                            var conferenceName = Utils.BytesToString(args.IM.BinaryBucket);
                            // Add the conference to the list of conferences.
                            lock (ConferencesLock)
                            {
                                if (!Conferences.AsParallel()
                                    .Any(
                                        o =>
                                            o.Name.Equals(conferenceName, StringComparison.Ordinal) &&
                                            o.Session.Equals(args.IM.IMSessionID)))
                                {
                                    Conferences.Add(new Conference
                                    {
                                        Name = conferenceName,
                                        Session = args.IM.IMSessionID,
                                        Restored = false
                                    });
                                }
                            }
                            // Save the conference state.
                            SaveConferenceState.Invoke();
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            // Send conference message notification.
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Configuration.Notifications.Conference, args),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Log conference messages,
                            if (corradeConfiguration.ConferenceMessageLogEnabled)
                            {
                                CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                {
                                    try
                                    {
                                        lock (ConferenceMessageLogFileLock)
                                        {
                                            using (
                                                var fileStream =
                                                    File.Open(
                                                        Path.Combine(corradeConfiguration.ConferenceMessageLogDirectory,
                                                            conferenceName) +
                                                        "." + CORRADE_CONSTANTS.LOG_FILE_EXTENSION, FileMode.Append,
                                                        FileAccess.Write, FileShare.None))
                                            {
                                                using (
                                                    var logWriter = new StreamWriter(fileStream,
                                                        Encoding.UTF8))
                                                {
                                                    logWriter.WriteLine(
                                                        CORRADE_CONSTANTS.CONFERENCE_MESSAGE_LOG_MESSAGE_FORMAT,
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            Utils.EnUsCulture.DateTimeFormat),
                                                        fullName.First(),
                                                        fullName.Last(),
                                                        args.IM.Message);
                                                }
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            Reflection.GetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_CONFERENCE_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }, corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
                            }
                            return;
                    }
                    // Check if this is an instant message.
                    switch (!args.IM.ToAgentID.Equals(Client.Self.AgentID))
                    {
                        case false:
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            // Send instant message notification.
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Configuration.Notifications.InstantMessage, args),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Check if we were ejected.
                            var groupUUID = UUID.Zero;
                            if (
                                Resolvers.GroupNameToUUID(
                                    Client,
                                    CORRADE_CONSTANTS.EjectedFromGroupRegEx.Match(args.IM.Message).Groups[1].Value,
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    new Time.DecayingAlarm(corradeConfiguration.DataDecayType),
                                    ref groupUUID))
                            {
                                // Remove the group from the cache.
                                Cache.CurrentGroupsCache.Remove(groupUUID);
                            }

                            // Log instant messages,
                            if (corradeConfiguration.InstantMessageLogEnabled)
                            {
                                CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                {
                                    try
                                    {
                                        lock (InstantMessageLogFileLock)
                                        {
                                            using (
                                                var fileStream =
                                                    File.Open(
                                                        Path.Combine(corradeConfiguration.InstantMessageLogDirectory,
                                                            args.IM.FromAgentName) +
                                                        "." + CORRADE_CONSTANTS.LOG_FILE_EXTENSION, FileMode.Append,
                                                        FileAccess.Write, FileShare.None))
                                            {
                                                using (
                                                    var logWriter = new StreamWriter(fileStream,
                                                        Encoding.UTF8))
                                                {
                                                    logWriter.WriteLine(
                                                        CORRADE_CONSTANTS.INSTANT_MESSAGE_LOG_MESSAGE_FORMAT,
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            Utils.EnUsCulture.DateTimeFormat),
                                                        fullName.First(),
                                                        fullName.Last(),
                                                        args.IM.Message);
                                                }
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            Reflection.GetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }, corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
                            }
                            return;
                    }
                    // Check if this is a region message.
                    switch (!args.IM.IMSessionID.Equals(UUID.Zero))
                    {
                        case false:
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Configuration.Notifications.RegionMessage, args),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Log region messages,
                            if (corradeConfiguration.RegionMessageLogEnabled)
                            {
                                CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                {
                                    try
                                    {
                                        lock (RegionLogFileLock)
                                        {
                                            using (
                                                var fileStream =
                                                    File.Open(
                                                        Path.Combine(corradeConfiguration.RegionMessageLogDirectory,
                                                            Client.Network.CurrentSim.Name) + "." +
                                                        CORRADE_CONSTANTS.LOG_FILE_EXTENSION, FileMode.Append,
                                                        FileAccess.Write, FileShare.None))
                                            {
                                                using (
                                                    var logWriter = new StreamWriter(fileStream, Encoding.UTF8)
                                                    )
                                                {
                                                    logWriter.WriteLine(
                                                        CORRADE_CONSTANTS.REGION_MESSAGE_LOG_MESSAGE_FORMAT,
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            Utils.EnUsCulture.DateTimeFormat),
                                                        fullName.First(),
                                                        fullName.Last(),
                                                        args.IM.Message);
                                                }
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            Reflection.GetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }, corradeConfiguration.MaximumLogThreads, corradeConfiguration.ServicesTimeout);
                            }
                            return;
                    }
                    break;
            }

            // We are now in a region of code where the message is an IM sent by an object.
            // Check if this is not a Corrade command and send an object IM notification.
            if (!IsCorradeCommand(args.IM.Message))
            {
                CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                    () => SendNotification(Configuration.Notifications.ObjectInstantMessage, args),
                    corradeConfiguration.MaximumNotificationThreads);
                return;
            }

            // If the group was not set properly, then bail.
            var commandGroup = GetCorradeGroupFromMessage(args.IM.Message);
            switch (!commandGroup.Equals(default(Configuration.Group)))
            {
                case false:
                    return;
            }
            // Otherwise process the command.
            CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                () =>
                    HandleCorradeCommand(args.IM.Message, args.IM.FromAgentName, args.IM.FromAgentID.ToString(),
                        commandGroup),
                corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                corradeConfiguration.SchedulerExpiration);
        }

        /// <summary>
        ///     Processes a RLV behaviour.
        /// </summary>
        /// <param name="message">the RLV message to process</param>
        /// <param name="senderUUID">the UUID of the sender</param>
        private static void HandleRLVBehaviour(string message, UUID senderUUID)
        {
            if (string.IsNullOrEmpty(message)) return;

            // Split all commands.
            var unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            var first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            var match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            var RLVrule = new RLVRule
            {
                Behaviour = match.Groups["behaviour"].ToString().ToLowerInvariant(),
                Option = match.Groups["option"].ToString().ToLowerInvariant(),
                Param = match.Groups["param"].ToString().ToLowerInvariant(),
                ObjectUUID = senderUUID
            };

            switch (RLVrule.Param)
            {
                case RLV_CONSTANTS.Y:
                case RLV_CONSTANTS.ADD:
                    if (string.IsNullOrEmpty(RLVrule.Option))
                    {
                        lock (RLVRulesLock)
                        {
                            RLVRules.RemoveWhere(
                                o =>
                                    o.Behaviour.Equals(
                                        RLVrule.Behaviour,
                                        StringComparison.OrdinalIgnoreCase) &&
                                    o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        }
                        goto CONTINUE;
                    }
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.OrdinalIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID) &&
                                string.Equals(RLVrule.Option, o.Option, StringComparison.OrdinalIgnoreCase));
                    }
                    goto CONTINUE;
                case RLV_CONSTANTS.N:
                case RLV_CONSTANTS.REM:
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.OrdinalIgnoreCase) &&
                                string.Equals(RLVrule.Option, o.Option, StringComparison.OrdinalIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        RLVRules.Add(RLVrule);
                    }
                    goto CONTINUE;
            }

            try
            {
                // Find RLV behaviour.
                var RLVBehaviour = Reflection.GetEnumValueFromName<RLVBehaviour>(RLVrule.Behaviour);
                if (RLVBehaviour.Equals(default(RLVBehaviour)))
                {
                    throw new Exception(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR,
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.BEHAVIOUR_NOT_IMPLEMENTED),
                        RLVrule.Behaviour));
                }
                var execute =
                    Reflection.GetAttributeFromEnumValue<RLVBehaviourAttribute>(RLVBehaviour);

                // Execute the command.
                execute.RLVBehaviour.Invoke(message, RLVrule, senderUUID);
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.FAILED_TO_MANIFEST_RLV_BEHAVIOUR),
                    RLVrule.Behaviour,
                    ex.Message);
            }

            CONTINUE:
            HandleRLVBehaviour(message, senderUUID);
        }

        private static Dictionary<string, string> HandleCorradeCommand(string message, string sender, string identifier,
            Configuration.Group commandGroup)
        {
            // Get password.
            var password =
                wasInput(KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.PASSWORD)),
                    message));
            // Bail if no password set.
            if (string.IsNullOrEmpty(password)) return null;
            // Authenticate the request against the group password.
            if (!Authenticate(commandGroup.UUID, password))
            {
                Feedback(commandGroup.Name, Reflection.GetDescriptionFromEnumValue(ConsoleError.ACCESS_DENIED));
                return null;
            }
            // Censor password.
            message = KeyValue.Set(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.PASSWORD)),
                CORRADE_CONSTANTS.PASSWORD_CENSOR, message);
            /*
             * OpenSim sends the primitive UUID through args.IM.FromAgentID while Second Life properly sends
             * the agent UUID - which just shows how crap and non-compliant OpenSim really is. This tries to
             * resolve args.IM.FromAgentID to a name, which is what Second Life does, otherwise it just sets
             * the name to the name of the primitive sending the message.
             */
            if (wasOpenMetaverse.Helpers.IsSecondLife(Client))
            {
                UUID fromAgentID;
                if (UUID.TryParse(identifier, out fromAgentID))
                {
                    if (
                        !Resolvers.AgentUUIDToName(Client, fromAgentID, corradeConfiguration.ServicesTimeout,
                            ref sender))
                    {
                        Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.AGENT_NOT_FOUND),
                            fromAgentID.ToString());
                        return null;
                    }
                }
            }

            // Log the command.
            Feedback(string.Format(Utils.EnUsCulture, "{0} : {1} ({2}) : {3}", commandGroup.Name, sender, identifier,
                KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.COMMAND)), message)));

            // Initialize workers for the group if they are not set.
            lock (GroupWorkersLock)
            {
                if (!GroupWorkers.Contains(commandGroup.Name))
                {
                    GroupWorkers.Add(commandGroup.Name, 0u);
                }
            }

            var configuredGroup = corradeConfiguration.Groups.AsParallel().FirstOrDefault(
                o => commandGroup.UUID.Equals(o.UUID));
            if (configuredGroup.Equals(default(Configuration.Group)))
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UNKNOWN_GROUP),
                    commandGroup.Name);
                return null;
            }

            // Check if the workers have not been exceeded.
            uint currentWorkers;
            lock (GroupWorkersLock)
            {
                currentWorkers = (uint) GroupWorkers[commandGroup.Name];
            }

            // Refuse to proceed if the workers have been exceeded.
            if (currentWorkers > configuredGroup.Workers)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.WORKERS_EXCEEDED),
                    commandGroup.Name);
                return null;
            }

            // Increment the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[commandGroup.Name] = (uint) GroupWorkers[commandGroup.Name] + 1;
            }
            // Perform the command.
            var result = ProcessCommand(new CorradeCommandParameters
            {
                Message = message,
                Sender = sender,
                Identifier = identifier,
                Group = commandGroup
            });
            // Decrement the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[commandGroup.Name] = (uint) GroupWorkers[commandGroup.Name] - 1;
            }
            // do not send a callback if the callback queue is saturated
            if (CallbackQueue.Count >= corradeConfiguration.CallbackQueueLength)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CALLBACK_THROTTLED));
                return result;
            }
            // send callback if registered
            var url =
                wasInput(KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.CALLBACK)),
                    message));
            // if no url was provided, do not send the callback
            if (string.IsNullOrEmpty(url)) return result;
            CallbackQueue.Enqueue(new CallbackQueueElement
            {
                GroupUUID = commandGroup.UUID,
                URL = url,
                message = KeyValue.Escape(result, wasOutput)
            });
            return result;
        }

        /// <summary>
        ///     This function is responsible for processing commands.
        /// </summary>
        /// <param name="corradeCommandParameters">the command parameters</param>
        /// <returns>a dictionary of key-value pairs representing the results of the command</returns>
        private static Dictionary<string, string> ProcessCommand(CorradeCommandParameters corradeCommandParameters)
        {
            var result = new Dictionary<string, string>
            {
                // add the command group to the response.
                {Reflection.GetNameFromEnumValue(ScriptKeys.GROUP), corradeCommandParameters.Group.Name}
            };

            // retrieve the command from the message.
            var command =
                wasInput(KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.COMMAND)),
                    corradeCommandParameters.Message));
            if (!string.IsNullOrEmpty(command))
            {
                result.Add(Reflection.GetNameFromEnumValue(ScriptKeys.COMMAND), command);
            }

            // execute command, sift data and check for errors
            var success = false;
            try
            {
                // Find command.
                var scriptKey = Reflection.GetEnumValueFromName<ScriptKeys>(command);
                if (scriptKey.Equals(default(ScriptKeys)))
                {
                    throw new ScriptException(ScriptError.COMMAND_NOT_FOUND);
                }
                var execute =
                    Reflection.GetAttributeFromEnumValue<CorradeCommandAttribute>(scriptKey);

                // Execute the command.
                try
                {
                    execute.CorradeCommand.Invoke(corradeCommandParameters, result);
                    // Sifting was requested so apply the filters in order.
                    var sift = wasInput(KeyValue.Get(wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.SIFT)),
                        corradeCommandParameters.Message));
                    string data;
                    if (result.TryGetValue(Reflection.GetNameFromEnumValue(ResultKeys.DATA), out data) &&
                        !string.IsNullOrEmpty(sift))
                    {
                        foreach (var kvp in CSV.ToKeyValue(sift))
                        {
                            switch (Reflection.GetEnumValueFromName<Sift>(wasInput(kvp.Key).ToLowerInvariant()))
                            {
                                case Sift.TAKE:
                                    // Take a specified amount from the results if requested.
                                    int take;
                                    if (!string.IsNullOrEmpty(data) && int.TryParse(wasInput(kvp.Value), out take))
                                    {
                                        data = CSV.FromEnumerable(CSV.ToEnumerable(data).Take(take));
                                    }
                                    break;
                                case Sift.SKIP:
                                    // Skip a number of elements if requested.
                                    int skip;
                                    if (!string.IsNullOrEmpty(data) && int.TryParse(wasInput(kvp.Value), out skip))
                                    {
                                        data = CSV.FromEnumerable(CSV.ToEnumerable(data).Skip(skip));
                                    }
                                    break;
                                case Sift.EACH:
                                    // Return a stride in case it was requested.
                                    int each;
                                    if (!string.IsNullOrEmpty(data) && int.TryParse(wasInput(kvp.Value), out each))
                                    {
                                        data = CSV.FromEnumerable(CSV.ToEnumerable(data).Where((e, i) => i%each == 0));
                                    }
                                    break;
                                case Sift.MATCH:
                                    // Match the results if requested.
                                    var regex = wasInput(kvp.Value);
                                    if (!string.IsNullOrEmpty(data) && !string.IsNullOrEmpty(regex))
                                    {
                                        data =
                                            CSV.FromEnumerable(new Regex(regex, RegexOptions.Compiled).Matches(data)
                                                .AsParallel()
                                                .Cast<Match>()
                                                .Select(m => m.Groups).SelectMany(
                                                    matchGroups => Enumerable.Range(0, matchGroups.Count).Skip(1),
                                                    (matchGroups, i) => new {matchGroups, i})
                                                .SelectMany(
                                                    @t => Enumerable.Range(0, @t.matchGroups[@t.i].Captures.Count),
                                                    (@t, j) => @t.matchGroups[@t.i].Captures[j].Value));
                                    }
                                    break;
                                default:
                                    throw new ScriptException(ScriptError.UNKNOWN_SIFT);
                            }
                            switch (!string.IsNullOrEmpty(data))
                            {
                                case true:
                                    result[Reflection.GetNameFromEnumValue(ResultKeys.DATA)] = data;
                                    break;
                                default:
                                    result.Remove(Reflection.GetNameFromEnumValue(ResultKeys.DATA));
                                    break;
                            }
                        }
                    }

                    success = true;
                }
                catch (ScriptException sx)
                {
                    // we have a script error so return a status as well
                    result.Add(Reflection.GetNameFromEnumValue(ResultKeys.ERROR), sx.Message);
                    result.Add(Reflection.GetNameFromEnumValue(ResultKeys.STATUS),
                        sx.Status.ToString());
                }
            }
            catch (Exception ex)
            {
                // we have a generic exception so return the message
                result.Add(Reflection.GetNameFromEnumValue(ResultKeys.ERROR), ex.Message);
            }

            // add the final success status
            result.Add(Reflection.GetNameFromEnumValue(ResultKeys.SUCCESS),
                success.ToString(Utils.EnUsCulture));

            // add the time stamp
            result.Add(Reflection.GetNameFromEnumValue(ResultKeys.TIME),
                DateTime.Now.ToUniversalTime().ToString(Constants.LSL.DATE_TIME_STAMP));

            // build afterburn
            var AfterBurnLock = new object();
            // remove keys that are script keys, result keys or invalid key-value pairs
            var resultKeys = new HashSet<string>(Reflection.GetEnumNames<ResultKeys>());
            var scriptKeys = new HashSet<string>(Reflection.GetEnumNames<ScriptKeys>());
            KeyValue.Decode(corradeCommandParameters.Message)
                .AsParallel()
                .Where(
                    o =>
                        !string.IsNullOrEmpty(o.Key) && !resultKeys.Contains(wasInput(o.Key)) &&
                        !scriptKeys.Contains(wasInput(o.Key)) && !string.IsNullOrEmpty(o.Value))
                .ForAll(o =>
                {
                    lock (AfterBurnLock)
                    {
                        result.Add(o.Key, o.Value);
                    }
                });

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets the values from structures as strings.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="structure">the structure</param>
        /// <param name="query">a CSV list of fields or properties to get</param>
        /// <returns>value strings</returns>
        private static IEnumerable<string> GetStructuredData<T>(T structure, string query)
        {
            var result = new HashSet<string[]>();
            switch (!structure.Equals(default(T)))
            {
                case false:
                    return result.SelectMany(o => o);
            }
            var LockObject = new object();
            CSV.ToEnumerable(query).AsParallel().Where(o => !string.IsNullOrEmpty(o)).ForAll(name =>
            {
                var fi =
                    wasGetFields(structure, structure.GetType().Name).AsParallel()
                        .FirstOrDefault(o => string.Equals(name, o.Key.Name, StringComparison.Ordinal));

                var pi =
                    wasGetProperties(structure, structure.GetType().Name).AsParallel().FirstOrDefault(
                        o => string.Equals(name, o.Key.Name, StringComparison.Ordinal));

                var data = new List<string> {name};
                var info = wasGetInfo(fi.Key, fi.Value).Concat(wasGetInfo(pi.Key, pi.Value)).ToList();
                switch (info.Count.Equals(0))
                {
                    case true:
                        data.Add(string.Empty);
                        break;
                    default:
                        data.AddRange(info);
                        break;
                }
                lock (LockObject)
                {
                    result.Add(data.ToArray());
                }
            });
            return result.SelectMany(o => o);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Takes as input a CSV data values and sets the corresponding
        ///     structure's fields or properties from the CSV data.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="data">a CSV string</param>
        /// <param name="structure">the structure to set the fields and properties for</param>
        private static void wasCSVToStructure<T>(string data, ref T structure)
        {
            foreach (
                var match in CSV.ToKeyValue(data))
            {
                var localMatch = match;
                var fi =
                    wasGetFields(structure, structure.GetType().Name)
                        .ToArray()
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(fi.Key, fi.Value, match.Value, ref structure);

                var pi =
                    wasGetProperties(structure, structure.GetType().Name)
                        .ToArray()
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(pi.Key, pi.Value, match.Value, ref structure);
            }
        }

        private static void HandleTerseObjectUpdate(object sender, TerseObjectUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.TerseUpdates, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleRadarObjects(object sender, SimChangedEventArgs e)
        {
            lock (RadarObjectsLock)
            {
                if (RadarObjects.Any())
                {
                    RadarObjects.Clear();
                }
            }
        }

        private static void HandleSimChanged(object sender, SimChangedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.RegionCrossed, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMoneyBalance(object sender, BalanceEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Balance, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMoneyBalance(object sender, MoneyBalanceReplyEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Configuration.Notifications.Economy, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void UpdateDynamicConfiguration(Configuration configuration)
        {
            // Send message that we are updating the configuration.
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.UPDATING_CORRADE_CONFIGURATION));

            // Set the content type based on chosen output filers
            switch (corradeConfiguration.OutputFilters.LastOrDefault())
            {
                case Configuration.Filter.RFC1738:
                    CorradePOSTMediaType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                    break;
                default:
                    CorradePOSTMediaType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                    break;
            }

            // Set-up per-group HTTP clients.
            configuration.Groups.AsParallel().ForAll(o =>
            {
                // Create cookie containers for new groups.
                lock (GroupCookieContainersLock)
                {
                    if (!GroupCookieContainers.ContainsKey(o.UUID))
                    {
                        GroupCookieContainers.Add(o.UUID, new CookieContainer());
                    }
                }
                lock (GroupHTTPClientsLock)
                {
                    if (!GroupHTTPClients.ContainsKey(o.UUID))
                    {
                        GroupHTTPClients.Add(o.UUID, new Web.wasHTTPClient
                            (CORRADE_CONSTANTS.USER_AGENT, GroupCookieContainers[o.UUID], CorradePOSTMediaType,
                                corradeConfiguration.ServicesTimeout));
                    }
                }
            });

            // Remove HTTP clients from groups that are not configured.
            lock (GroupHTTPClientsLock)
            {
                new List<UUID>(
                    GroupHTTPClients.Keys.AsParallel().Where(o => !configuration.Groups.Any(p => p.UUID.Equals(o))))
                    .AsParallel().ForAll(
                        o => { GroupHTTPClients.Remove(o); });
            }

            // Enable the group scheduling thread if permissions were granted to groups.
            switch (configuration.Groups.AsParallel()
                .Any(
                    o =>
                        !(o.PermissionMask & (ulong) Configuration.Permissions.Schedule).Equals(0) &&
                        !o.Schedules.Equals(0)))
            {
                case true:
                    // Don't start if the expiration thread is already started.
                    if (GroupSchedulesThread != null) break;
                    // Start the group expiration thread.
                    runGroupSchedulesThread = true;
                    var groupSchedules = new HashSet<GroupSchedule>();
                    GroupSchedulesThread = new Thread(() =>
                    {
                        do
                        {
                            // Check schedules with a one second resolution.
                            Thread.Sleep((int) corradeConfiguration.SchedulesResolution);
                            lock (GroupSchedulesLock)
                            {
                                groupSchedules.Clear();
                                groupSchedules.UnionWith(GroupSchedules.AsParallel()
                                    .Where(
                                        o =>
                                            DateTime.Compare(DateTime.Now.ToUniversalTime(),
                                                o.At) >= 0));
                            }
                            if (groupSchedules.Any())
                            {
                                groupSchedules.AsParallel().ForAll(
                                    o =>
                                    {
                                        // Spawn the command.
                                        CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                                            () => HandleCorradeCommand(o.Message, o.Sender, o.Identifier, o.Group),
                                            corradeConfiguration.MaximumCommandThreads, o.Group.UUID,
                                            corradeConfiguration.SchedulerExpiration);
                                        lock (GroupSchedulesLock)
                                        {
                                            GroupSchedules.Remove(o);
                                        }
                                    });
                                SaveGroupSchedulesState.Invoke();
                            }
                        } while (runGroupSchedulesThread);
                    })
                    {IsBackground = true};
                    GroupSchedulesThread.Start();
                    break;
                default:
                    runGroupSchedulesThread = false;
                    try
                    {
                        if (GroupSchedulesThread != null)
                        {
                            if (
                                GroupSchedulesThread.ThreadState.Equals(ThreadState.Running) ||
                                GroupSchedulesThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                            {
                                if (!GroupSchedulesThread.Join(1000))
                                {
                                    GroupSchedulesThread.Abort();
                                    GroupSchedulesThread.Join();
                                }
                            }
                        }
                    }
                    catch (Exception)
                    {
                        /* We are going down and we do not care. */
                    }
                    finally
                    {
                        GroupSchedulesThread = null;
                    }
                    break;
            }

            // Enable SIML in case it was enabled in the configuration file.
            try
            {
                switch (configuration.EnableSIML)
                {
                    case true:
                        lock (SIMLBotLock)
                        {
                            SynBot.Learning += HandleSynBotLearning;
                            SynBot.Memorizing += HandleSynBotMemorizing;
                            LoadChatBotFiles.Invoke();
                        }
                        break;
                    default:
                        lock (SIMLBotLock)
                        {
                            SynBot.Learning -= HandleSynBotLearning;
                            SynBot.Memorizing -= HandleSynBotMemorizing;
                            if (!string.IsNullOrEmpty(SIMLBotConfigurationWatcher.Path))
                                SIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                Feedback(
                    Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_SIML_CONFIGURATION_WATCHER),
                    ex.Message);
            }

            // Dynamically disable or enable notifications.
            Reflection.GetEnumValues<Configuration.Notifications>().AsParallel().ForAll(o =>
            {
                var enabled = configuration.Groups.AsParallel().Any(
                    p =>
                        !(p.NotificationMask & (ulong) o).Equals(0));
                switch (o)
                {
                    case Configuration.Notifications.Sound:
                        switch (enabled)
                        {
                            case true:
                                Client.Sound.SoundTrigger += HandleSoundTrigger;
                                break;
                            default:
                                Client.Sound.SoundTrigger -= HandleSoundTrigger;
                                break;
                        }
                        break;
                    case Configuration.Notifications.AnimationsChanged:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.AnimationsChanged += HandleAnimationsChanged;
                                break;
                            default:
                                Client.Self.AnimationsChanged -= HandleAnimationsChanged;
                                break;
                        }
                        break;
                    case Configuration.Notifications.Feed:
                        switch (enabled)
                        {
                            case true:
                                // Start the group membership thread.
                                StartGroupFeedThread.Invoke();
                                break;
                            default:
                                // Stop the group sweep thread.
                                StopGroupFeedThread.Invoke();
                                break;
                        }
                        break;
                    case Configuration.Notifications.GroupMembership:
                        switch (enabled)
                        {
                            case true:
                                // Start the group membership thread.
                                StartGroupMembershipSweepThread.Invoke();
                                break;
                            default:
                                // Stop the group sweep thread.
                                StopGroupMembershipSweepThread.Invoke();
                                break;
                        }
                        break;
                    case Configuration.Notifications.Friendship:
                        switch (enabled)
                        {
                            case true:
                                Client.Friends.FriendshipOffered += HandleFriendshipOffered;
                                Client.Friends.FriendshipResponse += HandleFriendShipResponse;
                                Client.Friends.FriendOnline += HandleFriendOnlineStatus;
                                Client.Friends.FriendOffline += HandleFriendOnlineStatus;
                                Client.Friends.FriendRightsUpdate += HandleFriendRightsUpdate;
                                break;
                            default:
                                Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
                                Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
                                Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
                                Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
                                Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
                                break;
                        }
                        break;
                    case Configuration.Notifications.ScriptPermission:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.ScriptQuestion += HandleScriptQuestion;
                                break;
                            default:
                                Client.Self.ScriptQuestion -= HandleScriptQuestion;
                                break;
                        }
                        break;
                    case Configuration.Notifications.AlertMessage:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.AlertMessage += HandleAlertMessage;
                                break;
                            default:
                                Client.Self.AlertMessage -= HandleAlertMessage;
                                break;
                        }
                        break;
                    case Configuration.Notifications.Balance:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.MoneyBalance += HandleMoneyBalance;
                                break;
                            default:
                                Client.Self.MoneyBalance -= HandleMoneyBalance;
                                break;
                        }
                        break;
                    case Configuration.Notifications.Economy:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.MoneyBalanceReply += HandleMoneyBalance;
                                break;
                            default:
                                Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
                                break;
                        }
                        break;
                    case Configuration.Notifications.ScriptDialog:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.ScriptDialog += HandleScriptDialog;
                                break;
                            default:
                                Client.Self.ScriptDialog -= HandleScriptDialog;
                                break;
                        }
                        break;
                    case Configuration.Notifications.SitChanged:
                        switch (enabled)
                        {
                            case true:
                                Client.Objects.AvatarSitChanged += HandleAvatarSitChanged;
                                break;
                            default:
                                Client.Objects.AvatarSitChanged -= HandleAvatarSitChanged;
                                break;
                        }
                        break;
                    case Configuration.Notifications.TerseUpdates:
                        switch (enabled)
                        {
                            case true:
                                Client.Objects.TerseObjectUpdate += HandleTerseObjectUpdate;
                                break;
                            default:
                                Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
                                break;
                        }
                        break;
                    case Configuration.Notifications.ViewerEffect:
                        switch (enabled)
                        {
                            case true:
                                Client.Avatars.ViewerEffect += HandleViewerEffect;
                                Client.Avatars.ViewerEffectPointAt += HandleViewerEffect;
                                Client.Avatars.ViewerEffectLookAt += HandleViewerEffect;
                                break;
                            default:
                                Client.Avatars.ViewerEffect -= HandleViewerEffect;
                                Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
                                Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
                                break;
                        }
                        break;
                    case Configuration.Notifications.MeanCollision:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.MeanCollision += HandleMeanCollision;
                                break;
                            default:
                                Client.Self.MeanCollision -= HandleMeanCollision;
                                break;
                        }
                        break;
                    case Configuration.Notifications.RegionCrossed:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.RegionCrossed += HandleRegionCrossed;
                                Client.Network.SimChanged += HandleSimChanged;
                                break;
                            default:
                                Client.Self.RegionCrossed -= HandleRegionCrossed;
                                Client.Network.SimChanged -= HandleSimChanged;
                                break;
                        }
                        break;
                    case Configuration.Notifications.LoadURL:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.LoadURL += HandleLoadURL;
                                break;
                            default:
                                Client.Self.LoadURL -= HandleLoadURL;
                                break;
                        }
                        break;
                    case Configuration.Notifications.ScriptControl:
                        switch (enabled)
                        {
                            case true:
                                Client.Self.ScriptControlChange += HandleScriptControlChange;
                                break;
                            default:
                                Client.Self.ScriptControlChange -= HandleScriptControlChange;
                                break;
                        }
                        break;
                }
            });

            // Depending on whether groups have bound to the viewer effects notification,
            // start or stop the viwer effect expiration thread.
            switch (
                configuration.Groups.AsParallel()
                    .Any(o => !(o.NotificationMask & (ulong) Configuration.Notifications.ViewerEffect).Equals(0)))
            {
                case true:
                    // Don't start if the expiration thread is already started.
                    if (EffectsExpirationThread != null) break;
                    EffectsExpirationThread = new Thread(() =>
                    {
                        do
                        {
                            Thread.Sleep(1000);
                            lock (SphereEffectsLock)
                            {
                                SphereEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                            }
                            lock (BeamEffectsLock)
                            {
                                BeamEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                            }
                        } while (runEffectsExpirationThread);
                    })
                    {IsBackground = true};
                    // Start sphere and beam effect expiration thread
                    runEffectsExpirationThread = true;
                    EffectsExpirationThread.Start();
                    break;
                default:
                    // Stop the effects expiration thread.
                    runEffectsExpirationThread = false;
                    if (EffectsExpirationThread != null)
                    {
                        try
                        {
                            if (
                                EffectsExpirationThread.ThreadState.Equals(ThreadState.Running) ||
                                EffectsExpirationThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                            {
                                if (!EffectsExpirationThread.Join(1000))
                                {
                                    EffectsExpirationThread.Abort();
                                    EffectsExpirationThread.Join();
                                }
                            }
                        }
                        catch (Exception)
                        {
                            /* We are going down and we do not care. */
                        }
                        finally
                        {
                            EffectsExpirationThread = null;
                        }
                    }
                    break;
            }

            // Depending on whether any group has bound either the avatar radar notification,
            // or the primitive radar notification, install or uinstall the listeners.
            switch (
                configuration.Groups.AsParallel().Any(
                    o =>
                        !(o.NotificationMask & (ulong) Configuration.Notifications.RadarAvatars).Equals(0) ||
                        !(o.NotificationMask & (ulong) Configuration.Notifications.RadarPrimitives).Equals(0)))
            {
                case true:
                    Client.Network.SimChanged += HandleRadarObjects;
                    Client.Objects.AvatarUpdate += HandleAvatarUpdate;
                    Client.Objects.ObjectUpdate += HandleObjectUpdate;
                    Client.Objects.KillObject += HandleKillObject;
                    break;
                default:
                    Client.Network.SimChanged -= HandleRadarObjects;
                    Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
                    Client.Objects.ObjectUpdate -= HandleObjectUpdate;
                    Client.Objects.KillObject -= HandleKillObject;
                    break;
            }

            // Enable the TCP notifications server in case it was enabled in the Configuration.
            switch (configuration.EnableTCPNotificationsServer)
            {
                case true:
                    // Don't start if the TCP notifications server is already started.
                    if (TCPNotificationsThread != null) break;
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.STARTING_TCP_NOTIFICATIONS_SERVER));
                    runTCPNotificationsServer = true;
                    // Start the TCP notifications server.
                    TCPNotificationsThread = new Thread(() =>
                    {
                        TCPListener =
                            new TcpListener(
                                new IPEndPoint(IPAddress.Parse(configuration.TCPNotificationsServerAddress),
                                    (int) configuration.TCPNotificationsServerPort));
                        TCPListener.Start();

                        do
                        {
                            var TCPClient = TCPListener.AcceptTcpClient();

                            new Thread(() =>
                            {
                                IPEndPoint remoteEndPoint = null;
                                var commandGroup = new Configuration.Group();
                                try
                                {
                                    remoteEndPoint = TCPClient.Client.RemoteEndPoint as IPEndPoint;
                                    using (var networkStream = TCPClient.GetStream())
                                    {
                                        using (
                                            var streamReader = new StreamReader(networkStream,
                                                Encoding.UTF8))
                                        {
                                            var receiveLine = streamReader.ReadLine();

                                            using (
                                                var streamWriter = new StreamWriter(networkStream,
                                                    Encoding.UTF8))
                                            {
                                                commandGroup = GetCorradeGroupFromMessage(receiveLine);
                                                switch (!commandGroup.Equals(default(Configuration.Group)) &&
                                                        Authenticate(commandGroup.UUID,
                                                            wasInput(
                                                                KeyValue.Get(
                                                                    wasOutput(
                                                                        Reflection.GetNameFromEnumValue(
                                                                            ScriptKeys.PASSWORD)),
                                                                    receiveLine))))
                                                {
                                                    case false:
                                                        streamWriter.WriteLine(
                                                            KeyValue.Encode(new Dictionary
                                                                <string, string>
                                                            {
                                                                {
                                                                    Reflection.GetNameFromEnumValue(
                                                                        ScriptKeys.SUCCESS),
                                                                    false.ToString()
                                                                }
                                                            }));
                                                        streamWriter.Flush();
                                                        TCPClient.Close();
                                                        return;
                                                }

                                                var notificationTypes =
                                                    wasInput(
                                                        KeyValue.Get(
                                                            wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.TYPE)),
                                                            receiveLine));
                                                Notification notification;
                                                lock (GroupNotificationsLock)
                                                {
                                                    notification =
                                                        GroupNotifications.AsParallel().FirstOrDefault(
                                                            o =>
                                                                o.GroupUUID.Equals(commandGroup.UUID));
                                                }
                                                // Build any requested data for raw notifications.
                                                var fields =
                                                    wasInput(
                                                        KeyValue.Get(
                                                            wasOutput(Reflection.GetNameFromEnumValue(ScriptKeys.DATA)),
                                                            receiveLine));
                                                var data = new HashSet<string>();
                                                var LockObject = new object();
                                                if (!string.IsNullOrEmpty(fields))
                                                {
                                                    CSV.ToEnumerable(fields)
                                                        .ToArray()
                                                        .AsParallel()
                                                        .Where(o => !string.IsNullOrEmpty(o)).ForAll(o =>
                                                        {
                                                            lock (LockObject)
                                                            {
                                                                data.Add(o);
                                                            }
                                                        });
                                                }
                                                switch (notification != null)
                                                {
                                                    case false:
                                                        notification = new Notification
                                                        {
                                                            GroupName = commandGroup.Name,
                                                            GroupUUID = commandGroup.UUID,
                                                            NotificationURLDestination =
                                                                new Collections.SerializableDictionary
                                                                    <Configuration.Notifications, HashSet<string>>(),
                                                            NotificationTCPDestination =
                                                                new Dictionary
                                                                    <Configuration.Notifications, HashSet<IPEndPoint>>(),
                                                            Data = data
                                                        };
                                                        break;
                                                    case true:
                                                        if (notification.NotificationTCPDestination == null)
                                                        {
                                                            notification.NotificationTCPDestination =
                                                                new Dictionary
                                                                    <Configuration.Notifications, HashSet<IPEndPoint>>();
                                                        }
                                                        if (notification.NotificationURLDestination == null)
                                                        {
                                                            notification.NotificationURLDestination =
                                                                new Collections.SerializableDictionary
                                                                    <Configuration.Notifications, HashSet<string>>();
                                                        }
                                                        break;
                                                }

                                                var succeeded = true;
                                                Parallel.ForEach(CSV.ToEnumerable(
                                                    notificationTypes)
                                                    .ToArray()
                                                    .AsParallel()
                                                    .Where(o => !string.IsNullOrEmpty(o)),
                                                    (o, state) =>
                                                    {
                                                        var notificationValue =
                                                            (ulong)
                                                                Reflection
                                                                    .GetEnumValueFromName
                                                                    <Configuration.Notifications>(o);
                                                        if (
                                                            !GroupHasNotification(commandGroup.UUID,
                                                                notificationValue))
                                                        {
                                                            // one of the notification was not allowed, so abort
                                                            succeeded = false;
                                                            state.Break();
                                                        }
                                                        switch (
                                                            !notification.NotificationTCPDestination.ContainsKey(
                                                                (Configuration.Notifications) notificationValue))
                                                        {
                                                            case true:
                                                                lock (LockObject)
                                                                {
                                                                    notification.NotificationTCPDestination.Add(
                                                                        (Configuration.Notifications) notificationValue,
                                                                        new HashSet<IPEndPoint> {remoteEndPoint});
                                                                }
                                                                break;
                                                            default:
                                                                lock (LockObject)
                                                                {
                                                                    notification.NotificationTCPDestination[
                                                                        (Configuration.Notifications) notificationValue]
                                                                        .Add(
                                                                            remoteEndPoint);
                                                                }
                                                                break;
                                                        }
                                                    });

                                                switch (succeeded)
                                                {
                                                    case true:
                                                        lock (GroupNotificationsLock)
                                                        {
                                                            // Replace notification.
                                                            GroupNotifications.RemoveWhere(
                                                                o =>
                                                                    o.GroupUUID.Equals(commandGroup.UUID));
                                                            GroupNotifications.Add(notification);
                                                        }
                                                        // Save the notifications state.
                                                        SaveNotificationState.Invoke();
                                                        streamWriter.WriteLine(
                                                            KeyValue.Encode(new Dictionary
                                                                <string, string>
                                                            {
                                                                {
                                                                    Reflection.GetNameFromEnumValue(
                                                                        ScriptKeys.SUCCESS),
                                                                    true.ToString()
                                                                }
                                                            }));
                                                        streamWriter.Flush();
                                                        break;
                                                    default:
                                                        streamWriter.WriteLine(
                                                            KeyValue.Encode(new Dictionary
                                                                <string, string>
                                                            {
                                                                {
                                                                    Reflection.GetNameFromEnumValue(
                                                                        ScriptKeys.SUCCESS),
                                                                    false.ToString()
                                                                }
                                                            }));
                                                        streamWriter.Flush();
                                                        TCPClient.Close();
                                                        return;
                                                }
                                                do
                                                {
                                                    var notificationTCPQueueElement =
                                                        new NotificationTCPQueueElement();
                                                    if (!NotificationTCPQueue.Dequeue(
                                                        (int) configuration.TCPNotificationThrottle,
                                                        ref notificationTCPQueueElement)) continue;
                                                    if (notificationTCPQueueElement.Equals(
                                                        default(NotificationTCPQueueElement)) ||
                                                        !notificationTCPQueueElement.IPEndPoint.Equals(
                                                            remoteEndPoint)) continue;
                                                    streamWriter.WriteLine(
                                                        KeyValue.Encode(
                                                            notificationTCPQueueElement.message));
                                                    streamWriter.Flush();
                                                } while (runTCPNotificationsServer && TCPClient.Connected);
                                            }
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Feedback(
                                        Reflection.GetDescriptionFromEnumValue(
                                            ConsoleError.TCP_NOTIFICATIONS_SERVER_ERROR),
                                        ex.Message);
                                }
                                finally
                                {
                                    if (remoteEndPoint != null && !commandGroup.Equals(default(Configuration.Group)))
                                    {
                                        lock (GroupNotificationsLock)
                                        {
                                            var notification =
                                                GroupNotifications.AsParallel().FirstOrDefault(
                                                    o =>
                                                        o.GroupUUID.Equals(commandGroup.UUID));
                                            if (notification != null)
                                            {
                                                var
                                                    notificationTCPDestination =
                                                        new Dictionary<Configuration.Notifications, HashSet<IPEndPoint>>
                                                            ();
                                                notification.NotificationTCPDestination.AsParallel().ForAll(o =>
                                                {
                                                    switch (o.Value.Contains(remoteEndPoint))
                                                    {
                                                        case true:
                                                            var destinations =
                                                                new HashSet<IPEndPoint>(
                                                                    o.Value.Where(p => !p.Equals(remoteEndPoint)));
                                                            notificationTCPDestination.Add(o.Key, destinations);
                                                            break;
                                                        default:
                                                            notificationTCPDestination.Add(o.Key, o.Value);
                                                            break;
                                                    }
                                                });

                                                GroupNotifications.Remove(notification);
                                                GroupNotifications.Add(new Notification
                                                {
                                                    GroupName = notification.GroupName,
                                                    GroupUUID = notification.GroupUUID,
                                                    NotificationURLDestination =
                                                        notification.NotificationURLDestination,
                                                    NotificationTCPDestination = notificationTCPDestination,
                                                    Afterburn = notification.Afterburn,
                                                    Data = notification.Data
                                                });
                                            }
                                        }
                                    }
                                }
                            })
                            {IsBackground = true}.Start();
                        } while (runTCPNotificationsServer);
                    })
                    {IsBackground = true};
                    TCPNotificationsThread.Start();
                    break;
                default:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.STOPPING_TCP_NOTIFICATIONS_SERVER));
                    runTCPNotificationsServer = false;
                    try
                    {
                        if (TCPNotificationsThread != null)
                        {
                            TCPListener.Stop();
                            if (
                                TCPNotificationsThread.ThreadState.Equals(ThreadState.Running) ||
                                TCPNotificationsThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                            {
                                if (!TCPNotificationsThread.Join(1000))
                                {
                                    TCPNotificationsThread.Abort();
                                    TCPNotificationsThread.Join();
                                }
                            }
                        }
                    }
                    catch (Exception)
                    {
                        /* We are going down and we do not care. */
                    }
                    finally
                    {
                        TCPNotificationsThread = null;
                    }
                    break;
            }

            // Enable the HTTP server in case it is supported and it was enabled in the Configuration.
            switch (HttpListener.IsSupported)
            {
                case true:
                    switch (configuration.EnableHTTPServer)
                    {
                        case true:
                            // Don't start if the HTTP server is already started.
                            if (HTTPListenerThread != null) break;
                            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.STARTING_HTTP_SERVER));
                            runHTTPServer = true;
                            HTTPListenerThread = new Thread(() =>
                            {
                                try
                                {
                                    using (HTTPListener = new HttpListener())
                                    {
                                        HTTPListener.Prefixes.Add(configuration.HTTPServerPrefix);
                                        // TimeoutManager is not supported on mono (what is mono good for anyway, practically speaking?).
                                        switch (Environment.OSVersion.Platform)
                                        {
                                            case PlatformID.Win32NT:
                                                // We have to set this through reflection to prevent mono from bombing.
                                                var pi =
                                                    HTTPListener.GetType()
                                                        .GetProperty("TimeoutManager",
                                                            BindingFlags.Public | BindingFlags.Instance);
                                                var timeoutManager = pi?.GetValue(HTTPListener, null);
                                                // Check if we have TimeoutManager.
                                                if (timeoutManager == null) break;
                                                // Now, set the properties through reflection.
                                                pi = timeoutManager.GetType().GetProperty("DrainEntityBody");
                                                pi?.SetValue(timeoutManager,
                                                    TimeSpan.FromMilliseconds(configuration.HTTPServerDrainTimeout),
                                                    null);
                                                pi = timeoutManager.GetType().GetProperty("EntityBody");
                                                pi?.SetValue(timeoutManager,
                                                    TimeSpan.FromMilliseconds(configuration.HTTPServerBodyTimeout),
                                                    null);
                                                pi = timeoutManager.GetType().GetProperty("HeaderWait");
                                                pi?.SetValue(timeoutManager,
                                                    TimeSpan.FromMilliseconds(configuration.HTTPServerHeaderTimeout),
                                                    null);
                                                pi = timeoutManager.GetType().GetProperty("IdleConnection");
                                                pi?.SetValue(timeoutManager,
                                                    TimeSpan.FromMilliseconds(configuration.HTTPServerIdleTimeout),
                                                    null);
                                                pi = timeoutManager.GetType().GetProperty("RequestQueue");
                                                pi?.SetValue(timeoutManager,
                                                    TimeSpan.FromMilliseconds(configuration.HTTPServerQueueTimeout),
                                                    null);
                                                break;
                                        }
                                        HTTPListener.Start();
                                        while (runHTTPServer && HTTPListener.IsListening)
                                        {
                                            var result = HTTPListener.BeginGetContext(ProcessHTTPRequest,
                                                HTTPListener);
                                            WaitHandle.WaitAny(new[] {result.AsyncWaitHandle});
                                        }
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR),
                                        ex.Message);
                                }
                            })
                            {IsBackground = true};
                            HTTPListenerThread.Start();
                            break;
                        default:
                            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.STOPPING_HTTP_SERVER));
                            runHTTPServer = false;
                            try
                            {
                                if (HTTPListenerThread != null)
                                {
                                    HTTPListener.Stop();
                                    if (
                                        HTTPListenerThread.ThreadState.Equals(ThreadState.Running) ||
                                        HTTPListenerThread.ThreadState.Equals(ThreadState.WaitSleepJoin))
                                    {
                                        if (!HTTPListenerThread.Join(1000))
                                        {
                                            HTTPListenerThread.Abort();
                                            HTTPListenerThread.Join();
                                        }
                                    }
                                }
                            }
                            catch (Exception)
                            {
                                /* We are going down and we do not care. */
                            }
                            finally
                            {
                                HTTPListenerThread = null;
                            }
                            break;
                    }
                    break;
                default:
                    Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR),
                        Reflection.GetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_NOT_SUPPORTED));
                    break;
            }

            // Apply settings to the instance.
            Client.Self.Movement.Camera.Far = corradeConfiguration.Range;
            Client.Settings.LOGIN_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.LOGOUT_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.SIMULATOR_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.CAPS_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.MAP_REQUEST_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.TRANSFER_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Client.Settings.TELEPORT_TIMEOUT = (int) corradeConfiguration.ServicesTimeout;
            Settings.MAX_HTTP_CONNECTIONS = (int) corradeConfiguration.ConnectionLimit;

            // Network Settings
            ServicePointManager.DefaultConnectionLimit = (int) corradeConfiguration.ConnectionLimit;
            ServicePointManager.UseNagleAlgorithm = corradeConfiguration.UseNaggle;
            ServicePointManager.Expect100Continue = corradeConfiguration.UseExpect100Continue;
            ServicePointManager.MaxServicePointIdleTime = (int) corradeConfiguration.ConnectionIdleTime;

            // Throttles.
            Client.Throttle.Total = corradeConfiguration.ThrottleTotal;
            Client.Throttle.Land = corradeConfiguration.ThrottleLand;
            Client.Throttle.Task = corradeConfiguration.ThrottleTask;
            Client.Throttle.Texture = corradeConfiguration.ThrottleTexture;
            Client.Throttle.Wind = corradeConfiguration.ThrottleWind;
            Client.Throttle.Resend = corradeConfiguration.ThrottleResend;
            Client.Throttle.Asset = corradeConfiguration.ThrottleAsset;
            Client.Throttle.Cloud = corradeConfiguration.ThrottleCloud;

            // Client Identification Tag.
            Client.Settings.CLIENT_IDENTIFICATION_TAG = corradeConfiguration.ClientIdentificationTag;

            // Send message that the configuration has been updated.
            Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.CORRADE_CONFIGURATION_UPDATED));
        }

        private static void HandleSynBotLearning(object sender, LearningEventArgs e)
        {
            try
            {
                e.Document.Save(Path.Combine(
                    Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                    SIML_BOT_CONSTANTS.EVOLVE_DIRECTORY,
                    SIML_BOT_CONSTANTS.LEARNED_FILE));
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SAVING_SIML_BOT_LEARNING_FILE),
                    ex.Message);
            }
        }

        private static void HandleSynBotMemorizing(object sender, MemorizingEventArgs e)
        {
            try
            {
                e.Document.Save(Path.Combine(
                    Directory.GetCurrentDirectory(), SIML_BOT_CONSTANTS.ROOT_DIRECTORY,
                    SIML_BOT_CONSTANTS.EVOLVE_DIRECTORY,
                    SIML_BOT_CONSTANTS.MEMORIZED_FILE));
            }
            catch (Exception ex)
            {
                Feedback(Reflection.GetDescriptionFromEnumValue(ConsoleError.ERROR_SAVING_SIML_BOT_MEMORIZING_FILE),
                    ex.Message);
            }
        }

        /// <summary>
        ///     Constants for Corrade's integrated chat bot.
        /// </summary>
        private struct SIML_BOT_CONSTANTS
        {
            public const string ROOT_DIRECTORY = @"SIML";
            public const string SIML_DIRECTORY = @"Corrade";
            public const string SIML_SETTINGS_DIRECTORY = @"Settings";
            public const string PACKAGE_FILE = @"Corrade.simlpk";
            public const string EVOLVE_DIRECTORY = @"Evolve";
            public const string LEARNED_FILE = @"Learned.siml";
            public const string MEMORIZED_FILE = @"Memorized.siml";
        }

        /// <summary>
        ///     Possible actions.
        /// </summary>
        private enum Action : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("get")] GET,
            [Reflection.NameAttribute("set")] SET,
            [Reflection.NameAttribute("add")] ADD,
            [Reflection.NameAttribute("remove")] REMOVE,
            [Reflection.NameAttribute("start")] START,
            [Reflection.NameAttribute("stop")] STOP,
            [Reflection.NameAttribute("mute")] MUTE,
            [Reflection.NameAttribute("unmute")] UNMUTE,
            [Reflection.NameAttribute("restart")] RESTART,
            [Reflection.NameAttribute("cancel")] CANCEL,
            [Reflection.NameAttribute("accept")] ACCEPT,
            [Reflection.NameAttribute("decline")] DECLINE,
            [Reflection.NameAttribute("online")] ONLINE,
            [Reflection.NameAttribute("offline")] OFFLINE,
            [Reflection.NameAttribute("request")] REQUEST,
            [Reflection.NameAttribute("response")] RESPONSE,
            [Reflection.NameAttribute("delete")] DELETE,
            [Reflection.NameAttribute("take")] TAKE,
            [Reflection.NameAttribute("read")] READ,
            [Reflection.NameAttribute("wrtie")] WRITE,
            [Reflection.NameAttribute("purge")] PURGE,
            [Reflection.NameAttribute("crossed")] CROSSED,
            [Reflection.NameAttribute("changed")] CHANGED,
            [Reflection.NameAttribute("reply")] REPLY,
            [Reflection.NameAttribute("offer")] OFFER,
            [Reflection.NameAttribute("generic")] GENERIC,
            [Reflection.NameAttribute("point")] POINT,
            [Reflection.NameAttribute("look")] LOOK,
            [Reflection.NameAttribute("update")] UPDATE,
            [Reflection.NameAttribute("received")] RECEIVED,
            [Reflection.NameAttribute("joined")] JOINED,
            [Reflection.NameAttribute("parted")] PARTED,
            [Reflection.NameAttribute("save")] SAVE,
            [Reflection.NameAttribute("load")] LOAD,
            [Reflection.NameAttribute("enable")] ENABLE,
            [Reflection.NameAttribute("disable")] DISABLE,
            [Reflection.NameAttribute("process")] PROCESS,
            [Reflection.NameAttribute("rebuild")] REBUILD,
            [Reflection.NameAttribute("clear")] CLEAR,
            [Reflection.NameAttribute("ls")] LS,
            [Reflection.NameAttribute("cwd")] CWD,
            [Reflection.NameAttribute("cd")] CD,
            [Reflection.NameAttribute("mkdir")] MKDIR,
            [Reflection.NameAttribute("chmod")] CHMOD,
            [Reflection.NameAttribute("rm")] RM,
            [Reflection.NameAttribute("ln")] LN,
            [Reflection.NameAttribute("mv")] MV,
            [Reflection.NameAttribute("cp")] CP,
            [Reflection.NameAttribute("appear")] APPEAR,
            [Reflection.NameAttribute("vanish")] VANISH,
            [Reflection.NameAttribute("list")] LIST,
            [Reflection.NameAttribute("link")] LINK,
            [Reflection.NameAttribute("delink")] DELINK,
            [Reflection.NameAttribute("ban")] BAN,
            [Reflection.NameAttribute("unban")] UNBAN,
            [Reflection.NameAttribute("send")] SEND,
            [Reflection.NameAttribute("search")] SEARCH,
            [Reflection.NameAttribute("attach")] ATTACH,
            [Reflection.NameAttribute("detach")] DETACH,
            [Reflection.NameAttribute("wear")] WEAR,
            [Reflection.NameAttribute("unwear")] UNWEAR,
            [Reflection.NameAttribute("post")] POST,
            [Reflection.NameAttribute("tweet")] TWEET,
            [Reflection.NameAttribute("detect")] DETECT,
            [Reflection.NameAttribute("ignore")] IGNORE,
            [Reflection.NameAttribute("revoke")] REVOKE,
            [Reflection.NameAttribute("reject")] REJECT,
            [Reflection.NameAttribute("propose")] PROPOSE,
            [Reflection.NameAttribute("append")] APPEND,
            [Reflection.NameAttribute("create")] CREATE,
            [Reflection.NameAttribute("detail")] DETAIL
        }

        /// <summary>
        ///     Possible sifting actions for post-processing data.
        /// </summary>
        private enum Sift : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("take")] TAKE,
            [Reflection.NameAttribute("each")] EACH,
            [Reflection.NameAttribute("match")] MATCH,
            [Reflection.NameAttribute("skip")] SKIP
        }

        /// <summary>
        ///     Agent structure.
        /// </summary>
        private struct Agent
        {
            [Reflection.NameAttribute("firstname")] public string FirstName;
            [Reflection.NameAttribute("lastname")] public string LastName;
            [Reflection.NameAttribute("uuid")] public UUID UUID;
        }

        /// <summary>
        ///     A structure to track Beam effects.
        /// </summary>
        private struct BeamEffect
        {
            [Reflection.NameAttribute("alpha")] public float Alpha;
            [Reflection.NameAttribute("color")] public Vector3 Color;
            [Reflection.NameAttribute("duration")] public float Duration;
            [Reflection.NameAttribute("effect")] public UUID Effect;
            [Reflection.NameAttribute("offset")] public Vector3d Offset;
            [Reflection.NameAttribute("source")] public UUID Source;
            [Reflection.NameAttribute("target")] public UUID Target;
            [Reflection.NameAttribute("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     Constants used by Corrade.
        /// </summary>
        private struct CORRADE_CONSTANTS
        {
            /// <summary>
            ///     Copyright.
            /// </summary>
            public const string COPYRIGHT = @"(c) Copyright 2013 Wizardry and Steamworks";

            public const string WIZARDRY_AND_STEAMWORKS = @"Wizardry and Steamworks";
            public const string CORRADE = @"Corrade";
            public const string WIZARDRY_AND_STEAMWORKS_WEBSITE = @"http://grimore.org";

            /// <summary>
            ///     Censor characters for passwords.
            /// </summary>
            public const string PASSWORD_CENSOR = "***";

            /// <summary>
            ///     Corrade channel sent to the simulator.
            /// </summary>
            public const string CLIENT_CHANNEL = @"[Wizardry and Steamworks]:Corrade";

            public const uint TWITTER_MAXIMUM_TWEET_LENGTH = 140;
            public const string CURRENT_OUTFIT_FOLDER_NAME = @"Current Outfit";
            public const string DEFAULT_SERVICE_NAME = @"Corrade";
            public const string LOG_FACILITY = @"Application";
            public const string WEB_REQUEST = @"Web Request";
            public const string CONFIGURATION_FILE = @"Corrade.ini";
            public const string DATE_TIME_STAMP = @"dd-MM-yyyy HH:mm:ss";
            public const string INVENTORY_CACHE_FILE = @"Inventory.cache";
            public const string AGENT_CACHE_FILE = @"Agent.cache";
            public const string GROUP_CACHE_FILE = @"Group.cache";
            public const string PATH_SEPARATOR = @"/";
            public const string ERROR_SEPARATOR = @" : ";
            public const string CACHE_DIRECTORY = @"cache";
            public const string ASSET_CACHE_DIRECTORY = @"assets";
            public const string LOG_FILE_EXTENSION = @"log";
            public const string STATE_DIRECTORY = @"state";
            public const string NOTIFICATIONS_STATE_FILE = @"Notifications.state";
            public const string GROUP_MEMBERS_STATE_FILE = @"GroupMembers.state";
            public const string GROUP_SCHEDULES_STATE_FILE = @"GroupSchedules.state";
            public const string GROUP_COOKIES_STATE_FILE = @"GroupCookies.state";
            public const string MOVEMENT_STATE_FILE = @"Movement.state";
            public const string FEEDS_STATE_FILE = @"Feeds.state";
            public const string CONFERENCE_STATE_FILE = @"Conferences.state";
            public const string LIBS_DIRECTORY = @"libs";
            public const string LANGUAGE_PROFILE_FILE = @"Core14.profile.xml";
            public static readonly Regex OneOrMoRegex = new Regex(@".+?", RegexOptions.Compiled);

            public static readonly Regex InventoryOfferObjectNameRegEx = new Regex(@"^[']{0,1}(.+?)(('\s)|$)",
                RegexOptions.Compiled);

            public static readonly Regex EjectedFromGroupRegEx =
                new Regex(@"You have been ejected from '(.+?)' by .+?\.$", RegexOptions.Compiled);

            public static readonly string GROUP_MESSAGE_LOG_MESSAGE_FORMAT = @"[{0}] {1} {2} : {3}";

            public static readonly Regex GroupMessageLogRegex = new Regex(@"^\[(.+?)\] (.+?) (.+?) : (.+?)$",
                RegexOptions.Compiled);

            public static readonly string REGION_MESSAGE_LOG_MESSAGE_FORMAT = @"[{0}] {1} {2} : {3}";

            public static readonly Regex RegionMessageLogRegex = new Regex(@"^\[(.+?)\] (.+?) (.+?) : (.+?)$",
                RegexOptions.Compiled);

            public static readonly string INSTANT_MESSAGE_LOG_MESSAGE_FORMAT = @"[{0}] {1} {2} : {3}";

            public static readonly Regex InstantMessageLogRegex = new Regex(@"^\[(.+?)\] (.+?) (.+?) : (.+?)$",
                RegexOptions.Compiled);

            public static readonly string CONFERENCE_MESSAGE_LOG_MESSAGE_FORMAT = @"[{0}] {1} {2} : {3}";

            public static readonly Regex ConferenceMessageLogRegex = new Regex(@"^\[(.+?)\] (.+?) (.+?) : (.+?)$",
                RegexOptions.Compiled);

            public static readonly string LOCAL_MESSAGE_LOG_MESSAGE_FORMAT = @"[{0}] {1} {2} ({3}) : {4}";

            public static readonly Regex LocalMessageLogRegex = new Regex(@"^\[(.+?)\] (.+?) (.+?) \((.+?)\) : (.+?)$",
                RegexOptions.Compiled);

            /// <summary>
            ///     Corrade version.
            /// </summary>
            public static readonly string CORRADE_VERSION = Assembly.GetEntryAssembly().GetName().Version.ToString();

            /// <summary>
            ///     Corrade user agent.
            /// </summary>
            public static readonly ProductInfoHeaderValue USER_AGENT = new ProductInfoHeaderValue(CORRADE,
                CORRADE_VERSION);

            /// <summary>
            ///     Corrade compile date.
            /// </summary>
            public static readonly string CORRADE_COMPILE_DATE = new DateTime(2000, 1, 1).Add(new TimeSpan(
                TimeSpan.TicksPerDay*Assembly.GetEntryAssembly().GetName().Version.Build + // days since 1 January 2000
                TimeSpan.TicksPerSecond*2*Assembly.GetEntryAssembly().GetName().Version.Revision)).ToLongDateString();

            /// <summary>
            ///     Corrade Logo.
            /// </summary>
            public static readonly List<string> LOGO = new List<string>
            {
                @"",
                @"       _..--=--..._  ",
                @"    .-'            '-.  .-.  ",
                @"   /.'              '.\/  /  ",
                @"  |=-     Corrade    -=| (  ",
                @"   \'.              .'/\  \  ",
                @"    '-.,_____ _____.-'  '-'  ",
                @"          [_____]=8  ",
                @"               \  ",
                @"                 Good day!  ",
                @"",
                string.Format(Utils.EnUsCulture, "Version: {0}, Compiled: {1}", CORRADE_VERSION,
                    CORRADE_COMPILE_DATE),
                string.Format(Utils.EnUsCulture, "Copyright: {0}", COPYRIGHT)
            };

            /// <summary>
            ///     Conten-types that Corrade can send and receive.
            /// </summary>
            public struct CONTENT_TYPE
            {
                public const string TEXT_PLAIN = @"text/plain";
                public const string WWW_FORM_URLENCODED = @"application/x-www-form-urlencoded";
            }

            public struct PERMISSIONS
            {
                public const string NONE = @"------------------------------";
            }

            public struct PRIMTIVE_BODIES
            {
                [Reflection.NameAttribute("cube")] public static readonly Primitive.ConstructionData CUBE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("prism")] public static readonly Primitive.ConstructionData PRISM = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 1.0f,
                    PathShearX = -0.5f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("pyramid")] public static readonly Primitive.ConstructionData PYRAMID = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("tetrahedron")] public static readonly Primitive.ConstructionData TETRAHEDRON
                    = new Primitive.ConstructionData
                    {
                        AttachmentPoint = AttachmentPoint.Default,
                        Material = Material.Wood,
                        PathBegin = 0f,
                        PathCurve = PathCurve.Line,
                        PathEnd = 1.0f,
                        PathRadiusOffset = 0.0f,
                        PathRevolutions = 1.0f,
                        PathScaleX = 0.0f,
                        PathScaleY = 0.0f,
                        PathShearX = 0.0f,
                        PathShearY = 0.0f,
                        PathSkew = 0.0f,
                        PathTaperX = 0.0f,
                        PathTaperY = 0.0f,
                        PathTwistBegin = 0.0f,
                        PCode = PCode.Prim,
                        ProfileBegin = 0.0f,
                        ProfileCurve = ProfileCurve.EqualTriangle,
                        ProfileEnd = 1.0f,
                        ProfileHole = HoleType.Same,
                        ProfileHollow = 0.0f,
                        State = 0
                    };

                [Reflection.NameAttribute("cylinder")] public static readonly Primitive.ConstructionData CYLINDER = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("hemicylinder")] public static readonly Primitive.ConstructionData
                    HEMICYLINDER = new Primitive.ConstructionData
                    {
                        AttachmentPoint = AttachmentPoint.Default,
                        Material = Material.Wood,
                        PathBegin = 0.0f,
                        PathCurve = PathCurve.Line,
                        PathEnd = 1.0f,
                        PathRadiusOffset = 0.0f,
                        PathRevolutions = 1.0f,
                        PathScaleX = 1.0f,
                        PathScaleY = 1.0f,
                        PathShearX = 0.0f,
                        PathShearY = 0.0f,
                        PathSkew = 0.0f,
                        PathTaperX = 0.0f,
                        PathTaperY = 0.0f,
                        PathTwistBegin = 0.0f,
                        PCode = PCode.Prim,
                        ProfileBegin = 0.25f,
                        ProfileCurve = ProfileCurve.Circle,
                        ProfileEnd = 0.75f,
                        ProfileHole = HoleType.Same,
                        ProfileHollow = 0.0f,
                        State = 0
                    };

                [Reflection.NameAttribute("cone")] public static readonly Primitive.ConstructionData CONE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("hemicone")] public static readonly Primitive.ConstructionData HEMICONE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.25f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 0.75f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("sphere")] public static readonly Primitive.ConstructionData SPHERE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.HalfCircle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("hemisphere")] public static readonly Primitive.ConstructionData HEMISPHERE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 0.5f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.HalfCircle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("torus")] public static readonly Primitive.ConstructionData TORUS = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 0.25f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Reflection.NameAttribute("ring")] public static readonly Primitive.ConstructionData RING = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 0.25f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.EqualTriangle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };
            }
        }

        /// <summary>
        ///     An element from the callback queue waiting to be dispatched.
        /// </summary>
        private struct CallbackQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
            public UUID GroupUUID;
        }

        /// <summary>
        ///     Structure containing error messages printed on console for the owner.
        /// </summary>
        private enum ConsoleError
        {
            [Reflection.DescriptionAttribute("none")] NONE = 0,
            [Reflection.DescriptionAttribute("access denied")] ACCESS_DENIED,

            [Reflection.DescriptionAttribute(
                "the Terms of Service (TOS) for the grid you are connecting to have not been accepted, please check your configuration file"
                )] TOS_NOT_ACCEPTED,
            [Reflection.DescriptionAttribute("teleport failed")] TELEPORT_FAILED,
            [Reflection.DescriptionAttribute("teleport succeeded")] TELEPORT_SUCCEEDED,
            [Reflection.DescriptionAttribute("accepted friendship")] ACCEPTED_FRIENDSHIP,
            [Reflection.DescriptionAttribute("login failed")] LOGIN_FAILED,
            [Reflection.DescriptionAttribute("login succeeded")] LOGIN_SUCCEEDED,
            [Reflection.DescriptionAttribute("failed to set appearance")] APPEARANCE_SET_FAILED,
            [Reflection.DescriptionAttribute("appearance set")] APPEARANCE_SET_SUCCEEDED,
            [Reflection.DescriptionAttribute("all simulators disconnected")] ALL_SIMULATORS_DISCONNECTED,
            [Reflection.DescriptionAttribute("simulator connected")] SIMULATOR_CONNECTED,
            [Reflection.DescriptionAttribute("event queue started")] EVENT_QUEUE_STARTED,
            [Reflection.DescriptionAttribute("disconnected")] DISCONNECTED,
            [Reflection.DescriptionAttribute("logging out")] LOGGING_OUT,
            [Reflection.DescriptionAttribute("logging in")] LOGGING_IN,
            [Reflection.DescriptionAttribute("agent not found")] AGENT_NOT_FOUND,
            [Reflection.DescriptionAttribute("reading Corrade configuration")] READING_CORRADE_CONFIGURATION,
            [Reflection.DescriptionAttribute("read Corrade configuration")] READ_CORRADE_CONFIGURATION,
            [Reflection.DescriptionAttribute("configuration file modified")] CONFIGURATION_FILE_MODIFIED,
            [Reflection.DescriptionAttribute("HTTP server error")] HTTP_SERVER_ERROR,
            [Reflection.DescriptionAttribute("HTTP server not supported")] HTTP_SERVER_NOT_SUPPORTED,
            [Reflection.DescriptionAttribute("starting HTTP server")] STARTING_HTTP_SERVER,
            [Reflection.DescriptionAttribute("stopping HTTP server")] STOPPING_HTTP_SERVER,
            [Reflection.DescriptionAttribute("HTTP server processing aborted")] HTTP_SERVER_PROCESSING_ABORTED,
            [Reflection.DescriptionAttribute("timeout logging out")] TIMEOUT_LOGGING_OUT,
            [Reflection.DescriptionAttribute("callback error")] CALLBACK_ERROR,
            [Reflection.DescriptionAttribute("notification error")] NOTIFICATION_ERROR,
            [Reflection.DescriptionAttribute("inventory cache items loaded")] INVENTORY_CACHE_ITEMS_LOADED,
            [Reflection.DescriptionAttribute("inventory cache items saved")] INVENTORY_CACHE_ITEMS_SAVED,
            [Reflection.DescriptionAttribute("unable to load Corrade cache")] UNABLE_TO_LOAD_CORRADE_CACHE,
            [Reflection.DescriptionAttribute("unable to save Corrade cache")] UNABLE_TO_SAVE_CORRADE_CACHE,
            [Reflection.DescriptionAttribute("failed to manifest RLV behaviour")] FAILED_TO_MANIFEST_RLV_BEHAVIOUR,
            [Reflection.DescriptionAttribute("behaviour not implemented")] BEHAVIOUR_NOT_IMPLEMENTED,
            [Reflection.DescriptionAttribute("workers exceeded")] WORKERS_EXCEEDED,
            [Reflection.DescriptionAttribute("SIML bot configuration modified")] SIML_CONFIGURATION_MODIFIED,
            [Reflection.DescriptionAttribute("read SIML bot configuration")] READ_SIML_BOT_CONFIGURATION,
            [Reflection.DescriptionAttribute("reading SIML bot configuration")] READING_SIML_BOT_CONFIGURATION,
            [Reflection.DescriptionAttribute("wrote SIML bot configuration")] WROTE_SIML_BOT_CONFIGURATION,
            [Reflection.DescriptionAttribute("writing SIML bot configuration")] WRITING_SIML_BOT_CONFIGURATION,
            [Reflection.DescriptionAttribute("error loading SIML bot files")] ERROR_LOADING_SIML_BOT_FILES,
            [Reflection.DescriptionAttribute("error saving SIML bot files")] ERROR_SAVING_SIML_BOT_FILES,
            [Reflection.DescriptionAttribute("could not write to client log file")] COULD_NOT_WRITE_TO_CLIENT_LOG_FILE,
            [Reflection.DescriptionAttribute("could not write to group chat log file")] COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE,
            [Reflection.DescriptionAttribute("could not write to instant message log file")] COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE,
            [Reflection.DescriptionAttribute("could not write to local message log file")] COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE,
            [Reflection.DescriptionAttribute("could not write to region message log file")] COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE,
            [Reflection.DescriptionAttribute("unknown IP address")] UNKNOWN_IP_ADDRESS,
            [Reflection.DescriptionAttribute("unable to save Corrade notifications state")] UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE,
            [Reflection.DescriptionAttribute("unable to load Corrade notifications state")] UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE,
            [Reflection.DescriptionAttribute("unknwon notification type")] UNKNOWN_NOTIFICATION_TYPE,
            [Reflection.DescriptionAttribute("teleport throttled")] TELEPORT_THROTTLED,
            [Reflection.DescriptionAttribute("uncaught exception for thread")] UNCAUGHT_EXCEPTION_FOR_THREAD,
            [Reflection.DescriptionAttribute("error setting up configuration watcher")] ERROR_SETTING_UP_CONFIGURATION_WATCHER,
            [Reflection.DescriptionAttribute("error setting up SIML configuration watcher")] ERROR_SETTING_UP_SIML_CONFIGURATION_WATCHER,
            [Reflection.DescriptionAttribute("callback throttled")] CALLBACK_THROTTLED,
            [Reflection.DescriptionAttribute("notification throttled")] NOTIFICATION_THROTTLED,
            [Reflection.DescriptionAttribute("error updating inventory")] ERROR_UPDATING_INVENTORY,
            [Reflection.DescriptionAttribute("unable to load group members state")] UNABLE_TO_LOAD_GROUP_MEMBERS_STATE,
            [Reflection.DescriptionAttribute("unable to save group members state")] UNABLE_TO_SAVE_GROUP_MEMBERS_STATE,
            [Reflection.DescriptionAttribute("error making POST request")] ERROR_MAKING_POST_REQUEST,
            [Reflection.DescriptionAttribute("notifications file modified")] NOTIFICATIONS_FILE_MODIFIED,
            [Reflection.DescriptionAttribute("unable to load Corrade configuration")] UNABLE_TO_LOAD_CORRADE_CONFIGURATION,
            [Reflection.DescriptionAttribute("unable to save Corrade configuration")] UNABLE_TO_SAVE_CORRADE_CONFIGURATION,
            [Reflection.DescriptionAttribute("unable to load Corrade group schedules state")] UNABLE_TO_LOAD_CORRADE_GROUP_SCHEDULES_STATE,
            [Reflection.DescriptionAttribute("unable to save Corrade group schedules state")] UNABLE_TO_SAVE_CORRADE_GROUP_SCHEDULES_STATE,
            [Reflection.DescriptionAttribute("group schedules file modified")] GROUP_SCHEDULES_FILE_MODIFIED,
            [Reflection.DescriptionAttribute("error setting up notifications watcher")] ERROR_SETTING_UP_NOTIFICATIONS_WATCHER,
            [Reflection.DescriptionAttribute("error setting up schedules watcher")] ERROR_SETTING_UP_SCHEDULES_WATCHER,
            [Reflection.DescriptionAttribute("unable to load Corrade movement state")] UNABLE_TO_LOAD_CORRADE_MOVEMENT_STATE,
            [Reflection.DescriptionAttribute("unable to save Corrade movement state")] UNABLE_TO_SAVE_CORRADE_MOVEMENT_STATE,
            [Reflection.DescriptionAttribute("TCP notifications server error")] TCP_NOTIFICATIONS_SERVER_ERROR,
            [Reflection.DescriptionAttribute("stopping TCP notifications server")] STOPPING_TCP_NOTIFICATIONS_SERVER,
            [Reflection.DescriptionAttribute("starting TCP notifications server")] STARTING_TCP_NOTIFICATIONS_SERVER,
            [Reflection.DescriptionAttribute("TCP notification throttled")] TCP_NOTIFICATION_THROTTLED,
            [Reflection.DescriptionAttribute("unknown group")] UNKNOWN_GROUP,
            [Reflection.DescriptionAttribute("group feeds file modified")] GROUP_FEEDS_FILE_MODIFIED,
            [Reflection.DescriptionAttribute("unable to save Corrade feeds state")] UNABLE_TO_SAVE_CORRADE_FEEDS_STATE,
            [Reflection.DescriptionAttribute("unable to load Corrade feeds state")] UNABLE_TO_LOAD_CORRADE_FEEDS_STATE,
            [Reflection.DescriptionAttribute("error setting up feeds watcher")] ERROR_SETTING_UP_FEEDS_WATCHER,
            [Reflection.DescriptionAttribute("error loading feed")] ERROR_LOADING_FEED,
            [Reflection.DescriptionAttribute("error saving SIML bot learning file")] ERROR_SAVING_SIML_BOT_LEARNING_FILE,
            [Reflection.DescriptionAttribute("error saving SIML bot memorizing file")] ERROR_SAVING_SIML_BOT_MEMORIZING_FILE,
            [Reflection.DescriptionAttribute("error loading language detection")] ERROR_LOADING_LANGUAGE_DETECTION,
            [Reflection.DescriptionAttribute("updating Corrade configuration")] UPDATING_CORRADE_CONFIGURATION,
            [Reflection.DescriptionAttribute("Corrade configuration updated")] CORRADE_CONFIGURATION_UPDATED,
            [Reflection.DescriptionAttribute("Connecting to login server")] CONNECTING_TO_LOGIN_SERVER,
            [Reflection.DescriptionAttribute("Redirecting")] REDIRECTING,
            [Reflection.DescriptionAttribute("Connecting to simulator")] CONNECTING_TO_SIMULATOR,
            [Reflection.DescriptionAttribute("Reading response")] READING_RESPONSE,
            [Reflection.DescriptionAttribute("unable to load group cookies state")] UNABLE_TO_LOAD_GROUP_COOKIES_STATE,
            [Reflection.DescriptionAttribute("unable to save group cookies state")] UNABLE_TO_SAVE_GROUP_COOKIES_STATE,
            [Reflection.DescriptionAttribute("could not write to conference message log file")] COULD_NOT_WRITE_TO_CONFERENCE_MESSAGE_LOG_FILE,
            [Reflection.DescriptionAttribute("unable to load conference state")] UNABLE_TO_LOAD_CONFERENCE_STATE,
            [Reflection.DescriptionAttribute("unable to save conference state")] UNABLE_TO_SAVE_CONFERENCE_STATE,
            [Reflection.DescriptionAttribute("unable to restore conference")] UNABLE_TO_RESTORE_CONFERENCE
        }

        /// <summary>
        ///     Corrade's internal thread structure.
        /// </summary>
        private struct CorradeThread
        {
            /// <summary>
            ///     Holds all the live threads.
            /// </summary>
            private static readonly HashSet<Thread> WorkSet = new HashSet<Thread>();

            private static readonly object WorkSetLock = new object();

            /// <summary>
            ///     Semaphore for sequential execution of threads.
            /// </summary>
            private static readonly ManualResetEvent SequentialThreadCompletedEvent = new ManualResetEvent(true);

            /// <summary>
            ///     Holds a map of groups to execution time in milliseconds.
            /// </summary>
            private static Dictionary<UUID, GroupExecution> GroupExecutionTime =
                new Dictionary<UUID, GroupExecution>();

            private static readonly object GroupExecutionTimeLock = new object();
            private static readonly Stopwatch ThreadExecutuionStopwatch = new Stopwatch();
            private readonly CorradeThreadType corradeThreadType;

            /// <summary>
            ///     Constructor for a Corrade thread.
            /// </summary>
            /// <param name="corradeThreadType">the type of Corrade thread</param>
            public CorradeThread(CorradeThreadType corradeThreadType)
            {
                this.corradeThreadType = corradeThreadType;
            }

            /// <summary>
            ///     This is a sequential scheduler that benefits from not blocking Corrade
            ///     and guarrantees that any Corrade thread spawned this way will only execute
            ///     until the previous thread spawned this way has completed.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            /// <param name="millisecondsTimeout">
            ///     the timeout in milliseconds before considering the previous thread as vanished
            /// </param>
            public void SpawnSequential(ThreadStart s, uint m, uint millisecondsTimeout)
            {
                lock (WorkSetLock)
                {
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                var threadType = corradeThreadType;
                Thread t = null;
                t = new Thread(() =>
                {
                    // Wait for previous sequential thread to complete.
                    SequentialThreadCompletedEvent.WaitOne((int) millisecondsTimeout, false);
                    SequentialThreadCompletedEvent.Reset();
                    // protect inner thread
                    try
                    {
                        s();
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            Reflection.GetDescriptionFromEnumValue(ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            Reflection.GetNameFromEnumValue(threadType), ex.Message, ex.InnerException?.Message);
                    }
                    // Thread has completed.
                    SequentialThreadCompletedEvent.Set();
                    lock (WorkSetLock)
                    {
                        WorkSet.Remove(t);
                    }
                })
                {IsBackground = true};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            /// <summary>
            ///     This is an ad-hoc scheduler where threads will be executed in a
            ///     first-come first-served fashion.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            public void Spawn(ThreadStart s, uint m)
            {
                lock (WorkSetLock)
                {
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                var threadType = corradeThreadType;
                Thread t = null;
                t = new Thread(() =>
                {
                    // protect inner thread
                    try
                    {
                        s();
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            Reflection.GetDescriptionFromEnumValue(ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            Reflection.GetNameFromEnumValue(threadType), ex.Message, ex.InnerException?.Message);
                    }
                    lock (WorkSetLock)
                    {
                        WorkSet.Remove(t);
                    }
                })
                {IsBackground = true};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            /// <summary>
            ///     This is a fairness-oriented group/time-based scheduler that monitors
            ///     the execution time of threads for each configured group and favors
            ///     threads for the configured groups that have the smallest accumulated
            ///     execution time.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            /// <param name="groupUUID">the UUID of the group</param>
            /// <param name="expiration">the time in milliseconds after which measurements are expunged</param>
            public void Spawn(ThreadStart s, uint m, UUID groupUUID, uint expiration)
            {
                // Don't accept to schedule bogus groups.
                if (groupUUID.Equals(UUID.Zero))
                    return;
                lock (WorkSetLock)
                {
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                var threadType = corradeThreadType;
                Thread t = null;
                t = new Thread(() =>
                {
                    // protect inner thread
                    try
                    {
                        // First remove any groups that have expired.
                        lock (GroupExecutionTimeLock)
                        {
                            GroupExecutionTime =
                                GroupExecutionTime.AsParallel().Where(
                                    o => (DateTime.Now - o.Value.TimeStamp).Milliseconds < expiration)
                                    .ToDictionary(o => o.Key, o => o.Value);
                        }
                        var sleepTime = 0;
                        var sortedTimeGroups = new List<int>();
                        lock (GroupExecutionTimeLock)
                        {
                            // In case only one group is involved, then do not schedule the group.
                            if (GroupExecutionTime.Count > 1 && GroupExecutionTime.ContainsKey(groupUUID))
                            {
                                sortedTimeGroups.AddRange(
                                    GroupExecutionTime.OrderBy(o => o.Value.ExecutionTime)
                                        .Select(o => o.Value.ExecutionTime));
                            }
                        }
                        switch (sortedTimeGroups.Any())
                        {
                            case true:
                                var draw = CorradeRandom.Next(sortedTimeGroups.Sum(o => o));
                                var accu = 0;
                                foreach (var time in sortedTimeGroups)
                                {
                                    accu += time;
                                    if (accu < draw) continue;
                                    sleepTime = time;
                                    break;
                                }
                                break;
                        }
                        Thread.Sleep(sleepTime);
                        ThreadExecutuionStopwatch.Restart();
                        s();
                        ThreadExecutuionStopwatch.Stop();
                        lock (GroupExecutionTimeLock)
                        {
                            // add or change the mean execution time for a group
                            switch (GroupExecutionTime.ContainsKey(groupUUID))
                            {
                                case true:
                                    GroupExecutionTime[groupUUID] = new GroupExecution
                                    {
                                        ExecutionTime = (GroupExecutionTime[groupUUID].ExecutionTime +
                                                         (int) ThreadExecutuionStopwatch.ElapsedMilliseconds)/
                                                        2,
                                        TimeStamp = DateTime.Now
                                    };
                                    break;
                                default:
                                    GroupExecutionTime.Add(groupUUID, new GroupExecution
                                    {
                                        ExecutionTime = (int) ThreadExecutuionStopwatch.ElapsedMilliseconds,
                                        TimeStamp = DateTime.Now
                                    });
                                    break;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            Reflection.GetDescriptionFromEnumValue(ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            Reflection.GetNameFromEnumValue(threadType), ex.Message, ex.InnerException?.Message,
                            ex.StackTrace);
                    }
                    lock (WorkSetLock)
                    {
                        WorkSet.Remove(t);
                    }
                })
                {IsBackground = true};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            private struct GroupExecution
            {
                public int ExecutionTime;
                public DateTime TimeStamp;
            }
        }

        /// <summary>
        ///     An inventory item.
        /// </summary>
        private struct DirItem
        {
            [Reflection.NameAttribute("item")] public UUID Item;
            [Reflection.NameAttribute("name")] public string Name;
            [Reflection.NameAttribute("permissions")] public string Permissions;
            [Reflection.NameAttribute("type")] public DirItemType Type;

            public static DirItem FromInventoryBase(InventoryBase inventoryBase)
            {
                var item = new DirItem
                {
                    Name = inventoryBase.Name,
                    Item = inventoryBase.UUID,
                    Permissions = CORRADE_CONSTANTS.PERMISSIONS.NONE
                };

                if (inventoryBase is InventoryFolder)
                {
                    item.Type = DirItemType.FOLDER;
                    return item;
                }

                if (!(inventoryBase is InventoryItem)) return item;

                var inventoryItem = inventoryBase as InventoryItem;
                item.Permissions = Inventory.wasPermissionsToString(inventoryItem.Permissions);

                if (inventoryItem is InventoryWearable)
                {
                    item.Type = (DirItemType) typeof (DirItemType).GetFields(BindingFlags.Public |
                                                                             BindingFlags.Static)
                        .AsParallel().FirstOrDefault(
                            o =>
                                string.Equals(o.Name,
                                    Enum.GetName(typeof (WearableType),
                                        (inventoryItem as InventoryWearable).WearableType),
                                    StringComparison.OrdinalIgnoreCase)).GetValue(null);
                    return item;
                }

                if (inventoryItem is InventoryTexture)
                {
                    item.Type = DirItemType.TEXTURE;
                    return item;
                }

                if (inventoryItem is InventorySound)
                {
                    item.Type = DirItemType.SOUND;
                    return item;
                }

                if (inventoryItem is InventoryCallingCard)
                {
                    item.Type = DirItemType.CALLINGCARD;
                    return item;
                }

                if (inventoryItem is InventoryLandmark)
                {
                    item.Type = DirItemType.LANDMARK;
                    return item;
                }

                if (inventoryItem is InventoryObject)
                {
                    item.Type = DirItemType.OBJECT;
                    return item;
                }

                if (inventoryItem is InventoryNotecard)
                {
                    item.Type = DirItemType.NOTECARD;
                    return item;
                }

                if (inventoryItem is InventoryCategory)
                {
                    item.Type = DirItemType.CATEGORY;
                    return item;
                }

                if (inventoryItem is InventoryLSL)
                {
                    item.Type = DirItemType.LSL;
                    return item;
                }

                if (inventoryItem is InventorySnapshot)
                {
                    item.Type = DirItemType.SNAPSHOT;
                    return item;
                }

                if (inventoryItem is InventoryAttachment)
                {
                    item.Type = DirItemType.ATTACHMENT;
                    return item;
                }

                if (inventoryItem is InventoryAnimation)
                {
                    item.Type = DirItemType.ANIMATION;
                    return item;
                }

                if (inventoryItem is InventoryGesture)
                {
                    item.Type = DirItemType.GESTURE;
                    return item;
                }

                item.Type = DirItemType.NONE;
                return item;
            }
        }

        /// <summary>
        ///     Holds item types with the wearable inventory item type expanded to wearable types.
        /// </summary>
        private enum DirItemType : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("texture")] TEXTURE,
            [Reflection.NameAttribute("sound")] SOUND,
            [Reflection.NameAttribute("callingcard")] CALLINGCARD,
            [Reflection.NameAttribute("landmark")] LANDMARK,
            [Reflection.NameAttribute("object")] OBJECT,
            [Reflection.NameAttribute("notecard")] NOTECARD,
            [Reflection.NameAttribute("category")] CATEGORY,
            [Reflection.NameAttribute("LSL")] LSL,
            [Reflection.NameAttribute("snapshot")] SNAPSHOT,
            [Reflection.NameAttribute("attachment")] ATTACHMENT,
            [Reflection.NameAttribute("animation")] ANIMATION,
            [Reflection.NameAttribute("gesture")] GESTURE,
            [Reflection.NameAttribute("folder")] FOLDER,
            [Reflection.NameAttribute("shape")] SHAPE,
            [Reflection.NameAttribute("skin")] SKIN,
            [Reflection.NameAttribute("hair")] HAIR,
            [Reflection.NameAttribute("eyes")] EYES,
            [Reflection.NameAttribute("shirt")] SHIRT,
            [Reflection.NameAttribute("pants")] PANTS,
            [Reflection.NameAttribute("shoes")] SHOES,
            [Reflection.NameAttribute("socks")] SOCKS,
            [Reflection.NameAttribute("jacket")] JACKET,
            [Reflection.NameAttribute("gloves")] GLOVES,
            [Reflection.NameAttribute("undershirt")] UNDERSHIRT,
            [Reflection.NameAttribute("underpants")] UNDERPANTS,
            [Reflection.NameAttribute("skirt")] SKIRT,
            [Reflection.NameAttribute("tattoo")] TATTOO,
            [Reflection.NameAttribute("alpha")] ALPHA,
            [Reflection.NameAttribute("physics")] PHYSICS
        }

        /// <summary>
        ///     Directions in 3D cartesian.
        /// </summary>
        private enum Direction : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("back")] BACK,
            [Reflection.NameAttribute("forward")] FORWARD,
            [Reflection.NameAttribute("left")] LEFT,
            [Reflection.NameAttribute("right")] RIGHT,
            [Reflection.NameAttribute("up")] UP,
            [Reflection.NameAttribute("down")] DOWN
        }

        /// <summary>
        ///     Possible entities.
        /// </summary>
        private enum Entity : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("avatar")] AVATAR,
            [Reflection.NameAttribute("local")] LOCAL,
            [Reflection.NameAttribute("group")] GROUP,
            [Reflection.NameAttribute("estate")] ESTATE,
            [Reflection.NameAttribute("region")] REGION,
            [Reflection.NameAttribute("object")] OBJECT,
            [Reflection.NameAttribute("parcel")] PARCEL,
            [Reflection.NameAttribute("range")] RANGE,
            [Reflection.NameAttribute("syntax")] SYNTAX,
            [Reflection.NameAttribute("permission")] PERMISSION,
            [Reflection.NameAttribute("description")] DESCRIPTION,
            [Reflection.NameAttribute("message")] MESSAGE,
            [Reflection.NameAttribute("world")] WORLD,
            [Reflection.NameAttribute("statistics")] STATISTICS,
            [Reflection.NameAttribute("lindex")] LINDEX,
            [Reflection.NameAttribute("conference")] CONFERENCE
        }

        /// <summary>
        ///     A structure for group invites.
        /// </summary>
        private struct GroupInvite
        {
            [Reflection.NameAttribute("agent")] public Agent Agent;
            [Reflection.NameAttribute("fee")] public int Fee;
            [Reflection.NameAttribute("group")] public string Group;
            [Reflection.NameAttribute("session")] public UUID Session;
        }

        /// <summary>
        ///     A structure for group notices.
        /// </summary>
        private struct GroupNotice
        {
            [Reflection.NameAttribute("agent")] public Agent Agent;
            [Reflection.NameAttribute("asset")] public AssetType Asset;
            [Reflection.NameAttribute("attachment")] public bool Attachment;
            [Reflection.NameAttribute("folder")] public UUID Folder;
            [Reflection.NameAttribute("group")] public Group Group;
            [Reflection.NameAttribute("message")] public string Message;
            [Reflection.NameAttribute("session")] public UUID Session;
            [Reflection.NameAttribute("subject")] public string Subject;
        }

        /// <summary>
        ///     A structure holding Corrade command parameters.
        /// </summary>
        public struct CorradeCommandParameters
        {
            [Reflection.NameAttribute("group")] public Configuration.Group Group;
            [Reflection.NameAttribute("identifier")] public string Identifier;
            [Reflection.NameAttribute("message")] public string Message;
            [Reflection.NameAttribute("sender")] public string Sender;
        }

        public struct CorradeNotificationParameters
        {
            [Reflection.NameAttribute("event")] public object Event;
            [Reflection.NameAttribute("notification")] public Notification Notification;
        }

        /// <summary>
        ///     A structure for group scheduled commands.
        /// </summary>
        [Serializable]
        public struct GroupSchedule
        {
            [Reflection.NameAttribute("at")] public DateTime At;
            [Reflection.NameAttribute("group")] public Configuration.Group Group;
            [Reflection.NameAttribute("identifier")] public string Identifier;
            [Reflection.NameAttribute("message")] public string Message;
            [Reflection.NameAttribute("sender")] public string Sender;
        }

        /// <summary>
        ///     A structure for conferences.
        /// </summary>
        public struct Conference
        {
            [Reflection.NameAttribute("name")] public string Name;
            [Reflection.NameAttribute("session")] public UUID Session;
            [Reflection.NameAttribute("restored")] public bool Restored;
        }

        /// <summary>
        ///     A structure for the agent movement.
        /// </summary>
        [Serializable]
        public struct AgentMovement
        {
            public bool AlwaysRun;
            public bool AutoResetControls;
            public bool Away;
            public Quaternion BodyRotation;
            public AgentFlags Flags;
            public bool Fly;
            public Quaternion HeadRotation;
            public bool Mouselook;
            public bool SitOnGround;
            public bool StandUp;
            public AgentState State;
        }

        /// <summary>
        ///     A structure for holding region messages.
        /// </summary>
        public struct RegionMessage
        {
            public DateTime DateTime;
            public string FirstName;
            public string LastName;
            public string Message;
            public string RegionName;
        }

        /// <summary>
        ///     A structure for holding group messages.
        /// </summary>
        [Serializable]
        public struct GroupMessage
        {
            public DateTime DateTime;
            public string FirstName;
            public string LastName;
            public string Message;
        }

        /// <summary>
        ///     A structure for holding instant messages.
        /// </summary>
        [Serializable]
        public struct InstantMessage
        {
            public DateTime DateTime;
            public string FirstName;
            public string LastName;
            public string Message;
        }

        /// <summary>
        ///     A structure for holding local messages.
        /// </summary>
        [Serializable]
        public struct LocalMessage
        {
            public ChatType ChatType;
            public DateTime DateTime;
            public string FirstName;
            public string LastName;
            public string Message;
            public string RegionName;
        }

        /// <summary>
        ///     An event for the group membership notification.
        /// </summary>
        private class GroupMembershipEventArgs : EventArgs
        {
            public Action Action;
            public string AgentName;
            public UUID AgentUUID;
            public string GroupName;
            public UUID GroupUUID;
        }

        /// <summary>
        ///     An event for the group feed notification.
        /// </summary>
        private class FeedEventArgs : EventArgs
        {
            public DateTimeOffset Date;
            public UUID GroupUUID;
            public string Name;
            public string Summary;
            public string Title;
        }

        private class OutfitEventArgs : EventArgs
        {
            public Action Action;
            public UUID Asset;
            public UUID Creator;
            public string Description;
            public AssetType Entity;
            public InventoryType Inventory;
            public UUID Item;
            public string Name;
            public string Permissions;
            public bool Replace;
            public string Slot;
        }

        /// <summary>
        ///     An event for a group message.
        /// </summary>
        private class GroupMessageEventArgs : EventArgs
        {
            public UUID AgentUUID;
            public string FirstName;
            public string GroupName;
            public UUID GroupUUID;
            public string LastName;
            public string Message;
        }

        /// <summary>
        ///     An event for typing on local or instant message.
        /// </summary>
        private class TypingEventArgs : EventArgs
        {
            public Action Action;
            public UUID AgentUUID;
            public Entity Entity;
            public string FirstName;
            public string LastName;
        }

        /// <summary>
        ///     A structure to track LookAt effects.
        /// </summary>
        private struct LookAtEffect
        {
            [Reflection.NameAttribute("effect")] public UUID Effect;
            [Reflection.NameAttribute("offset")] public Vector3d Offset;
            [Reflection.NameAttribute("source")] public UUID Source;
            [Reflection.NameAttribute("target")] public UUID Target;
            [Reflection.NameAttribute("type")] public LookAtType Type;
        }

        /// <summary>
        ///     Second Life website transactions.
        /// </summary>
        [XmlRoot("transactions")]
        public class Transactions
        {
            [XmlElement("transaction")]
            public List<Transaction> list { get; set; }
        }

        /// <summary>
        ///     Second Life website transaction.
        /// </summary>
        [XmlRoot("transaction")]
        public class Transaction
        {
            [XmlElement("id")]
            public UUID ID { get; set; }

            [XmlElement("type")]
            public string Type { get; set; }

            [XmlElement("description")]
            public string Description { get; set; }

            [XmlElement("region")]
            public string Region { get; set; }

            [XmlElement("deposit")]
            public uint Deposit { get; set; }

            [XmlIgnore]
            public DateTime Time { get; set; }

            [XmlElement("time")]
            public string Timestamp
            {
                get { return Time.ToString(Constants.LSL.DATE_TIME_STAMP); }
                set { Time = DateTime.Parse(value); }
            }

            [XmlElement("resident")]
            public string Resident { get; set; }

            [XmlElement("end_balance")]
            public uint EndBalance { get; set; }
        }

        /// <summary>
        ///     Form data for Second Life events.
        /// </summary>
        public class EventFormData
        {
            public Dictionary<string, uint> Category;
            public Dictionary<string, uint> Duration;
            public Dictionary<string, string> Location;
            public Dictionary<string, string> Time;

            public EventFormData()
            {
                Location = new Dictionary<string, string>();
                Duration = new Dictionary<string, uint>();
                Time = new Dictionary<string, string>();
                Category = new Dictionary<string, uint>();
            }
        }

        /// <summary>
        ///     A Corrade notification.
        /// </summary>
        [Serializable]
        public class Notification
        {
            public Collections.SerializableDictionary<string, string> Afterburn;
            public HashSet<string> Data;
            public string GroupName;
            public UUID GroupUUID;

            /// <summary>
            ///     Holds TCP notification destinations.
            /// </summary>
            /// <remarks>These are state dependant so they do not have to be serialized.</remarks>
            [XmlIgnore] public Dictionary<Configuration.Notifications, HashSet<IPEndPoint>> NotificationTCPDestination;

            public Collections.SerializableDictionary<Configuration.Notifications, HashSet<string>>
                NotificationURLDestination;

            public ulong NotificationMask
            {
                get
                {
                    return (NotificationURLDestination != null && NotificationURLDestination.Any()
                        ? NotificationURLDestination.Keys.Cast<ulong>().Aggregate((p, q) => p |= q)
                        : 0) | (NotificationTCPDestination != null && NotificationTCPDestination.Any()
                            ? NotificationTCPDestination.Keys.Cast<ulong>().Aggregate((p, q) => p |= q)
                            : 0);
                }
            }
        }

        /// <summary>
        ///     An element from the notification queue waiting to be dispatched.
        /// </summary>
        private struct NotificationQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
            public UUID GroupUUID;
        }

        private struct NotificationTCPQueueElement
        {
            public IPEndPoint IPEndPoint;
            public Dictionary<string, string> message;
        }

        /// <summary>
        ///     A structure to track PointAt effects.
        /// </summary>
        private struct PointAtEffect
        {
            [Reflection.NameAttribute("effect")] public UUID Effect;
            [Reflection.NameAttribute("offset")] public Vector3d Offset;
            [Reflection.NameAttribute("source")] public UUID Source;
            [Reflection.NameAttribute("target")] public UUID Target;
            [Reflection.NameAttribute("type")] public PointAtType Type;
        }

        /// <summary>
        ///     Keys returned by Corrade.
        /// </summary>
        private enum ResultKeys : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("data")] DATA,
            [Reflection.NameAttribute("success")] SUCCESS,
            [Reflection.NameAttribute("error")] ERROR,
            [Reflection.NameAttribute("status")] STATUS,
            [Reflection.NameAttribute("time")] TIME
        }

        /// <summary>
        ///     A structure for script dialogs.
        /// </summary>
        private struct ScriptDialog
        {
            public Agent Agent;
            [Reflection.NameAttribute("button")] public List<string> Button;
            [Reflection.NameAttribute("channel")] public int Channel;
            [Reflection.NameAttribute("item")] public UUID Item;
            [Reflection.NameAttribute("message")] public string Message;
            [Reflection.NameAttribute("name")] public string Name;
        }

        /// <summary>
        ///     The status for an error message.
        /// </summary>
        public class StatusAttribute : Attribute
        {
            protected readonly uint statusCode;

            public StatusAttribute(uint statusCode)
            {
                this.statusCode = statusCode;
            }

            public uint Status => statusCode;
        }

        /// <summary>
        ///     An exception thrown on script errors.
        /// </summary>
        [Serializable]
        public class ScriptException : Exception
        {
            public ScriptException(ScriptError error)
                : base(Reflection.GetDescriptionFromEnumValue(error))
            {
                Status = Reflection.GetAttributeFromEnumValue<StatusAttribute>(error).Status;
            }

            protected ScriptException(SerializationInfo info, StreamingContext context)
                : base(info, context)
            {
            }

            public uint Status { get; }
        }

        /// <summary>
        ///     An exception thrown on processing commands via the HTTP server.
        /// </summary>
        [Serializable]
        public class HTTPCommandException : Exception
        {
            public HTTPCommandException()
            {
            }

            public HTTPCommandException(string message)
                : base(message)
            {
            }

            protected HTTPCommandException(SerializationInfo info, StreamingContext context)
                : base(info, context)
            {
            }
        }

        /// <summary>
        ///     Keys reconigzed by Corrade.
        /// </summary>
        private enum ScriptKeys : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,

            [Reflection.NameAttribute("restored")]
            RESTORED,

            [CommandInputSyntax(
                "<command=getconferencemembersdata>&<group=<UUID|STRING>>&<password=<STRING>>&<session=<UUID>>&<data=<ChatSessionMember[,ChatSessionMember...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("getconferencemembersdata")] [Reflection.NameAttribute("getconferencemembersdata")] GETCONFERENCEMEMBERSDATA,

            [CommandInputSyntax(
                "<command=getconferencememberdata>&<group=<UUID|STRING>>&<password=<STRING>>&<session=<UUID>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<ChatSessionMember[,ChatSessionMember...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("getconferencememberdata")] [Reflection.NameAttribute("getconferencememberdata")] GETCONFERENCEMEMBERDATA,

            [CommandInputSyntax(
                "<command=conference>&<group=<UUID|STRING>>&<password=<STRING>>>&<action=<start|detail|list>>&action=start:<avatars=<UUID|STRING[,UUID|STRING...]>>&action=detail:<session=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("conference")] [Reflection.NameAttribute("conference")] CONFERENCE,

            [Reflection.NameAttribute("parent")] PARENT,

            [CommandInputSyntax(
                "<command=importxml>&<group=<UUID|STRING>>&<password=<STRING>>>&<type=<zip|xml>>&<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask(
                    (ulong) Configuration.Permissions.Interact | (ulong) Configuration.Permissions.Economy)] [CorradeCommand("importxml")] [Reflection.NameAttribute("importxml")] IMPORTXML,

            [CommandInputSyntax(
                "<command=getgridlivedatafeeddata>&<group=<UUID|STRING>>&<password=<STRING>>>&<entity=<STRING>>&<data=<STRING[,STRING...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getgridlivedatafeeddata")] [Reflection.NameAttribute("getgridlivedatafeeddata")] GETGRIDLIVEDATAFEEDDATA,

            [CommandInputSyntax(
                "<command=readfile>&<group=<UUID|STRING>>&<password=<STRING>>>&<path=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("readfile")] [Reflection.NameAttribute("readfile")] READFILE,

            [CommandInputSyntax(
                "<command=writefile>&<group=<UUID|STRING>>&<password=<STRING>>>&<path=<STRING>>&<action=<append|create>>&<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("writefile")] [Reflection.NameAttribute("writefile")] WRITEFILE,

            [CommandInputSyntax(
                "<command=getavatargroupsdata>&<group=<UUID|STRING>>&<password=<STRING>>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarGroup[,AvatarGroup...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getavatargroupsdata")] [Reflection.NameAttribute("getavatargroupsdata")] GETAVATARGROUPSDATA,

            [CommandInputSyntax(
                "<command=setestatecovenant>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setestatecovenant")] [Reflection.NameAttribute("setestatecovenant")] SETESTATECOVENANT,

            [CommandInputSyntax(
                "<command=divorce>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("divorce")] [Reflection.NameAttribute("divorce")] DIVORCE,

            [CommandInputSyntax(
                "<command=marry>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&<action=<propose|revoke|accept|reject>>&action=propose:<message=<STRING>>&action=propose:<name=<STRING>>&action=accept:[message=<STRING>]&action=reject:[message=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("marry")] [Reflection.NameAttribute("marry")] MARRY,

            [Reflection.NameAttribute("verify")] VERIFY,

            [CommandInputSyntax(
                "<command=modifyevent>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&<id=<INTEGER>>&[name=<STRING>]&[description=<STRING>]&[date=<DateTime>]&[time=<DateTime>]&[duration=<INTEGER>]&[location=<STRING>]&[category=<INTEGER>]&[amount=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("modifyevent")] [Reflection.NameAttribute("modifyevent")] MODIFYEVENT,

            [CommandInputSyntax(
                "<command=deleteevent>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&[amount=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("deleteevent")] [Reflection.NameAttribute("deleteevent")] DELETEEVENT,

            [CommandInputSyntax(
                "<command=addevent>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&<name=<STRING>>&<description=<STRING>>&<date=<DateTime>>&<time=<DateTime>>&<duration=<INTEGER>>&<location=<STRING>>&<category=<INTEGER>>&[amount=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("addevent")] [Reflection.NameAttribute("addevent")] ADDEVENT,

            [Reflection.NameAttribute("location")] LOCATION,
            [Reflection.NameAttribute("category")] CATEGORY,

            [CommandInputSyntax(
                "<command=geteventformdata>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&[data=<EventFormData[,EventFormData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("geteventformdata")] [Reflection.NameAttribute("geteventformdata")] GETEVENTFORMDATA,

            [CommandInputSyntax(
                "<command=getaccounttransactionsdata>&<group=<UUID|STRING>>&<password=<STRING>>&[firstname=<STRING>]&[lastname=<STRING>]&<secret=<STRING>>&[data=<Transaction[,Transaction...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getaccounttransactionsdata")] [Reflection.NameAttribute("getaccounttransactionsdata")] GETACCOUNTTRANSACTIONSDATA,

            [CommandInputSyntax(
                "<command=getobjectsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Primitive[,Primitive...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getobjectsdata")] [Reflection.NameAttribute("getobjectsdata")] GETOBJECTSDATA,

            [CommandInputSyntax(
                "<command=getobjectdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<Primitive[,Primitive...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getobjectdata")] [Reflection.NameAttribute("getobjectdata")] GETOBJECTDATA,

            [CommandInputSyntax(
                "<command=getgroupmembersdata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<data=<GroupMember[,GroupMember...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupmembersdata")] [Reflection.NameAttribute("getgroupmembersdata")] GETGROUPMEMBERSDATA,

            [CommandInputSyntax(
                "<command=language>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<detect>>&action=detect:<message=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("language")] [Reflection.NameAttribute("language")] LANGUAGE,

            [Reflection.NameAttribute("online")] ONLINE,
            [Reflection.NameAttribute("dialog")] DIALOG,

            [CommandInputSyntax(
                "<command=getgroupmemberdata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<GroupMember[,GroupMember...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupmemberdata")] [Reflection.NameAttribute("getgroupmemberdata")] GETGROUPMEMBERDATA,

            [CommandInputSyntax(
                "<command=getcurrentgroupsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getcurrentgroupsdata")] [Reflection.NameAttribute("getcurrentgroupsdata")] GETCURRENTGROUPSDATA,

            [CommandInputSyntax(
                "<command=getcurrentgroups>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getcurrentgroups")] [Reflection.NameAttribute("getcurrentgroups")] GETCURRENTGROUPS,

            [CommandInputSyntax(
                "<command=getgroupsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<target=<UUID|STRING,...>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupsdata")] [Reflection.NameAttribute("getgroupsdata")] GETGROUPSDATA,

            [CommandInputSyntax(
                "<command=facebook>&<group=<UUID|STRING>>&<password=<STRING>>&<token=<USER_ACCESS_TOKEN>>&<action=<post>>&action=post:[ID=<STRING>]&action=post:[message=<STRING>]&action=post:[name=<STRING>]&action=post:[URL=<STRING>]&action=post:[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("facebook")] [Reflection.NameAttribute("facebook")] FACEBOOK,

            [CommandInputSyntax(
                "<command=twitter>&<group=<UUID|STRING>>&<password=<STRING>>&<key=<CONSUMER_KEY>>&<secret=<CONSUMER_SECRET>>&<token=<ACCESS_TOKEN>>&<access=<TOKEN_SECRET>>&<action=<post>>&action=post:<message=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("twitter")] [Reflection.NameAttribute("twitter")] TWITTER,

            [Reflection.NameAttribute("secret")] SECRET,
            [Reflection.NameAttribute("token")] TOKEN,
            [Reflection.NameAttribute("access")] ACCESS,
            [Reflection.NameAttribute("date")] DATE,
            [Reflection.NameAttribute("summary")] SUMMARY,

            [CommandInputSyntax(
                "<command=feed>&<group=<UUID|STRING>>&<password=<STRING>>&<URL=<STRING>>&<action=<add|remove|list>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Feed)] [CorradeCommand("feed")] [Reflection.NameAttribute("feed")] FEED,

            [CommandInputSyntax(
                "<command=setrolepowers>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<role=<UUID|STRING>>&<powers=<GroupPowers[,GroupPowers...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("setrolepowers")] [Reflection.NameAttribute("setrolepowers")] SETROLEPOWERS,

            /// <remarks>
            ///     This command is disabled because libopenmetaverse does not support managing the parcel lists.
            /// </remarks>
            /* [IsCorradeCommand(true)]
            [CommandInputSyntax(
                "<command=setparcellist>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )]
            [CommandPermissionMask((UInt64)Configuration.Permissions.Land)]
            [CorradeCommand("setparcellist")]
            [Reflection.NameAttribute("setparcellist")]
            SETPARCELLIST, */
            [Reflection.NameAttribute("creator")] CREATOR,
            [Reflection.NameAttribute("slot")] SLOT,

            [CommandInputSyntax(
                "<command=configuration>&<group=<UUID|STRING>>&<password=<STRING>>&<action=read|write|get|set>&action=write:<data=STRING>&action=write:<data=<STRING>>&action=get:<path=<STRING>>&action=set:<path=<STRING>>&action=set:<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("configuration")] [Reflection.NameAttribute("configuration")] CONFIGURATION,

            [CommandInputSyntax(
                "<command=getparcelinfodata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<ParcelInfo[,ParcelInfo...]>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getparcelinfodata")] [Reflection.NameAttribute("getparcelinfodata")] GETPARCELINFODATA,

            [Reflection.NameAttribute("degrees")] DEGREES,

            [CommandInputSyntax(
                "<command=turn>&<group=<UUID|STRING>>&<password=<STRING>>&<direction=<left|right>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("turn")] [Reflection.NameAttribute("turn")] TURN,

            [Reflection.NameAttribute("SQL")] SQL,

            [CommandInputSyntax(
                "<command=logs>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<group|message|local|region>>&<action=<get|search>>&entity=group|message|local|region,action=get:[from=<DateTime>]&entity=group|message|local|region,action=get:[to=<DateTime>]&entity=group|message|local|region,action=get:[firstname=<STRING>]&entity=group|message|local|region,action=get:[lastname=<STRING>]&entity=group|message|local|region,action=get:[message=<STRING>]&entity=local|region,action=get:[region=<STRING>]&entity=local:[type=<ChatType>]&action=search:<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("logs")] [Reflection.NameAttribute("logs")] LOGS,

            [Reflection.NameAttribute("from")] FROM,
            [Reflection.NameAttribute("to")] TO,
            [Reflection.NameAttribute("deanimate")] DEANIMATE,

            [CommandInputSyntax(
                "<command=terraform>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<height=<FLOAT>>&<width=<FLOAT>>&<amount=<FLOAT>>&<brush=<TerraformBrushSize>>&<action=<TerraformAction>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("terraform")] [Reflection.NameAttribute("terraform")] TERRAFORM,

            [Reflection.NameAttribute("height")] HEIGHT,
            [Reflection.NameAttribute("width")] WIDTH,
            [Reflection.NameAttribute("brush")] BRUSH,

            [CommandInputSyntax(
                "<command=getestatecovenant>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getestatecovenant")] [Reflection.NameAttribute("getestatecovenant")] GETESTATECOVENANT,

            [CommandInputSyntax(
                "<command=estateteleportusershome>&<group=<UUID|STRING>>&<password=<STRING>>&[avatars=<UUID|STRING[,UUID|STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("estateteleportusershome")] [Reflection.NameAttribute("estateteleportusershome")] ESTATETELEPORTUSERSHOME,

            [CommandInputSyntax(
                "<command=setregionterrainvariables>&<group=<UUID|STRING>>&<password=<STRING>>&[waterheight=<FLOAT>]&[terrainraiselimit=<FLOAT>]&[terrainlowerlimit=<FLOAT>]&[usestatesun=<BOOL>]&[fixedsun=<BOOL>]&[sunposition=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setregionterrainvariables")] [Reflection.NameAttribute("setregionterrainvariables")] SETREGIONTERRAINVARIABLES,

            [Reflection.NameAttribute("useestatesun")] USEESTATESUN,
            [Reflection.NameAttribute("terrainraiselimit")] TERRAINRAISELIMIT,
            [Reflection.NameAttribute("terrainlowerlimit")] TERRAINLOWERLIMIT,
            [Reflection.NameAttribute("sunposition")] SUNPOSITION,
            [Reflection.NameAttribute("fixedsun")] FIXEDSUN,
            [Reflection.NameAttribute("waterheight")] WATERHEIGHT,

            [CommandInputSyntax(
                "<command=getregionterrainheights>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getregionterrainheights")] [Reflection.NameAttribute("getregionterrainheights")] GETREGIONTERRAINHEIGHTS,

            [CommandInputSyntax(
                "<command=setregionterrainheights>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<FLOAT[,FLOAT...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setregionterrainheights")] [Reflection.NameAttribute("setregionterrainheights")] SETREGIONTERRAINHEIGHTS,

            [CommandInputSyntax(
                "<command=getregionterraintextures>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getregionterraintextures")] [Reflection.NameAttribute("getregionterraintextures")] GETREGIONTERRAINTEXTURES,

            [CommandInputSyntax(
                "<command=setregionterraintextures>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<UUID|STRING[,UUID|STRING...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setregionterraintextures")] [Reflection.NameAttribute("setregionterraintextures")] SETREGIONTERRAINTEXTURES,

            [CommandInputSyntax(
                "<command=setregioninfo>&<group=<UUID|STRING>>&<password=<STRING>>&[terraform=<BOOL>]&[fly=<BOOL>]&[damage=<BOOL>]&[resell=<BOOL>]&[push=<BOOL>]&[parcel=<BOOL>]&[limit=<FLOAT>]&[bonus=<FLOAT>]&[mature=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setregioninfo")] [Reflection.NameAttribute("setregioninfo")] SETREGIONINFO,

            [Reflection.NameAttribute("bonus")] BONUS,
            [Reflection.NameAttribute("damage")] DAMAGE,
            [Reflection.NameAttribute("limit")] LIMIT,
            [Reflection.NameAttribute("mature")] MATURE,
            [Reflection.NameAttribute("parcel")] PARCEL,
            [Reflection.NameAttribute("push")] PUSH,
            [Reflection.NameAttribute("resell")] RESELL,

            [CommandInputSyntax(
                "<command=setcameradata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager.AgentMovement.AgentCamera[,AgentManager.AgentMovement.AgentCamera...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("setcameradata")] [Reflection.NameAttribute("setcameradata")] SETCAMERADATA,

            [CommandInputSyntax(
                "<command=getcameradata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager.AgentMovement.AgentCamera[,AgentManager.AgentMovement.AgentCamera...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getcameradata")] [Reflection.NameAttribute("getcameradata")] GETCAMERADATA,

            [CommandInputSyntax(
                "<command=setmovementdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager.AgentMovement[,AgentManager.AgentMovement...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("setmovementdata")] [Reflection.NameAttribute("setmovementdata")] SETMOVEMENTDATA,

            [CommandInputSyntax(
                "<command=getmovementdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager.AgentMovement[,AgentManager.AgentMovement...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getmovementdata")] [Reflection.NameAttribute("getmovementdata")] GETMOVEMENTDATA,

            [CommandInputSyntax(
                "<command=at>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|get|remove|list>>&action=add:<time=<Timestamp>>&action=add:<data=<STRING>>&action=get|remove:<index=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Schedule)] [CorradeCommand("at")] [Reflection.NameAttribute("at")] AT,

            [CommandInputSyntax(
                "<command=flyto>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR3>>&[duration=<INTGEGER>]&[affinity=<INTEGER>]&[fly=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("flyto")] [Reflection.NameAttribute("flyto")] FLYTO,

            [Reflection.NameAttribute("vicinity")] VICINITY,
            [Reflection.NameAttribute("affinity")] AFFINITY,

            [CommandInputSyntax(
                "<command=batchmute>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<mute|unmute>>&[mutes=<STRING|UUID[,STRING|UUID...]>]&action=mute:[type=MuteType]&action=mute:[flags=MuteFlags]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("batchmute")] [Reflection.NameAttribute("batchmute")] BATCHMUTE,

            [Reflection.NameAttribute("mutes")] MUTES,

            [CommandInputSyntax(
                "<command=setconfigurationdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<CorradeConfiguration,[Configuration...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("setconfigurationdata")] [Reflection.NameAttribute("setconfigurationdata")] SETCONFIGURATIONDATA,

            [CommandInputSyntax(
                "<command=getconfigurationdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<CorradeConfiguration,[Configuration...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("getconfigurationdata")] [Reflection.NameAttribute("getconfigurationdata")] GETCONFIGURATIONDATA,

            [CommandInputSyntax(
                "<command=ban>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<action=<ban|unban|list>>&action=ban,unban:[avatars=<UUID|STRING[,UUID|STRING...]>]&action=ban:[eject=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("ban")] [Reflection.NameAttribute("ban")] BAN,

            [CommandInputSyntax("<command=ping>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.None)] [CorradeCommand("ping")] [Reflection.NameAttribute("ping")] PING,
            [Reflection.NameAttribute("pong")] PONG,

            [CommandInputSyntax(
                "<command=batcheject>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[avatars=<UUID|STRING[,UUID|STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("batcheject")] [Reflection.NameAttribute("batcheject")] BATCHEJECT,

            [CommandInputSyntax(
                "<command=batchinvite>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[role=<UUID[,STRING...]>]&[avatars=<UUID|STRING[,UUID|STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("batchinvite")] [Reflection.NameAttribute("batchinvite")] BATCHINVITE,

            [Reflection.NameAttribute("avatars")] AVATARS,

            [CommandInputSyntax(
                "<command=setobjectmediadata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<face=<INTEGER>>&[data=<MediaEntry[,MediaEntry...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectmediadata")] [Reflection.NameAttribute("setobjectmediadata")] SETOBJECTMEDIADATA,

            [CommandInputSyntax(
                "<command=getobjectmediadata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<MediaEntry[,MediaEntry...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getobjectmediadata")] [Reflection.NameAttribute("getobjectmediadata")] GETOBJECTMEDIADATA,

            [CommandInputSyntax(
                "<command=setprimitivematerial>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[material=<Material>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivematerial")] [Reflection.NameAttribute("setprimitivematerial")] SETPRIMITIVEMATERIAL,

            [Reflection.NameAttribute("material")] MATERIAL,

            [CommandInputSyntax(
                "<command=setprimitivelightdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<LightData[,LightData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivelightdata")] [Reflection.NameAttribute("setprimitivelightdata")] SETPRIMITIVELIGHTDATA,

            [CommandInputSyntax(
                "<command=getprimitivelightdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<LightData [,LightData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivelightdata")] [Reflection.NameAttribute("getprimitivelightdata")] GETPRIMITIVELIGHTDATA,

            [CommandInputSyntax(
                "<command=setprimitiveflexibledata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<FlexibleData[,FlexibleData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitiveflexibledata")] [Reflection.NameAttribute("setprimitiveflexibledata")] SETPRIMITIVEFLEXIBLEDATA,

            [CommandInputSyntax(
                "<command=getprimitiveflexibledata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<FlexibleData[,FlexibleData ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitiveflexibledata")] [Reflection.NameAttribute("getprimitiveflexibledata")] GETPRIMITIVEFLEXIBLEDATA,

            [CommandInputSyntax(
                "<command=creategrass>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&<type=<Grass>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("creategrass")] [Reflection.NameAttribute("creategrass")] CREATEGRASS,

            [CommandInputSyntax(
                "<command=getstatus>&<group=<UUID|STRING>>&<password=<STRING>>&<status=<INTEGER>>&<entity=<description>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.None)] [CorradeCommand("getstatus")] [Reflection.NameAttribute("getstatus")] GETSTATUS,

            [CommandInputSyntax(
                "<command=getprimitivebodytypes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivebodytypes")] [Reflection.NameAttribute("getprimitivebodytypes")] GETPRIMITIVEBODYTYPES,

            [CommandInputSyntax(
                "<command=getprimitivephysicsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<PhysicsProperties[,PhysicsProperties ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivephysicsdata")] [Reflection.NameAttribute("getprimitivephysicsdata")] GETPRIMITIVEPHYSICSDATA,

            [CommandInputSyntax(
                "<command=getprimitivepropertiesdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<ObjectProperties[,ObjectProperties ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivepropertiesdata")] [Reflection.NameAttribute("getprimitivepropertiesdata")] GETPRIMITIVEPROPERTIESDATA,

            [CommandInputSyntax(
                "<command=setprimitiveflags>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<SINGLE>]&[temporary=<BOOL>]&[shadows=<BOOL>]&[restitution=<SINGLE>]&[phantom=<BOOL>]&[gravity=<SINGLE>]&[friction=<SINGLE>]&[density=<SINGLE>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitiveflags")] [Reflection.NameAttribute("setprimitiveflags")] SETPRIMITIVEFLAGS,

            [Reflection.NameAttribute("temporary")] TEMPORARY,
            [Reflection.NameAttribute("shadows")] SHADOWS,
            [Reflection.NameAttribute("restitution")] RESTITUTION,
            [Reflection.NameAttribute("phantom")] PHANTOM,
            [Reflection.NameAttribute("gravity")] GRAVITY,
            [Reflection.NameAttribute("friction")] FRICTION,
            [Reflection.NameAttribute("density")] DENSITY,

            [CommandInputSyntax(
                "<command=grab>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&<item=<UUID|STRING>>&[range=<FLOAT>]&<texture=<VECTOR3>&<surface=<VECTOR3>>&<normal=<VECTOR3>>&<binormal=<VECTOR3>>&<face=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("grab")] [Reflection.NameAttribute("grab")] GRAB,

            [Reflection.NameAttribute("texture")] TEXTURE,
            [Reflection.NameAttribute("surface")] SURFACE,
            [Reflection.NameAttribute("normal")] NORMAL,
            [Reflection.NameAttribute("binormal")] BINORMAL,
            [Reflection.NameAttribute("face")] FACE,

            [CommandInputSyntax(
                "<command=createtree>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&<type=<Tree>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("createtree")] [Reflection.NameAttribute("createtree")] CREATETREE,

            [CommandInputSyntax(
                "<command=setprimitivetexturedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[index=<INTEGER>]&[data=<TextureEntryFace [,TextureEntryFace ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivetexturedata")] [Reflection.NameAttribute("setprimitivetexturedata")] SETPRIMITIVETEXTUREDATA,

            [CommandInputSyntax(
                "<command=getprimitivetexturedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<TextureEntry[,TextureEntry ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivetexturedata")] [Reflection.NameAttribute("getprimitivetexturedata")] GETPRIMITIVETEXTUREDATA,

            [CommandInputSyntax(
                "<command=setprimitivesculptdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<SculptData[,SculptData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivesculptdata")] [Reflection.NameAttribute("setprimitivesculptdata")] SETPRIMITIVESCULPTDATA,

            [CommandInputSyntax(
                "<command=getprimitivesculptdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<SculptData[,SculptData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivesculptdata")] [Reflection.NameAttribute("getprimitivesculptdata")] GETPRIMITIVESCULPTDATA,

            [CommandInputSyntax(
                "<command=setprimitiveshapedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[type=<CorradePrimitiveShape>]&[data=<ConstructionData[,ConstructionData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitiveshapedata")] [Reflection.NameAttribute("setprimitiveshapedata")] SETPRIMITIVESHAPEDATA,

            [CommandInputSyntax(
                "<command=getprimitiveshapedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<ConstructionData[,ConstructionData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitiveshapedata")] [Reflection.NameAttribute("getprimitiveshapedata")] GETPRIMITIVESHAPEDATA,

            [CommandInputSyntax(
                "<command=createprimitive>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&[type=<CorradePrimitiveShape>]&[data=<ConstructionData>]&[flags=<PrimFlags>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("createprimitive")] [Reflection.NameAttribute("createprimitive")] CREATEPRIMITIVE,

            [Reflection.NameAttribute("flags")] FLAGS,
            [Reflection.NameAttribute("take")] TAKE,
            [Reflection.NameAttribute("pass")] PASS,
            [Reflection.NameAttribute("controls")] CONTROLS,
            [Reflection.NameAttribute("afterburn")] AFTERBURN,

            [CommandInputSyntax(
                "<command=getprimitivepayprices>&<group=<UUID|STRING>>&<password=<STRING>>>&item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivepayprices")] [Reflection.NameAttribute("getprimitivepayprices")] GETPRIMITIVEPAYPRICES,

            [CommandInputSyntax(
                "<command=primitivebuy>&<group=<UUID|STRING>>&<password=<STRING>>>&item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask(
                    (ulong) Configuration.Permissions.Interact | (ulong) Configuration.Permissions.Economy)
                   ] [CorradeCommand("primitivebuy")] [Reflection.NameAttribute("primitivebuy")] PRIMITIVEBUY,

            [CommandInputSyntax(
                "<command=changeprimitivelink>&<group=<UUID|STRING>>&<password=<STRING>>>&<action=<link|delink>>&action=link:<item=<STRING|UUID,STRING|UUID[,STRING|UUID...>>&action=delink:<item=<STRING|UUID[,STRING|UUID...>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("changeprimitivelink")] [Reflection.NameAttribute("changeprimitivelink")] CHANGEPRIMITIVELINK,

            [CommandInputSyntax(
                "<command=getavatargroupdata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarGroup[,AvatarGroup...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getavatargroupdata")] [Reflection.NameAttribute("getavatargroupdata")] GETAVATARGROUPDATA,

            [CommandInputSyntax(
                "<command=getcommand>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<entity=<syntax|permission>>&entity=syntax:<type=<input>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.None)] [CorradeCommand("getcommand")] [Reflection.NameAttribute("getcommand")] GETCOMMAND,
            [CommandInputSyntax("<command=listcommands>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.None)] [CorradeCommand("listcommands")] [Reflection.NameAttribute("listcommands")] LISTCOMMANDS,

            [CommandInputSyntax(
                "<command=getconnectedregions>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getconnectedregions")] [Reflection.NameAttribute("getconnectedregions")] GETCONNECTEDREGIONS,

            [CommandInputSyntax(
                "<command=getnetworkdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<NetworkManager[,NetworkManager...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getnetworkdata")] [Reflection.NameAttribute("getnetworkdata")] GETNETWORKDATA,

            [CommandInputSyntax(
                "<command=typing>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("typing")] [Reflection.NameAttribute("typing")] TYPING,

            [CommandInputSyntax(
                "<command=busy>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("busy")] [Reflection.NameAttribute("busy")] BUSY,

            [CommandInputSyntax(
                "<command=away>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("away")] [Reflection.NameAttribute("away")] AWAY,

            [CommandInputSyntax(
                "<command=getobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getobjectpermissions")] [Reflection.NameAttribute("getobjectpermissions")] GETOBJECTPERMISSIONS,
            [Reflection.NameAttribute("scale")] SCALE,
            [Reflection.NameAttribute("uniform")] UNIFORM,

            [CommandInputSyntax(
                "<command=setobjectscale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectscale")] [Reflection.NameAttribute("setobjectscale")] SETOBJECTSCALE,

            [CommandInputSyntax(
                "<command=setprimitivescale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivescale")] [Reflection.NameAttribute("setprimitivescale")] SETPRIMITIVESCALE,

            [CommandInputSyntax(
                "<command=setprimitiverotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<rotation=<QUATERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitiverotation")] [Reflection.NameAttribute("setprimitiverotation")] SETPRIMITIVEROTATION,

            [CommandInputSyntax(
                "<command=setprimitiveposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitiveposition")] [Reflection.NameAttribute("setprimitiveposition")] SETPRIMITIVEPOSITION,

            [CommandInputSyntax(
                "<command=exportdae>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("exportdae")] [Reflection.NameAttribute("exportdae")] EXPORTDAE,

            [CommandInputSyntax(
                "<command=exportxml>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("exportxml")] [Reflection.NameAttribute("exportxml")] EXPORTXML,

            [CommandInputSyntax(
                "<command=getprimitivesdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Primitive[,Primitive...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivesdata")] [Reflection.NameAttribute("getprimitivesdata")] GETPRIMITIVESDATA,

            [CommandInputSyntax(
                "<command=getavatarsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Avatar[,Avatar...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getavatarsdata")] [Reflection.NameAttribute("getavatarsdata")] GETAVATARSDATA,
            [Reflection.NameAttribute("format")] FORMAT,
            [Reflection.NameAttribute("volume")] VOLUME,
            [Reflection.NameAttribute("audible")] AUDIBLE,
            [Reflection.NameAttribute("path")] PATH,

            [CommandInputSyntax(
                "<command=inventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<ls|cwd|cd|mkdir|chmod|rm|cp|mv|ln>>&action=ls|mkdir|chmod:[path=<STRING>]&action=cd,action=rm:<path=<STRING>>&action=mkdir:<name=<STRING>>&action=chmod:<permissions=<STRING>>&action=cp|mv|ln:<source=<STRING>>&action=cp|mv|ln:<target=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("inventory")] [Reflection.NameAttribute("inventory")] INVENTORY,
            [Reflection.NameAttribute("offset")] OFFSET,
            [Reflection.NameAttribute("alpha")] ALPHA,
            [Reflection.NameAttribute("color")] COLOR,

            [CommandInputSyntax(
                "<command=deleteviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point>>&<id=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("deleteviewereffect")] [Reflection.NameAttribute("deleteviewereffect")] DELETEVIEWEREFFECT,

            [CommandInputSyntax(
                "<command=getviewereffects>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getviewereffects")] [Reflection.NameAttribute("getviewereffects")] GETVIEWEREFFECTS,

            [CommandInputSyntax(
                "<command=setviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&effect=Look:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Look:<offset=<VECTOR3>>&effect=Look:<type=LookAt>&effect=Point:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Point:<offset=<VECTOR3>>&effect=Point:<type=PointAt>&effect=Beam:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Beam:<color=<VECTOR3>>&effect=Beam:<alpha=<FLOAT>>&effect=Beam:<duration=<FLOAT>>&effect=Beam:<offset=<VECTOR3>>&effect=Sphere:<color=<VECTOR3>>&effect=Sphere:<alpha=<FLOAT>>&effect=Sphere:<duration=<FLOAT>>&effect=Sphere:<offset=<VECTOR3>>&[id=<UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setviewereffect")] [Reflection.NameAttribute("setviewereffect")] SETVIEWEREFFECT,

            [CommandInputSyntax(
                "<command=ai>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<process|enable|disable|rebuild>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("ai")] [Reflection.NameAttribute("ai")] AI,

            [CommandInputSyntax(
                "<command=gettitles>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("gettitles")] [Reflection.NameAttribute("gettitles")] GETTITLES,

            [CommandInputSyntax(
                "<command=tag>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&action=<set|get>&action=set:<title=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("tag")] [Reflection.NameAttribute("tag")] TAG,

            [CommandInputSyntax(
                "<command=filter>&<group=<UUID|STRING>>&<password=<STRING>>&action=<set|get>&action=get:<type=<input|output>>&action=set:<input=<STRING>>&action=set:<output=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Filter)] [CorradeCommand("filter")] [Reflection.NameAttribute("filter")] FILTER,

            [CommandInputSyntax(
                "<command=run>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )
            ] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("run")] [Reflection.NameAttribute("run")] RUN,
            [CommandInputSyntax("<command=relax>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("relax")] [Reflection.NameAttribute("relax")] RELAX,
            [Reflection.NameAttribute("sift")] SIFT,

            [CommandInputSyntax(
                "<command=rlv>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable>>&[callback=<STRING>]")
            ] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("rlv")] [Reflection.NameAttribute("rlv")] RLV,

            [CommandInputSyntax(
                "<command=getinventorypath>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("getinventorypath")] [Reflection.NameAttribute("getinventorypath")] GETINVENTORYPATH,
            [Reflection.NameAttribute("committed")] COMMITTED,
            [Reflection.NameAttribute("credit")] CREDIT,
            [Reflection.NameAttribute("success")] SUCCESS,
            [Reflection.NameAttribute("transaction")] TRANSACTION,

            [CommandInputSyntax(
                "<command=getscriptdialogs>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getscriptdialogs")] [Reflection.NameAttribute("getscriptdialogs")] GETSCRIPTDIALOGS,

            [CommandInputSyntax(
                "<command=getscriptpermissionrequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getscriptpermissionrequests")] [Reflection.NameAttribute("getscriptpermissionrequests")] GETSCRIPTPERMISSIONREQUESTS,

            [CommandInputSyntax(
                "<command=getteleportlures>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("getteleportlures")] [Reflection.NameAttribute("getteleportlures")] GETTELEPORTLURES,

            [CommandInputSyntax(
                "<command=replytogroupinvite>&<group=<UUID|STRING>>&<password=<STRING>>&[action=<accept|decline>]&<session=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group | (ulong) Configuration.Permissions.Economy)] [CorradeCommand("replytogroupinvite")] [Reflection.NameAttribute("replytogroupinvite")] REPLYTOGROUPINVITE,

            [CommandInputSyntax(
                "<command=getgroupinvites>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupinvites")] [Reflection.NameAttribute("getgroupinvites")] GETGROUPINVITES,

            [CommandInputSyntax(
                "<command=getmemberroles>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getmemberroles")] [Reflection.NameAttribute("getmemberroles")] GETMEMBERROLES,

            [CommandInputSyntax(
                "<command=execute>&<group=<UUID|STRING>>&<password=<STRING>>&<file=<STRING>>&[parameter=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Execute)] [CorradeCommand("execute")] [Reflection.NameAttribute("execute")] EXECUTE,
            [Reflection.NameAttribute("parameter")] PARAMETER,
            [Reflection.NameAttribute("file")] FILE,

            [CommandInputSyntax(
                "<command=cache>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<purge|load|save>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("cache")] [Reflection.NameAttribute("cache")] CACHE,

            [CommandInputSyntax(
                "<command=getgridregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<GridRegion[,GridRegion...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getgridregiondata")] [Reflection.NameAttribute("getgridregiondata")] GETGRIDREGIONDATA,

            [CommandInputSyntax(
                "<command=getregionparcelsboundingbox>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getregionparcelsboundingbox")] [Reflection.NameAttribute("getregionparcelsboundingbox")] GETREGIONPARCELSBOUNDINGBOX,
            [Reflection.NameAttribute("pattern")] PATTERN,

            [CommandInputSyntax(
                "<command=searchinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[type=<AssetType>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("searchinventory")] [Reflection.NameAttribute("searchinventory")] SEARCHINVENTORY,

            [CommandInputSyntax(
                "<command=getterrainheight>&<group=<UUID|STRING>>&<password=<STRING>>&[southwest=<VECTOR>]&[northwest=<VECTOR>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getterrainheight")] [Reflection.NameAttribute("getterrainheight")] GETTERRAINHEIGHT,
            [Reflection.NameAttribute("northeast")] NORTHEAST,
            [Reflection.NameAttribute("southwest")] SOUTHWEST,

            [CommandInputSyntax(
                "<command=upload>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Clothing:[wear=<WearableType>]&type=Bodypart:[wear=<WearableType>]&<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask(
                    (ulong) Configuration.Permissions.Inventory | (ulong) Configuration.Permissions.Economy
                    )] [CorradeCommand("upload")] [Reflection.NameAttribute("upload")] UPLOAD,

            [CommandInputSyntax(
                "<command=download>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Texture:[format=<STRING>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact | (ulong) Configuration.Permissions.System
                    )] [CorradeCommand("download")] [Reflection.NameAttribute("download")] DOWNLOAD,

            [CommandInputSyntax(
                "<command=setparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR>]&[data=<Parcel[,Parcel...]>]&[region=<STRING>]&[callback=<STRING>]"
                )
            ] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setparceldata")] [Reflection.NameAttribute("setparceldata")] SETPARCELDATA,
            [Reflection.NameAttribute("new")] NEW,
            [Reflection.NameAttribute("old")] OLD,
            [Reflection.NameAttribute("aggressor")] AGGRESSOR,
            [Reflection.NameAttribute("magnitude")] MAGNITUDE,
            [Reflection.NameAttribute("time")] TIME,
            [Reflection.NameAttribute("victim")] VICTIM,

            [CommandInputSyntax(
                "<command=playgesture>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("playgesture")] [Reflection.NameAttribute("playgesture")] PLAYGESTURE,

            [CommandInputSyntax(
                "<command=jump>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("jump")] [Reflection.NameAttribute("jump")] JUMP,

            [CommandInputSyntax(
                "<command=crouch>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("crouch")] [Reflection.NameAttribute("crouch")] CROUCH,

            [CommandInputSyntax(
                "<command=turnto>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR3>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("turnto")] [Reflection.NameAttribute("turnto")] TURNTO,

            [CommandInputSyntax(
                "<command=nudge>&<group=<UUID|STRING>>&<password=<STRING>>&<direction=<left|right|up|down|back|forward>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("nudge")] [Reflection.NameAttribute("nudge")] NUDGE,

            [CommandInputSyntax(
                "<command=createnotecard>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[text=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("createnotecard")] [Reflection.NameAttribute("createnotecard")] CREATENOTECARD,
            [Reflection.NameAttribute("direction")] DIRECTION,
            [Reflection.NameAttribute("agent")] AGENT,

            [CommandInputSyntax(
                "<command=replytoinventoryoffer>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<accept|decline>>&<session=<UUID>>&[folder=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("replytoinventoryoffer")] [Reflection.NameAttribute("replytoinventoryoffer")] REPLYTOINVENTORYOFFER,

            [CommandInputSyntax(
                "<command=getinventoryoffers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("getinventoryoffers")] [Reflection.NameAttribute("getinventoryoffers")] GETINVENTORYOFFERS,

            [CommandInputSyntax(
                "<command=updateprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|remove|take>>&action=add:<entity=<UUID|STRING>>&action=remove:<entity=<UUID|STRING>>&action=take:<entity=<UUID|STRING>>&action=take:<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("updateprimitiveinventory")] [Reflection.NameAttribute("updateprimitiveinventory")] UPDATEPRIMITIVEINVENTORY,
            [CommandInputSyntax("<command=version>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.None)] [CorradeCommand("version")] [Reflection.NameAttribute("version")] VERSION,

            [CommandInputSyntax(
                "<command=playsound>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&<item=<UUID|STRING>>&[gain=<FLOAT>]&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("playsound")] [Reflection.NameAttribute("playsound")] PLAYSOUND,
            [Reflection.NameAttribute("gain")] GAIN,

            [CommandInputSyntax(
                "<command=getrolemembers>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getrolemembers")] [Reflection.NameAttribute("getrolemembers")] GETROLEMEMBERS,
            [Reflection.NameAttribute("status")] STATUS,

            [CommandInputSyntax(
                "<command=getmembers>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getmembers")] [Reflection.NameAttribute("getmembers")] GETMEMBERS,

            [CommandInputSyntax(
                "<command=replytoteleportlure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<session=<UUID>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("replytoteleportlure")] [Reflection.NameAttribute("replytoteleportlure")] REPLYTOTELEPORTLURE,
            [Reflection.NameAttribute("session")] SESSION,

            [CommandInputSyntax(
                "<command=replytoscriptpermissionrequest>&<group=<UUID|STRING>>&<password=<STRING>>&<task=<UUID>>&<item=<UUID>>&<permissions=<ScriptPermission>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("replytoscriptpermissionrequest")] [Reflection.NameAttribute("replytoscriptpermissionrequest")] REPLYTOSCRIPTPERMISSIONREQUEST,
            [Reflection.NameAttribute("task")] TASK,

            [CommandInputSyntax(
                "<command=getparcellist>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getparcellist")] [Reflection.NameAttribute("getparcellist")] GETPARCELLIST,

            [CommandInputSyntax(
                "<command=parcelrelease>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("parcelrelease")] [Reflection.NameAttribute("parcelrelease")] PARCELRELEASE,

            [CommandInputSyntax(
                "<command=parcelbuy>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[forgroup=<BOOL>]&[removecontribution=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land | (ulong) Configuration.Permissions.Economy)] [CorradeCommand("parcelbuy")] [Reflection.NameAttribute("parcelbuy")] PARCELBUY,
            [Reflection.NameAttribute("removecontribution")] REMOVECONTRIBUTION,
            [Reflection.NameAttribute("forgroup")] FORGROUP,

            [CommandInputSyntax(
                "<command=parceldeed>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("parceldeed")] [Reflection.NameAttribute("parceldeed")] PARCELDEED,

            [CommandInputSyntax(
                "<command=parcelreclaim>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("parcelreclaim")] [Reflection.NameAttribute("parcelreclaim")] PARCELRECLAIM,

            [CommandInputSyntax(
                "<command=unwear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("unwear")] [Reflection.NameAttribute("unwear")] UNWEAR,

            [CommandInputSyntax(
                "<command=wear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("wear")] [Reflection.NameAttribute("wear")] WEAR,
            [Reflection.NameAttribute("wearables")] WEARABLES,
            [CommandInputSyntax("<command=getwearables>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getwearables")] [Reflection.NameAttribute("getwearables")] GETWEARABLES,

            [CommandInputSyntax(
                "<command=changeappearance>&<group=<UUID|STRING>>&<password=<STRING>>&<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("changeappearance")] [Reflection.NameAttribute("changeappearance")] CHANGEAPPEARANCE,
            [Reflection.NameAttribute("folder")] FOLDER,
            [Reflection.NameAttribute("replace")] REPLACE,

            [CommandInputSyntax(
                "<command=setobjectrotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<rotation=<QUARTERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectrotation")] [Reflection.NameAttribute("setobjectrotation")] SETOBJECTROTATION,

            [CommandInputSyntax(
                "<command=setprimitivedescription>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<description=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivedescription")] [Reflection.NameAttribute("setprimitivedescription")] SETPRIMITIVEDESCRIPTION,

            [CommandInputSyntax(
                "<command=setprimitivename>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setprimitivename")] [Reflection.NameAttribute("setprimitivename")] SETPRIMITIVENAME,

            [CommandInputSyntax(
                "<command=setobjectposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectposition")] [Reflection.NameAttribute("setobjectposition")] SETOBJECTPOSITION,

            [CommandInputSyntax(
                "<command=setobjectsaleinfo>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<price=<INTEGER>>&<type=<SaleType>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectsaleinfo")] [Reflection.NameAttribute("setobjectsaleinfo")] SETOBJECTSALEINFO,

            [CommandInputSyntax(
                "<command=setobjectgroup>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectgroup")] [Reflection.NameAttribute("setobjectgroup")] SETOBJECTGROUP,

            [CommandInputSyntax(
                "<command=objectdeed>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("objectdeed")] [Reflection.NameAttribute("objectdeed")] OBJECTDEED,

            [CommandInputSyntax(
                "<command=setobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<permissions=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setobjectpermissions")] [Reflection.NameAttribute("setobjectpermissions")] SETOBJECTPERMISSIONS,
            [Reflection.NameAttribute("permissions")] PERMISSIONS,

            [CommandInputSyntax(
                "<command=getavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<region|parcel>>&entity=parcel:<position=<VECTOR2>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getavatarpositions")] [Reflection.NameAttribute("getavatarpositions")] GETAVATARPOSITIONS,
            [Reflection.NameAttribute("delay")] DELAY,
            [Reflection.NameAttribute("asset")] ASSET,

            [CommandInputSyntax(
                "<command=setregiondebug>&<group=<UUID|STRING>>&<password=<STRING>>&<scripts=<BOOL>>&<collisions=<BOOL>>&<physics=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setregiondebug")] [Reflection.NameAttribute("setregiondebug")] SETREGIONDEBUG,
            [Reflection.NameAttribute("scripts")] SCRIPTS,
            [Reflection.NameAttribute("collisions")] COLLISIONS,
            [Reflection.NameAttribute("physics")] PHYSICS,

            [CommandInputSyntax(
                "<command=getmapavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getmapavatarpositions")] [Reflection.NameAttribute("getmapavatarpositions")] GETMAPAVATARPOSITIONS,

            [CommandInputSyntax(
                "<command=mapfriend>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("mapfriend")] [Reflection.NameAttribute("mapfriend")] MAPFRIEND,

            [CommandInputSyntax(
                "<command=replytofriendshiprequest>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("replytofriendshiprequest")] [Reflection.NameAttribute("replytofriendshiprequest")] REPLYTOFRIENDSHIPREQUEST,

            [CommandInputSyntax(
                "<command=getfriendshiprequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("getfriendshiprequests")] [Reflection.NameAttribute("getfriendshiprequests")] GETFRIENDSHIPREQUESTS,

            [CommandInputSyntax(
                "<command=grantfriendrights>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<rights=<FriendRights>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("grantfriendrights")] [Reflection.NameAttribute("grantfriendrights")] GRANTFRIENDRIGHTS,
            [Reflection.NameAttribute("rights")] RIGHTS,

            [CommandInputSyntax("<command=getfriendslist>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("getfriendslist")] [Reflection.NameAttribute("getfriendslist")] GETFRIENDSLIST,

            [CommandInputSyntax(
                "<command=terminatefriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("terminatefriendship")] [Reflection.NameAttribute("terminatefriendship")] TERMINATEFRIENDSHIP,

            [CommandInputSyntax(
                "<command=offerfriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("offerfriendship")] [Reflection.NameAttribute("offerfriendship")] OFFERFRIENDSHIP,

            [CommandInputSyntax(
                "<command=getfrienddata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<FriendInfo[,FriendInfo...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Friendship)] [CorradeCommand("getfrienddata")] [Reflection.NameAttribute("getfrienddata")] GETFRIENDDATA,
            [Reflection.NameAttribute("days")] DAYS,
            [Reflection.NameAttribute("interval")] INTERVAL,

            [CommandInputSyntax(
                "<command=getgroupaccountsummarydata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<data=<GroupAccountSummary[,GroupAccountSummary...]>>&<days=<INTEGER>>&<interval=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupaccountsummarydata")] [Reflection.NameAttribute("getgroupaccountsummarydata")] GETGROUPACCOUNTSUMMARYDATA,

            [CommandInputSyntax(
                "<command=getselfdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager[,AgentManager...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getselfdata")] [Reflection.NameAttribute("getselfdata")] GETSELFDATA,

            [CommandInputSyntax(
                "<command=deleteclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("deleteclassified")] [Reflection.NameAttribute("deleteclassified")] DELETECLASSIFIED,

            [CommandInputSyntax(
                "<command=addclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<price=<INTEGER>>&<type=<Any|Shopping|LandRental|PropertyRental|SpecialAttraction|NewProducts|Employment|Wanted|Service|Personal>>&[item=<UUID|STRING>]&[description=<STRING>]&[renew=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask(
                    (ulong) Configuration.Permissions.Grooming | (ulong) Configuration.Permissions.Economy)
                   ] [CorradeCommand("addclassified")] [Reflection.NameAttribute("addclassified")] ADDCLASSIFIED,
            [Reflection.NameAttribute("price")] PRICE,
            [Reflection.NameAttribute("renew")] RENEW,
            [CommandInputSyntax("<command=logout>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.System)] [CorradeCommand("logout")] [Reflection.NameAttribute("logout")] LOGOUT,

            [CommandInputSyntax(
                "<command=displayname>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<get|set>>&action=set:<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("displayname")] [Reflection.NameAttribute("displayname")] DISPLAYNAME,

            [CommandInputSyntax(
                "<command=returnprimitives>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<entity=<parcel|estate>>&<type=<Owner|Group|Other|Sell|ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers>>&type=Owner|GroupUUID|Other|Sell:[position=<VECTOR2>]&type=ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers:[all=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("returnprimitives")] [Reflection.NameAttribute("returnprimitives")] RETURNPRIMITIVES,

            [CommandInputSyntax(
                "<command=getgroupdata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[target=<STRING|UUID>]&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getgroupdata")] [Reflection.NameAttribute("getgroupdata")] GETGROUPDATA,

            [CommandInputSyntax(
                "<command=getavatardata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<Avatar[,Avatar...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getavatardata")] [Reflection.NameAttribute("getavatardata")] GETAVATARDATA,

            [CommandInputSyntax(
                "<command=getprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitiveinventory")] [Reflection.NameAttribute("getprimitiveinventory")] GETPRIMITIVEINVENTORY,

            [CommandInputSyntax(
                "<command=getinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("getinventorydata")] [Reflection.NameAttribute("getinventorydata")] GETINVENTORYDATA,

            [CommandInputSyntax(
                "<command=getprimitiveinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitiveinventorydata")] [Reflection.NameAttribute("getprimitiveinventorydata")] GETPRIMITIVEINVENTORYDATA,

            [CommandInputSyntax(
                "<command=getscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getscriptrunning")] [Reflection.NameAttribute("getscriptrunning")] GETSCRIPTRUNNING,

            [CommandInputSyntax(
                "<command=setscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("setscriptrunning")] [Reflection.NameAttribute("setscriptrunning")] SETSCRIPTRUNNING,

            [CommandInputSyntax(
                "<command=derez>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[folder=<STRING|UUID>]&[type=<DeRezDestination>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("derez")] [Reflection.NameAttribute("derez")] DEREZ,

            [CommandInputSyntax(
                "<command=getparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Parcel[,Parcel...]>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getparceldata")] [Reflection.NameAttribute("getparceldata")] GETPARCELDATA,

            [CommandInputSyntax(
                "<command=rez>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<item=<UUID|STRING>&[rotation=<QUARTERNION>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("rez")] [Reflection.NameAttribute("rez")] REZ,
            [Reflection.NameAttribute("rotation")] ROTATION,
            [Reflection.NameAttribute("index")] INDEX,

            [CommandInputSyntax(
                "<command=replytoscriptdialog>&<group=<UUID|STRING>>&<password=<STRING>>&<channel=<INTEGER>>&<index=<INTEGER>&<button=<STRING>>&<item=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("replytoscriptdialog")] [Reflection.NameAttribute("replytoscriptdialog")] REPLYTOSCRIPTDIALOG,
            [Reflection.NameAttribute("owner")] OWNER,
            [Reflection.NameAttribute("button")] BUTTON,

            [CommandInputSyntax("<command=getanimations>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")
            ] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getanimations")] [Reflection.NameAttribute("getanimations")] GETANIMATIONS,

            [CommandInputSyntax(
                "<command=animation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("animation")] [Reflection.NameAttribute("animation")] ANIMATION,

            [CommandInputSyntax(
                "<command=setestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&<action=<add|remove>>&type=ban|manager|user,action=add|remove:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&type=group,action=add|remove:<target=<STRING|UUID>>&[all=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("setestatelist")] [Reflection.NameAttribute("setestatelist")] SETESTATELIST,

            [CommandInputSyntax(
                "<command=getestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getestatelist")] [Reflection.NameAttribute("getestatelist")] GETESTATELIST,
            [Reflection.NameAttribute("all")] ALL,

            [CommandInputSyntax(
                "<command=getregiontop>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<scripts|colliders>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getregiontop")] [Reflection.NameAttribute("getregiontop")] GETREGIONTOP,

            [CommandInputSyntax(
                "<command=restartregion>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<scripts|colliders>>&[delay=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("restartregion")] [Reflection.NameAttribute("restartregion")] RESTARTREGION,

            [CommandInputSyntax(
                "<command=directorysearch>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<classified|event|group|land|people|places>>&type=classified:<data=<Classified[,Classified...]>>&type=classified:<name=<STRING>>&type=event:<data=<EventsSearchData[,EventSearchData...]>>&type=event:<name=<STRING>>&type=group:<data=<GroupSearchData[,GroupSearchData...]>>&type=land:<data=<DirectoryParcel[,DirectoryParcel...]>>&type=people:<data=<AgentSearchData[,AgentSearchData...]>>&type=places:<data=<DirectoryParcel[,DirectoryParcel...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Directory)] [CorradeCommand("directorysearch")] [Reflection.NameAttribute("directorysearch")] DIRECTORYSEARCH,

            [CommandInputSyntax(
                "<command=getprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprofiledata")] [Reflection.NameAttribute("getprofiledata")] GETPROFILEDATA,

            [CommandInputSyntax(
                "<command=getparticlesystem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getparticlesystem")] [Reflection.NameAttribute("getparticlesystem")] GETPARTICLESYSTEM,
            [Reflection.NameAttribute("data")] DATA,
            [Reflection.NameAttribute("range")] RANGE,
            [Reflection.NameAttribute("balance")] BALANCE,
            [Reflection.NameAttribute("key")] KEY,
            [Reflection.NameAttribute("value")] VALUE,

            [CommandInputSyntax(
                "<command=database>&<group=<UUID|STRING>>&<password=<STRING>>&<SQL=<string>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Database)] [CorradeCommand("database")] [Reflection.NameAttribute("database")] DATABASE,

            [Reflection.NameAttribute("text")] TEXT,
            [Reflection.NameAttribute("quorum")] QUORUM,
            [Reflection.NameAttribute("majority")] MAJORITY,

            [CommandInputSyntax(
                "<command=startproposal>&<group=<UUID|STRING>>&<password=<STRING>>&<duration=<INTEGER>>&<majority=<FLOAT>>&<quorum=<INTEGER>>&<text=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("startproposal")] [Reflection.NameAttribute("startproposal")] STARTPROPOSAL,
            [Reflection.NameAttribute("duration")] DURATION,
            [Reflection.NameAttribute("action")] ACTION,

            [CommandInputSyntax(
                "<command=deletefromrole>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("deletefromrole")] [Reflection.NameAttribute("deletefromrole")] DELETEFROMROLE,

            [CommandInputSyntax(
                "<command=addtorole>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("addtorole")] [Reflection.NameAttribute("addtorole")] ADDTOROLE,

            [CommandInputSyntax(
                "<command=leave>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("leave")] [Reflection.NameAttribute("leave")] LEAVE,

            [CommandInputSyntax(
                "<command=setgroupdata>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<data=<Group[,GroupUUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("setgroupdata")] [Reflection.NameAttribute("setgroupdata")] SETGROUPDATA,

            [CommandInputSyntax(
                "<command=eject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("eject")] [Reflection.NameAttribute("eject")] EJECT,

            [CommandInputSyntax(
                "<command=invite>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[role=<UUID[,STRING...]>]&[verify=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("invite")] [Reflection.NameAttribute("invite")] INVITE,

            [CommandInputSyntax(
                "<command=join>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group | (ulong) Configuration.Permissions.Economy)] [CorradeCommand("join")] [Reflection.NameAttribute("join")] JOIN,
            [Reflection.NameAttribute("callback")] CALLBACK,
            [Reflection.NameAttribute("group")] GROUP,
            [Reflection.NameAttribute("password")] PASSWORD,
            [Reflection.NameAttribute("firstname")] FIRSTNAME,
            [Reflection.NameAttribute("lastname")] LASTNAME,
            [Reflection.NameAttribute("command")] COMMAND,
            [Reflection.NameAttribute("role")] ROLE,
            [Reflection.NameAttribute("title")] TITLE,

            [CommandInputSyntax(
                "<command=tell>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<local|group|avatar|estate|region>>&entity=local:<type=<Normal|Whisper|Shout>>&entity=local,type=Normal|Whisper|Shout:[channel=<INTEGER>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=group:[target=<UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Talk)] [CorradeCommand("tell")] [Reflection.NameAttribute("tell")] TELL,

            [CommandInputSyntax(
                "<command=notice>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<action=<send|list|accept|decline>>&action=send:<message=<STRING>>&action=send:[subject=<STRING>]&action=send:[item=<UUID|STRING>]&action=send:[permissions=<STRING>]&action=accept|decline:<<notice=<UUID>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<session=<UUID>>&<folder=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("notice")] [Reflection.NameAttribute("notice")] NOTICE,
            [Reflection.NameAttribute("message")] MESSAGE,
            [Reflection.NameAttribute("subject")] SUBJECT,
            [Reflection.NameAttribute("item")] ITEM,

            [CommandInputSyntax(
                "<command=pay>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<avatar|object|group>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=object:<target=<UUID>>&[reason=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Economy)] [CorradeCommand("pay")] [Reflection.NameAttribute("pay")] PAY,
            [Reflection.NameAttribute("amount")] AMOUNT,
            [Reflection.NameAttribute("target")] TARGET,
            [Reflection.NameAttribute("reason")] REASON,
            [CommandInputSyntax("<command=getbalance>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Economy)] [CorradeCommand("getbalance")] [Reflection.NameAttribute("getbalance")] GETBALANCE,

            [CommandInputSyntax(
                "<command=teleport>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("teleport")] [Reflection.NameAttribute("teleport")] TELEPORT,
            [Reflection.NameAttribute("region")] REGION,
            [Reflection.NameAttribute("position")] POSITION,

            [CommandInputSyntax(
                "<command=getregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Simulator[,Simulator...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getregiondata")] [Reflection.NameAttribute("getregiondata")] GETREGIONDATA,

            [CommandInputSyntax(
                "<command=sit>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("sit")] [Reflection.NameAttribute("sit")] SIT,
            [CommandInputSyntax("<command=stand>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("stand")] [Reflection.NameAttribute("stand")] STAND,

            [CommandInputSyntax(
                "<command=parceleject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[ban=<BOOL>]&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("parceleject")] [Reflection.NameAttribute("parceleject")] PARCELEJECT,

            [CommandInputSyntax(
                "<command=creategroup>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<data=<Group[,GroupUUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group | (ulong) Configuration.Permissions.Economy)] [CorradeCommand("creategroup")] [Reflection.NameAttribute("creategroup")] CREATEGROUP,

            [CommandInputSyntax(
                "<command=parcelfreeze>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[freeze=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("parcelfreeze")] [Reflection.NameAttribute("parcelfreeze")] PARCELFREEZE,

            [CommandInputSyntax(
                "<command=createrole>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<role=<STRING>>&[powers=<GroupPowers[,GroupPowers...]>]&[title=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("createrole")] [Reflection.NameAttribute("createrole")] CREATEROLE,

            [CommandInputSyntax(
                "<command=deleterole>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("deleterole")] [Reflection.NameAttribute("deleterole")] DELETEROLE,

            [CommandInputSyntax(
                "<command=getrolesmembers>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getrolesmembers")] [Reflection.NameAttribute("getrolesmembers")] GETROLESMEMBERS,

            [CommandInputSyntax(
                "<command=getroles>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getroles")] [Reflection.NameAttribute("getroles")] GETROLES,

            [CommandInputSyntax(
                "<command=getrolepowers>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("getrolepowers")] [Reflection.NameAttribute("getrolepowers")] GETROLEPOWERS,
            [Reflection.NameAttribute("powers")] POWERS,

            [CommandInputSyntax(
                "<command=lure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("lure")] [Reflection.NameAttribute("lure")] LURE,
            [Reflection.NameAttribute("URL")] URL,
            [CommandInputSyntax("<command=sethome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("sethome")] [Reflection.NameAttribute("sethome")] SETHOME,
            [CommandInputSyntax("<command=gohome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("gohome")] [Reflection.NameAttribute("gohome")] GOHOME,

            [CommandInputSyntax(
                "<command=setprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("setprofiledata")] [Reflection.NameAttribute("setprofiledata")] SETPROFILEDATA,

            [CommandInputSyntax(
                "<command=give>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<entity=<avatar|object>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=avatar:<item=<UUID|STRING>&entity=object:<item=<UUID|STRING>&entity=object:[range=<FLOAT>]&entity=object:<target=<UUID|STRING>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("give")] [Reflection.NameAttribute("give")] GIVE,

            [CommandInputSyntax(
                "<command=deleteitem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("deleteitem")] [Reflection.NameAttribute("deleteitem")] DELETEITEM,
            [CommandInputSyntax("<command=emptytrash>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Inventory)] [CorradeCommand("emptytrash")] [Reflection.NameAttribute("emptytrash")] EMPTYTRASH,

            [CommandInputSyntax(
                "<command=fly>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("fly")] [Reflection.NameAttribute("fly")] FLY,

            [CommandInputSyntax(
                "<command=addpick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[description=<STRING>]&[item=<STRING|UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("addpick")] [Reflection.NameAttribute("addpick")] ADDPICK,

            [CommandInputSyntax(
                "<command=deletepick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("deletepick")] [Reflection.NameAttribute("deletepick")] DELETEPICK,

            [CommandInputSyntax(
                "<command=touch>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("touch")] [Reflection.NameAttribute("touch")] TOUCH,

            [CommandInputSyntax(
                "<command=moderate>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<type=<voice|text>>&<silence=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Group)] [CorradeCommand("moderate")] [Reflection.NameAttribute("moderate")] MODERATE,
            [Reflection.NameAttribute("type")] TYPE,
            [Reflection.NameAttribute("silence")] SILENCE,
            [Reflection.NameAttribute("freeze")] FREEZE,
            [CommandInputSyntax("<command=rebake>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("rebake")] [Reflection.NameAttribute("rebake")] REBAKE,

            [CommandInputSyntax("<command=getattachments>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("getattachments")] [Reflection.NameAttribute("getattachments")] GETATTACHMENTS,

            [CommandInputSyntax(
                "<command=attach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<AttachmentPoint<,<UUID|STRING>>[,AttachmentPoint<,<UUID|STRING>>...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("attach")] [Reflection.NameAttribute("attach")] ATTACH,
            [Reflection.NameAttribute("attachments")] ATTACHMENTS,

            [CommandInputSyntax(
                "<command=detach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<STRING[,UUID...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("detach")] [Reflection.NameAttribute("detach")] DETACH,

            [CommandInputSyntax(
                "<command=getprimitiveowners>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("getprimitiveowners")] [Reflection.NameAttribute("getprimitiveowners")] GETPRIMITIVEOWNERS,
            [Reflection.NameAttribute("entity")] ENTITY,
            [Reflection.NameAttribute("channel")] CHANNEL,
            [Reflection.NameAttribute("name")] NAME,
            [Reflection.NameAttribute("description")] DESCRIPTION,

            [CommandInputSyntax(
                "<command=getprimitivedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<Primitive[,Primitive...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Interact)] [CorradeCommand("getprimitivedata")] [Reflection.NameAttribute("getprimitivedata")] GETPRIMITIVEDATA,

            [CommandInputSyntax(
                "<command=activate>&<group=<UUID|STRING>>&[target=<UUID>]&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Grooming)] [CorradeCommand("activate")] [Reflection.NameAttribute("activate")] ACTIVATE,

            [CommandInputSyntax(
                "<command=autopilot>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Movement)] [CorradeCommand("autopilot")] [Reflection.NameAttribute("autopilot")] AUTOPILOT,

            [CommandInputSyntax(
                "<command=mute>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<mute|unmute>>&action=mute:<name=<STRING>&target=<UUID>>&action=unmute:<name=<STRING>|target=<UUID>>&action=mute:[type=MuteType]&action=mute:[flags=MuteFlags]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Mute)] [CorradeCommand("mute")] [Reflection.NameAttribute("mute")] MUTE,

            [CommandInputSyntax("<command=getmutes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((ulong) Configuration.Permissions.Mute)] [CorradeCommand("getmutes")] [Reflection.NameAttribute("getmutes")] GETMUTES,

            [CommandInputSyntax(
                "<command=notify>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|set|remove|list|clear|purge>>&action=add|set|remove|clear:<type=<STRING[,STRING...]>>&action=add|set|remove:<URL=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Notifications)] [CorradeCommand("notify")] [Reflection.NameAttribute("notify")] NOTIFY,
            [Reflection.NameAttribute("source")] SOURCE,
            [Reflection.NameAttribute("effect")] EFFECT,
            [Reflection.NameAttribute("id")] ID,

            [CommandInputSyntax(
                "<command=terrain>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<set|get>>&action=set:<data=<STRING>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((ulong) Configuration.Permissions.Land)] [CorradeCommand("terrain")] [Reflection.NameAttribute("terrain")] TERRAIN,
            [Reflection.NameAttribute("output")] OUTPUT,
            [Reflection.NameAttribute("input")] INPUT
        }

        /// <summary>
        ///     The permission mask of a command.
        /// </summary>
        private class CommandPermissionMaskAttribute : Attribute
        {
            public CommandPermissionMaskAttribute(ulong permissionMask)
            {
                PermissionMask = permissionMask;
            }

            public ulong PermissionMask { get; }
        }

        private class CorradeCommandAttribute : Attribute
        {
            public CorradeCommandAttribute(string command)
            {
                CorradeCommand = corradeCommands[command];
            }

            public Action<CorradeCommandParameters, Dictionary<string, string>> CorradeCommand { get; }
        }

        private class RLVBehaviourAttribute : Attribute
        {
            public RLVBehaviourAttribute(string behaviour)
            {
                RLVBehaviour = rlvBehaviours[behaviour];
            }

            public Action<string, RLVRule, UUID> RLVBehaviour { get; }
        }

        /// <summary>
        ///     The syntax for a command.
        /// </summary>
        private class CommandInputSyntaxAttribute : Attribute
        {
            public CommandInputSyntaxAttribute(string syntax)
            {
                Syntax = syntax;
            }

            public string Syntax { get; }
        }

        /// <summary>
        ///     A structure for script permission requests.
        /// </summary>
        private struct ScriptPermissionRequest
        {
            public Agent Agent;
            [Reflection.NameAttribute("item")] public UUID Item;
            [Reflection.NameAttribute("name")] public string Name;
            [Reflection.NameAttribute("permission")] public ScriptPermission Permission;
            [Reflection.NameAttribute("region")] public string Region;
            [Reflection.NameAttribute("task")] public UUID Task;
        }

        /// <summary>
        ///     A structure to track Sphere effects.
        /// </summary>
        private struct SphereEffect
        {
            [Reflection.NameAttribute("alpha")] public float Alpha;
            [Reflection.NameAttribute("color")] public Vector3 Color;
            [Reflection.NameAttribute("duration")] public float Duration;
            [Reflection.NameAttribute("effect")] public UUID Effect;
            [Reflection.NameAttribute("offset")] public Vector3d Offset;
            [Reflection.NameAttribute("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     A structure for teleport lures.
        /// </summary>
        private struct TeleportLure
        {
            public Agent Agent;
            public UUID Session;
        }

        /// <summary>
        ///     Various types.
        /// </summary>
        private enum Type : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("text")] TEXT,
            [Reflection.NameAttribute("voice")] VOICE,
            [Reflection.NameAttribute("scripts")] SCRIPTS,
            [Reflection.NameAttribute("colliders")] COLLIDERS,
            [Reflection.NameAttribute("ban")] BAN,
            [Reflection.NameAttribute("group")] GROUP,
            [Reflection.NameAttribute("user")] USER,
            [Reflection.NameAttribute("manager")] MANAGER,
            [Reflection.NameAttribute("classified")] CLASSIFIED,
            [Reflection.NameAttribute("event")] EVENT,
            [Reflection.NameAttribute("land")] LAND,
            [Reflection.NameAttribute("people")] PEOPLE,
            [Reflection.NameAttribute("place")] PLACE,
            [Reflection.NameAttribute("input")] INPUT,
            [Reflection.NameAttribute("output")] OUTPUT,
            [Reflection.NameAttribute("slot")] SLOT,
            [Reflection.NameAttribute("name")] NAME,
            [Reflection.NameAttribute("UUID")] UUID,
            [Reflection.NameAttribute("xml")] XML,
            [Reflection.NameAttribute("zip")] ZIP
        }

        /// <summary>
        ///     Possible viewer effects.
        /// </summary>
        private enum ViewerEffectType : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [Reflection.NameAttribute("look")] LOOK,
            [Reflection.NameAttribute("point")] POINT,
            [Reflection.NameAttribute("sphere")] SPHERE,
            [Reflection.NameAttribute("beam")] BEAM
        }

        #region Conference State

        #endregion

        #region NON PORTABLE HELPERS

        /// <summary>
        ///     Encrypts a string given a key and initialization vector.
        /// </summary>
        /// <param name="data">the string to encrypt</param>
        /// <param name="Key">the key</param>
        /// <param name="IV">the initialization bector</param>
        /// <returns>Base64 encoded encrypted data</returns>
        private static string wasAESEncrypt(string data, byte[] Key, byte[] IV)
        {
            byte[] encryptedData;
            using (var rijdanelManaged = new RijndaelManaged())
            {
                //  FIPS-197 / CBC
                rijdanelManaged.BlockSize = 128;
                rijdanelManaged.Mode = CipherMode.CBC;

                rijdanelManaged.Key = Key;
                rijdanelManaged.IV = IV;

                var encryptor = rijdanelManaged.CreateEncryptor(rijdanelManaged.Key, rijdanelManaged.IV);

                using (var memoryStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write)
                        )
                    {
                        using (var streamWriter = new StreamWriter(cryptoStream))
                        {
                            streamWriter.Write(data);
                            streamWriter.Flush();
                        }
                        encryptedData = memoryStream.ToArray();
                    }
                }
            }
            return Convert.ToBase64String(encryptedData);
        }

        /// <summary>
        ///     Decrypts a Base64 encoded string using AES with a given key and initialization vector.
        /// </summary>
        /// <param name="data">a Base64 encoded string of the data to decrypt</param>
        /// <param name="Key">the key</param>
        /// <param name="IV">the initialization vector</param>
        /// <returns>the decrypted data</returns>
        private static string wasAESDecrypt(string data, byte[] Key, byte[] IV)
        {
            string plaintext;
            using (var rijdanelManaged = new RijndaelManaged())
            {
                //  FIPS-197 / CBC
                rijdanelManaged.BlockSize = 128;
                rijdanelManaged.Mode = CipherMode.CBC;

                rijdanelManaged.Key = Key;
                rijdanelManaged.IV = IV;

                var decryptor = rijdanelManaged.CreateDecryptor(rijdanelManaged.Key, rijdanelManaged.IV);

                using (var memoryStream = new MemoryStream(Convert.FromBase64String(data)))
                {
                    using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
                    {
                        using (var streamReader = new StreamReader(cryptoStream))
                        {
                            plaintext = streamReader.ReadToEnd();
                        }
                    }
                }
            }
            return plaintext;
        }

        #endregion

        #region RLV STRUCTURES

        /// <summary>
        ///     Holds all the active RLV rules.
        /// </summary>
        private static readonly HashSet<RLVRule> RLVRules = new HashSet<RLVRule>();

        /// <summary>
        ///     Locks down RLV for linear concurrent access.
        /// </summary>
        private static readonly object RLVRulesLock = new object();

        /// <summary>
        ///     RLV Wearables.
        /// </summary>
        private static readonly List<RLVWearable> RLVWearables = new List<RLVWearable>
        {
            new RLVWearable {Name = @"gloves", WearableType = WearableType.Gloves},
            new RLVWearable {Name = @"jacket", WearableType = WearableType.Jacket},
            new RLVWearable {Name = @"pants", WearableType = WearableType.Pants},
            new RLVWearable {Name = @"shirt", WearableType = WearableType.Shirt},
            new RLVWearable {Name = @"shoes", WearableType = WearableType.Shoes},
            new RLVWearable {Name = @"skirt", WearableType = WearableType.Skirt},
            new RLVWearable {Name = @"socks", WearableType = WearableType.Socks},
            new RLVWearable {Name = @"underpants", WearableType = WearableType.Underpants},
            new RLVWearable {Name = @"undershirt", WearableType = WearableType.Undershirt},
            new RLVWearable {Name = @"skin", WearableType = WearableType.Skin},
            new RLVWearable {Name = @"eyes", WearableType = WearableType.Eyes},
            new RLVWearable {Name = @"hair", WearableType = WearableType.Hair},
            new RLVWearable {Name = @"shape", WearableType = WearableType.Shape},
            new RLVWearable {Name = @"alpha", WearableType = WearableType.Alpha},
            new RLVWearable {Name = @"tattoo", WearableType = WearableType.Tattoo},
            new RLVWearable {Name = @"physics", WearableType = WearableType.Physics}
        };

        /// <summary>
        ///     RLV Attachments.
        /// </summary>
        private static readonly List<RLVAttachment> RLVAttachments = new List<RLVAttachment>
        {
            new RLVAttachment {Name = @"none", AttachmentPoint = AttachmentPoint.Default},
            new RLVAttachment {Name = @"chest", AttachmentPoint = AttachmentPoint.Chest},
            new RLVAttachment {Name = @"skull", AttachmentPoint = AttachmentPoint.Skull},
            new RLVAttachment {Name = @"left shoulder", AttachmentPoint = AttachmentPoint.LeftShoulder},
            new RLVAttachment {Name = @"right shoulder", AttachmentPoint = AttachmentPoint.RightShoulder},
            new RLVAttachment {Name = @"left hand", AttachmentPoint = AttachmentPoint.LeftHand},
            new RLVAttachment {Name = @"right hand", AttachmentPoint = AttachmentPoint.RightHand},
            new RLVAttachment {Name = @"left foot", AttachmentPoint = AttachmentPoint.LeftFoot},
            new RLVAttachment {Name = @"right foot", AttachmentPoint = AttachmentPoint.RightFoot},
            new RLVAttachment {Name = @"spine", AttachmentPoint = AttachmentPoint.Spine},
            new RLVAttachment {Name = @"pelvis", AttachmentPoint = AttachmentPoint.Pelvis},
            new RLVAttachment {Name = @"mouth", AttachmentPoint = AttachmentPoint.Mouth},
            new RLVAttachment {Name = @"chin", AttachmentPoint = AttachmentPoint.Chin},
            new RLVAttachment {Name = @"left ear", AttachmentPoint = AttachmentPoint.LeftEar},
            new RLVAttachment {Name = @"right ear", AttachmentPoint = AttachmentPoint.RightEar},
            new RLVAttachment {Name = @"left eyeball", AttachmentPoint = AttachmentPoint.LeftEyeball},
            new RLVAttachment {Name = @"right eyeball", AttachmentPoint = AttachmentPoint.RightEyeball},
            new RLVAttachment {Name = @"nose", AttachmentPoint = AttachmentPoint.Nose},
            new RLVAttachment {Name = @"r upper arm", AttachmentPoint = AttachmentPoint.RightUpperArm},
            new RLVAttachment {Name = @"r forearm", AttachmentPoint = AttachmentPoint.RightForearm},
            new RLVAttachment {Name = @"l upper arm", AttachmentPoint = AttachmentPoint.LeftUpperArm},
            new RLVAttachment {Name = @"l forearm", AttachmentPoint = AttachmentPoint.LeftForearm},
            new RLVAttachment {Name = @"right hip", AttachmentPoint = AttachmentPoint.RightHip},
            new RLVAttachment {Name = @"r upper leg", AttachmentPoint = AttachmentPoint.RightUpperLeg},
            new RLVAttachment {Name = @"r lower leg", AttachmentPoint = AttachmentPoint.RightLowerLeg},
            new RLVAttachment {Name = @"left hip", AttachmentPoint = AttachmentPoint.LeftHip},
            new RLVAttachment {Name = @"l upper leg", AttachmentPoint = AttachmentPoint.LeftUpperLeg},
            new RLVAttachment {Name = @"l lower leg", AttachmentPoint = AttachmentPoint.LeftLowerLeg},
            new RLVAttachment {Name = @"stomach", AttachmentPoint = AttachmentPoint.Stomach},
            new RLVAttachment {Name = @"left pec", AttachmentPoint = AttachmentPoint.LeftPec},
            new RLVAttachment {Name = @"right pec", AttachmentPoint = AttachmentPoint.RightPec},
            new RLVAttachment {Name = @"center 2", AttachmentPoint = AttachmentPoint.HUDCenter2},
            new RLVAttachment {Name = @"top right", AttachmentPoint = AttachmentPoint.HUDTopRight},
            new RLVAttachment {Name = @"top", AttachmentPoint = AttachmentPoint.HUDTop},
            new RLVAttachment {Name = @"top left", AttachmentPoint = AttachmentPoint.HUDTopLeft},
            new RLVAttachment {Name = @"center", AttachmentPoint = AttachmentPoint.HUDCenter},
            new RLVAttachment {Name = @"bottom left", AttachmentPoint = AttachmentPoint.HUDBottomLeft},
            new RLVAttachment {Name = @"bottom", AttachmentPoint = AttachmentPoint.HUDBottom},
            new RLVAttachment {Name = @"bottom right", AttachmentPoint = AttachmentPoint.HUDBottomRight},
            new RLVAttachment {Name = @"neck", AttachmentPoint = AttachmentPoint.Neck},
            new RLVAttachment {Name = @"root", AttachmentPoint = AttachmentPoint.Root}
        };

        /// <summary>
        ///     RLV attachment structure.
        /// </summary>
        private struct RLVAttachment
        {
            public AttachmentPoint AttachmentPoint;
            public string Name;
        }

        /// <summary>
        ///     Enumeration for supported RLV commands.
        /// </summary>
        private enum RLVBehaviour : uint
        {
            [Reflection.NameAttribute("none")] NONE = 0,
            [RLVBehaviour("version")] [Reflection.NameAttribute("version")] VERSION,
            [RLVBehaviour("versionnew")] [Reflection.NameAttribute("versionnew")] VERSIONNEW,
            [RLVBehaviour("versionnum")] [Reflection.NameAttribute("versionnum")] VERSIONNUM,
            [RLVBehaviour("getgroup")] [Reflection.NameAttribute("getgroup")] GETGROUP,
            [RLVBehaviour("setgroup")] [Reflection.NameAttribute("setgroup")] SETGROUP,
            [RLVBehaviour("getsitid")] [Reflection.NameAttribute("getsitid")] GETSITID,
            [RLVBehaviour("getstatusall")] [Reflection.NameAttribute("getstatusall")] GETSTATUSALL,
            [RLVBehaviour("getstatus")] [Reflection.NameAttribute("getstatus")] GETSTATUS,
            [RLVBehaviour("sit")] [Reflection.NameAttribute("sit")] SIT,
            [RLVBehaviour("unsit")] [Reflection.NameAttribute("unsit")] UNSIT,
            [RLVBehaviour("setrot")] [Reflection.NameAttribute("setrot")] SETROT,
            [RLVBehaviour("tpto")] [Reflection.NameAttribute("tpto")] TPTO,
            [RLVBehaviour("getoutfit")] [Reflection.NameAttribute("getoutfit")] GETOUTFIT,
            [RLVBehaviour("getattach")] [Reflection.NameAttribute("getattach")] GETATTACH,
            [RLVBehaviour("remattach")] [Reflection.NameAttribute("remattach")] REMATTACH,
            [RLVBehaviour("detach")] [Reflection.NameAttribute("detach")] DETACH,
            [RLVBehaviour("detachme")] [Reflection.NameAttribute("detachme")] DETACHME,
            [RLVBehaviour("remoutfit")] [Reflection.NameAttribute("remoutfit")] REMOUTFIT,
            [RLVBehaviour("attach")] [Reflection.NameAttribute("attach")] ATTACH,
            [RLVBehaviour("attachoverorreplace")] [Reflection.NameAttribute("attachoverorreplace")] ATTACHOVERORREPLACE,
            [RLVBehaviour("attachover")] [Reflection.NameAttribute("attachover")] ATTACHOVER,
            [RLVBehaviour("getinv")] [Reflection.NameAttribute("getinv")] GETINV,
            [RLVBehaviour("getinvworn")] [Reflection.NameAttribute("getinvworn")] GETINVWORN,
            [RLVBehaviour("getpath")] [Reflection.NameAttribute("getpath")] GETPATH,
            [RLVBehaviour("getpathnew")] [Reflection.NameAttribute("getpathnew")] GETPATHNEW,
            [RLVBehaviour("findfolder")] [Reflection.NameAttribute("findfolder")] FINDFOLDER,
            [RLVBehaviour("clear")] [Reflection.NameAttribute("clear")] CLEAR,
            [Reflection.NameAttribute("accepttp")] ACCEPTTP,
            [Reflection.NameAttribute("acceptpermission")] ACCEPTPERMISSION
        }

        public struct RLVRule
        {
            public string Behaviour;
            public UUID ObjectUUID;
            public string Option;
            public string Param;
        }

        /// <summary>
        ///     RLV wearable structure.
        /// </summary>
        private struct RLVWearable
        {
            public string Name;
            public WearableType WearableType;
        }

        /// <summary>
        ///     Structure for RLV constants.
        /// </summary>
        private struct RLV_CONSTANTS
        {
            public const string COMMAND_OPERATOR = @"@";
            public const string VIEWER = @"RestrainedLife viewer";
            public const string SHORT_VERSION = @"1.23";
            public const string LONG_VERSION = @"1230100";
            public const string FORCE = @"force";
            public const string FALSE_MARKER = @"0";
            public const string TRUE_MARKER = @"1";
            public const string CSV_DELIMITER = @",";
            public const string DOT_MARKER = @".";
            public const string TILDE_MARKER = @"~";
            public const string PROPORTION_SEPARATOR = @"|";
            public const string SHARED_FOLDER_NAME = @"#RLV";
            public const string AND_OPERATOR = @"&&";
            public const string PATH_SEPARATOR = @"/";
            public const string Y = @"y";
            public const string ADD = @"add";
            public const string N = @"n";
            public const string REM = @"rem";
            public const string STATUS_SEPARATOR = @";";

            /// <summary>
            ///     Regex used to match RLV commands.
            /// </summary>
            public static readonly Regex RLVRegEx = new Regex(@"(?<behaviour>[^:=]+)(:(?<option>[^=]*))?=(?<param>\w+)",
                RegexOptions.Compiled);
        }

        #endregion
    }

    public class NativeMethods
    {
        public enum CtrlType
        {
            CTRL_C_EVENT = 0,
            CTRL_BREAK_EVENT,
            CTRL_CLOSE_EVENT,
            CTRL_LOGOFF_EVENT = 5,
            CTRL_SHUTDOWN_EVENT
        }

        /// <summary>
        ///     Import console handler for windows.
        /// </summary>
        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool SetConsoleCtrlHandler(Corrade.EventHandler handler,
            [MarshalAs(UnmanagedType.U1)] bool add);
    }
}