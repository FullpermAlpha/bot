///////////////////////////////////////////////////////////////////////////
//  Copyright (C) Wizardry and Steamworks 2013 - License: GNU GPLv3      //
//  Please see: http://www.gnu.org/licenses/gpl.html for legal details,  //
//  rights of fair usage, the disclaimer and warranty conditions.        //
///////////////////////////////////////////////////////////////////////////

#region

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Management;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.ServiceProcess;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using AIMLbot;
using OpenMetaverse;
using OpenMetaverse.Assets;
using OpenMetaverse.Imaging;
using OpenMetaverse.Rendering;
using OpenMetaverse.StructuredData;
using Encoder = System.Drawing.Imaging.Encoder;
using Parallel = System.Threading.Tasks.Parallel;
using Path = System.IO.Path;
using ThreadState = System.Threading.ThreadState;

#endregion

namespace Corrade
{
    public partial class Corrade : ServiceBase
    {
        public delegate bool EventHandler(NativeMethods.CtrlType ctrlType);

        /// <summary>
        ///     The type of threads managed by Corrade.
        /// </summary>
        public enum CorradeThreadType : uint
        {
            [Description("command")] COMMAND = 1,
            [Description("rlv")] RLV = 2,
            [Description("notification")] NOTIFICATION = 3,
            [Description("instant message")] INSTANT_MESSAGE = 4,
            [Description("log")] LOG = 5,
            [Description("post")] POST = 6
        };

        /// <summary>
        ///     Possible input and output filters.
        /// </summary>
        public enum Filter : uint
        {
            [XmlEnum(Name = "none")] [Description("none")] NONE = 0,
            [XmlEnum(Name = "RFC1738")] [Description("RFC1738")] RFC1738,
            [XmlEnum(Name = "RFC3986")] [Description("RFC3986")] RFC3986,
            [XmlEnum(Name = "ENIGMA")] [Description("ENIGMA")] ENIGMA,
            [XmlEnum(Name = "VIGENERE")] [Description("VIGENERE")] VIGENERE,
            [XmlEnum(Name = "ATBASH")] [Description("ATBASH")] ATBASH,
            [XmlEnum(Name = "BASE64")] [Description("BASE64")] BASE64
        }

        /// <summary>
        ///     An enumeration of various compression methods
        ///     supproted by Corrade's internal HTTP server.
        /// </summary>
        public enum HTTPCompressionMethod : uint
        {
            [XmlEnum(Name = "none")] [Description("none")] NONE,
            [XmlEnum(Name = "deflate")] [Description("deflate")] DEFLATE,
            [XmlEnum(Name = "gzip")] [Description("gzip")] GZIP
        }

        /// <summary>
        ///     Corrade notification types.
        /// </summary>
        [Flags]
        public enum Notifications : uint
        {
            [XmlEnum(Name = "none")] [Description("none")] NONE = 0,
            [XmlEnum(Name = "alert")] [Description("alert")] AlertMessage = 1,
            [XmlEnum(Name = "region")] [Description("region")] RegionMessage = 2,
            [XmlEnum(Name = "group")] [Description("group")] GroupMessage = 4,
            [XmlEnum(Name = "balance")] [Description("balance")] Balance = 8,
            [XmlEnum(Name = "message")] [Description("message")] InstantMessage = 16,
            [XmlEnum(Name = "notice")] [Description("notice")] GroupNotice = 32,
            [XmlEnum(Name = "local")] [Description("local")] LocalChat = 64,
            [XmlEnum(Name = "dialog")] [Description("dialog")] ScriptDialog = 128,
            [XmlEnum(Name = "friendship")] [Description("friendship")] Friendship = 256,
            [XmlEnum(Name = "inventory")] [Description("inventory")] Inventory = 512,
            [XmlEnum(Name = "permission")] [Description("permission")] ScriptPermission = 1024,
            [XmlEnum(Name = "lure")] [Description("lure")] TeleportLure = 2048,
            [XmlEnum(Name = "effect")] [Description("effect")] ViewerEffect = 4096,
            [XmlEnum(Name = "collision")] [Description("collision")] MeanCollision = 8192,
            [XmlEnum(Name = "crossing")] [Description("crossing")] RegionCrossed = 16384,
            [XmlEnum(Name = "terse")] [Description("terse")] TerseUpdates = 32768,
            [XmlEnum(Name = "typing")] [Description("typing")] Typing = 65536,
            [XmlEnum(Name = "invite")] [Description("invite")] GroupInvite = 131072,
            [XmlEnum(Name = "economy")] [Description("economy")] Economy = 262144,
            [XmlEnum(Name = "membership")] [Description("membership")] GroupMembership = 524288,
            [XmlEnum(Name = "url")] [Description("url")] LoadURL = 1048576,
            [XmlEnum(Name = "ownersay")] [Description("ownersay")] OwnerSay = 2097152,
            [XmlEnum(Name = "regionsayto")] [Description("regionsayto")] RegionSayTo = 4194304,
            [XmlEnum(Name = "objectim")] [Description("objectim")] ObjectInstantMessage = 8388608,
            [XmlEnum(Name = "rlv")] [Description("rlv")] RLVMessage = 16777216,
            [XmlEnum(Name = "debug")] [Description("debug")] DebugMessage = 33554432,
            [XmlEnum(Name = "avatars")] [Description("avatars")] RadarAvatars = 67108864,
            [XmlEnum(Name = "primitives")] [Description("primitives")] RadarPrimitives = 134217728,
            [XmlEnum(Name = "control")] [Description("control")] ScriptControl = 268435456
        }

        /// <summary>
        ///     Corrade permissions.
        /// </summary>
        [Flags]
        public enum Permissions : uint
        {
            [XmlEnum(Name = "none")] [Description("none")] None = 0,
            [XmlEnum(Name = "movement")] [Description("movement")] Movement = 1,
            [XmlEnum(Name = "economy")] [Description("economy")] Economy = 2,
            [XmlEnum(Name = "land")] [Description("land")] Land = 4,
            [XmlEnum(Name = "grooming")] [Description("grooming")] Grooming = 8,
            [XmlEnum(Name = "inventory")] [Description("inventory")] Inventory = 16,
            [XmlEnum(Name = "interact")] [Description("interact")] Interact = 32,
            [XmlEnum(Name = "mute")] [Description("mute")] Mute = 64,
            [XmlEnum(Name = "database")] [Description("database")] Database = 128,
            [XmlEnum(Name = "notifications")] [Description("notifications")] Notifications = 256,
            [XmlEnum(Name = "talk")] [Description("talk")] Talk = 512,
            [XmlEnum(Name = "directory")] [Description("directory")] Directory = 1024,
            [XmlEnum(Name = "system")] [Description("system")] System = 2048,
            [XmlEnum(Name = "friendship")] [Description("friendship")] Friendship = 4096,
            [XmlEnum(Name = "execute")] [Description("execute")] Execute = 8192,
            [XmlEnum(Name = "group")] [Description("group")] Group = 16384,
            [XmlEnum(Name = "filter")] [Description("filter")] Filter = 32768
        }

        /// <summary>
        ///     Structure containing errors returned to scripts.
        /// </summary>
        /// <remarks>
        ///     Status is generated by:
        ///     1.) jot -r 900 0 65535 | uniq | xargs printf "%05d\n" | pbcopy
        ///     2.) paste codes.txt status.txt | awk -F"\n" '{print $1,$2}' | pbcopy
        /// </remarks>
        public enum ScriptError : uint
        {
            [Status(0)] [Description("none")] NONE = 0,
            [Status(35392)] [Description("could not join group")] COULD_NOT_JOIN_GROUP,
            [Status(20900)] [Description("could not leave group")] COULD_NOT_LEAVE_GROUP,
            [Status(57961)] [Description("agent not found")] AGENT_NOT_FOUND,
            [Status(28002)] [Description("group not found")] GROUP_NOT_FOUND,
            [Status(15345)] [Description("already in group")] ALREADY_IN_GROUP,
            [Status(11502)] [Description("not in group")] NOT_IN_GROUP,
            [Status(32472)] [Description("role not found")] ROLE_NOT_FOUND,
            [Status(08653)] [Description("command not found")] COMMAND_NOT_FOUND,
            [Status(14634)] [Description("could not eject agent")] COULD_NOT_EJECT_AGENT,
            [Status(30473)] [Description("no group power for command")] NO_GROUP_POWER_FOR_COMMAND,
            [Status(27605)] [Description("cannot eject owners")] CANNOT_EJECT_OWNERS,
            [Status(25984)] [Description("inventory item not found")] INVENTORY_ITEM_NOT_FOUND,
            [Status(43982)] [Description("invalid pay amount")] INVALID_PAY_AMOUNT,
            [Status(02169)] [Description("insufficient funds")] INSUFFICIENT_FUNDS,
            [Status(47624)] [Description("invalid pay target")] INVALID_PAY_TARGET,
            [Status(32164)] [Description("teleport failed")] TELEPORT_FAILED,
            [Status(22693)] [Description("primitive not found")] PRIMITIVE_NOT_FOUND,
            [Status(28613)] [Description("could not sit")] COULD_NOT_SIT,
            [Status(48467)] [Description("no Corrade permissions")] NO_CORRADE_PERMISSIONS,
            [Status(54214)] [Description("could not create group")] COULD_NOT_CREATE_GROUP,
            [Status(11287)] [Description("could not create role")] COULD_NOT_CREATE_ROLE,
            [Status(12758)] [Description("no role name specified")] NO_ROLE_NAME_SPECIFIED,
            [Status(34084)] [Description("timeout getting group roles members")] TIMEOUT_GETING_GROUP_ROLES_MEMBERS,
            [Status(11050)] [Description("timeout getting group roles")] TIMEOUT_GETTING_GROUP_ROLES,
            [Status(39016)] [Description("timeout getting role powers")] TIMEOUT_GETTING_ROLE_POWERS,
            [Status(64390)] [Description("could not find parcel")] COULD_NOT_FIND_PARCEL,
            [Status(17019)] [Description("unable to set home")] UNABLE_TO_SET_HOME,
            [Status(31493)] [Description("unable to go home")] UNABLE_TO_GO_HOME,
            [Status(32923)] [Description("timeout getting profile")] TIMEOUT_GETTING_PROFILE,
            [Status(56462)] [Description("texture not found")] TEXTURE_NOT_FOUND,
            [Status(36068)] [Description("type can only be voice or text")] TYPE_CAN_BE_VOICE_OR_TEXT,
            [Status(19862)] [Description("agent not in group")] AGENT_NOT_IN_GROUP,
            [Status(29345)] [Description("empty attachments")] EMPTY_ATTACHMENTS,
            [Status(43508)] [Description("could not get land users")] COULD_NOT_GET_LAND_USERS,
            [Status(48899)] [Description("empty pick name")] EMPTY_PICK_NAME,
            [Status(22733)] [Description("unable to join group chat")] UNABLE_TO_JOIN_GROUP_CHAT,
            [Status(59524)] [Description("invalid position")] INVALID_POSITION,
            [Status(02707)] [Description("could not find title")] COULD_NOT_FIND_TITLE,
            [Status(43713)] [Description("fly action can only be start or stop")] FLY_ACTION_START_OR_STOP,
            [Status(64868)] [Description("invalid proposal text")] INVALID_PROPOSAL_TEXT,
            [Status(03098)] [Description("invalid proposal quorum")] INVALID_PROPOSAL_QUORUM,
            [Status(41810)] [Description("invalid proposal majority")] INVALID_PROPOSAL_MAJORITY,
            [Status(07628)] [Description("invalid proposal duration")] INVALID_PROPOSAL_DURATION,
            [Status(64123)] [Description("invalid mute target")] INVALID_MUTE_TARGET,
            [Status(59526)] [Description("unknown action")] UNKNOWN_ACTION,
            [Status(28087)] [Description("no database file configured")] NO_DATABASE_FILE_CONFIGURED,
            [Status(12181)] [Description("no database key specified")] NO_DATABASE_KEY_SPECIFIED,
            [Status(44994)] [Description("no database value specified")] NO_DATABASE_VALUE_SPECIFIED,
            [Status(19142)] [Description("unknown database action")] UNKNOWN_DATABASE_ACTION,
            [Status(01253)] [Description("cannot remove owner role")] CANNOT_REMOVE_OWNER_ROLE,
            [Status(47808)] [Description("cannot remove user from owner role")] CANNOT_REMOVE_USER_FROM_OWNER_ROLE,
            [Status(47469)] [Description("timeout getting picks")] TIMEOUT_GETTING_PICKS,
            [Status(41256)] [Description("maximum number of roles exceeded")] MAXIMUM_NUMBER_OF_ROLES_EXCEEDED,
            [Status(40908)] [Description("cannot delete a group member from the everyone role")] CANNOT_DELETE_A_GROUP_MEMBER_FROM_THE_EVERYONE_ROLE,
            [Status(00458)] [Description("group members are by default in the everyone role")] GROUP_MEMBERS_ARE_BY_DEFAULT_IN_THE_EVERYONE_ROLE,
            [Status(33413)] [Description("cannot delete the everyone role")] CANNOT_DELETE_THE_EVERYONE_ROLE,
            [Status(65303)] [Description("invalid url provided")] INVALID_URL_PROVIDED,
            [Status(65327)] [Description("invalid notification types")] INVALID_NOTIFICATION_TYPES,
            [Status(49640)] [Description("notification not allowed")] NOTIFICATION_NOT_ALLOWED,
            [Status(44447)] [Description("unknown directory search type")] UNKNOWN_DIRECTORY_SEARCH_TYPE,
            [Status(65101)] [Description("no search text provided")] NO_SEARCH_TEXT_PROVIDED,
            [Status(14337)] [Description("unknown restart action")] UNKNOWN_RESTART_ACTION,
            [Status(28429)] [Description("unknown move action")] UNKNOWN_MOVE_ACTION,
            [Status(20541)] [Description("timeout getting top scripts")] TIMEOUT_GETTING_TOP_SCRIPTS,
            [Status(57429)] [Description("timeout waiting for estate list")] TIMEOUT_WAITING_FOR_ESTATE_LIST,
            [Status(41676)] [Description("unknown top type")] UNKNOWN_TOP_TYPE,
            [Status(25897)] [Description("unknown estate list action")] UNKNOWN_ESTATE_LIST_ACTION,
            [Status(46990)] [Description("unknown estate list")] UNKNOWN_ESTATE_LIST,
            [Status(43156)] [Description("no item specified")] NO_ITEM_SPECIFIED,
            [Status(09348)] [Description("unknown animation action")] UNKNOWN_ANIMATION_ACTION,
            [Status(42216)] [Description("no channel specified")] NO_CHANNEL_SPECIFIED,
            [Status(31049)] [Description("no button index specified")] NO_BUTTON_INDEX_SPECIFIED,
            [Status(38931)] [Description("no button specified")] NO_BUTTON_SPECIFIED,
            [Status(19059)] [Description("no land rights")] NO_LAND_RIGHTS,
            [Status(61113)] [Description("unknown entity")] UNKNOWN_ENTITY,
            [Status(58183)] [Description("invalid rotation")] INVALID_ROTATION,
            [Status(45364)] [Description("could not set script state")] COULD_NOT_SET_SCRIPT_STATE,
            [Status(50218)] [Description("item is not a script")] ITEM_IS_NOT_A_SCRIPT,
            [Status(49722)] [Description("failed to get display name")] FAILED_TO_GET_DISPLAY_NAME,
            [Status(40665)] [Description("no name provided")] NO_NAME_PROVIDED,
            [Status(35198)] [Description("could not set display name")] COULD_NOT_SET_DISPLAY_NAME,
            [Status(63713)] [Description("timeout joining group")] TIMEOUT_JOINING_GROUP,
            [Status(32404)] [Description("timeout creating group")] TIMEOUT_CREATING_GROUP,
            [Status(00616)] [Description("timeout ejecting agent")] TIMEOUT_EJECTING_AGENT,
            [Status(25426)] [Description("timeout getting group role members")] TIMEOUT_GETTING_GROUP_ROLE_MEMBERS,
            [Status(31237)] [Description("timeout leaving group")] TIMEOUT_LEAVING_GROUP,
            [Status(14951)] [Description("timeout joining group chat")] TIMEOUT_JOINING_GROUP_CHAT,
            [Status(43780)] [Description("timeout during teleport")] TIMEOUT_DURING_TELEPORT,
            [Status(46316)] [Description("timeout requesting sit")] TIMEOUT_REQUESTING_SIT,
            [Status(09111)] [Description("timeout getting land users")] TIMEOUT_GETTING_LAND_USERS,
            [Status(23364)] [Description("timeout getting script state")] TIMEOUT_GETTING_SCRIPT_STATE,
            [Status(26393)] [Description("timeout updating mute list")] TIMEOUT_UPDATING_MUTE_LIST,
            [Status(32362)] [Description("timeout getting parcels")] TIMEOUT_GETTING_PARCELS,
            [Status(46942)] [Description("empty classified name")] EMPTY_CLASSIFIED_NAME,
            [Status(38184)] [Description("invalid price")] INVALID_PRICE,
            [Status(59103)] [Description("timeout getting classifieds")] TIMEOUT_GETTING_CLASSIFIEDS,
            [Status(08241)] [Description("could not find classified")] COULD_NOT_FIND_CLASSIFIED,
            [Status(53947)] [Description("invalid days")] INVALID_DAYS,
            [Status(18490)] [Description("invalid interval")] INVALID_INTERVAL,
            [Status(53829)] [Description("timeout getting group account summary")] TIMEOUT_GETTING_GROUP_ACCOUNT_SUMMARY,
            [Status(30207)] [Description("friend not found")] FRIEND_NOT_FOUND,
            [Status(32366)] [Description("the agent already is a friend")] AGENT_ALREADY_FRIEND,
            [Status(04797)] [Description("no friendship offer found")] NO_FRIENDSHIP_OFFER_FOUND,
            [Status(65003)] [Description("friend does not allow mapping")] FRIEND_DOES_NOT_ALLOW_MAPPING,
            [Status(10691)] [Description("timeout mapping friend")] TIMEOUT_MAPPING_FRIEND,
            [Status(23309)] [Description("friend offline")] FRIEND_OFFLINE,
            [Status(34964)] [Description("timeout getting region")] TIMEOUT_GETTING_REGION,
            [Status(35447)] [Description("region not found")] REGION_NOT_FOUND,
            [Status(00337)] [Description("no map items found")] NO_MAP_ITEMS_FOUND,
            [Status(53549)] [Description("no description provided")] NO_DESCRIPTION_PROVIDED,
            [Status(43982)] [Description("no folder specified")] NO_FOLDER_SPECIFIED,
            [Status(29512)] [Description("empty wearables")] EMPTY_WEARABLES,
            [Status(35316)] [Description("parcel not for sale")] PARCEL_NOT_FOR_SALE,
            [Status(42051)] [Description("unknown access list type")] UNKNOWN_ACCESS_LIST_TYPE,
            [Status(29438)] [Description("no task specified")] NO_TASK_SPECIFIED,
            [Status(37470)] [Description("timeout getting group members")] TIMEOUT_GETTING_GROUP_MEMBERS,
            [Status(24939)] [Description("group not open")] GROUP_NOT_OPEN,
            [Status(30384)] [Description("timeout downloading terrain")] TIMEOUT_DOWNLOADING_ASSET,
            [Status(57005)] [Description("timeout uploading terrain")] TIMEOUT_UPLOADING_ASSET,
            [Status(16667)] [Description("empty terrain data")] EMPTY_ASSET_DATA,
            [Status(34749)] [Description("the specified folder contains no equipable items")] NO_EQUIPABLE_ITEMS,
            [Status(42249)] [Description("inventory offer not found")] INVENTORY_OFFER_NOT_FOUND,
            [Status(23805)] [Description("no session specified")] NO_SESSION_SPECIFIED,
            [Status(61018)] [Description("folder not found")] FOLDER_NOT_FOUND,
            [Status(37211)] [Description("timeout creating item")] TIMEOUT_CREATING_ITEM,
            [Status(09541)] [Description("timeout uploading item")] TIMEOUT_UPLOADING_ITEM,
            [Status(36684)] [Description("unable to upload item")] UNABLE_TO_UPLOAD_ITEM,
            [Status(05034)] [Description("unable to create item")] UNABLE_TO_CREATE_ITEM,
            [Status(44397)] [Description("timeout uploading item data")] TIMEOUT_UPLOADING_ITEM_DATA,
            [Status(12320)] [Description("unable to upload item data")] UNABLE_TO_UPLOAD_ITEM_DATA,
            [Status(55979)] [Description("unknown direction")] UNKNOWN_DIRECTION,
            [Status(22576)] [Description("timeout requesting to set home")] TIMEOUT_REQUESTING_TO_SET_HOME,
            [Status(07255)] [Description("timeout transferring asset")] TIMEOUT_TRANSFERRING_ASSET,
            [Status(60269)] [Description("asset upload failed")] ASSET_UPLOAD_FAILED,
            [Status(57085)] [Description("failed to download asset")] FAILED_TO_DOWNLOAD_ASSET,
            [Status(60025)] [Description("unknown asset type")] UNKNOWN_ASSET_TYPE,
            [Status(59048)] [Description("invalid asset data")] INVALID_ASSET_DATA,
            [Status(32709)] [Description("unknown wearable type")] UNKNOWN_WEARABLE_TYPE,
            [Status(06097)] [Description("unknown inventory type")] UNKNOWN_INVENTORY_TYPE,
            [Status(64698)] [Description("could not compile regular expression")] COULD_NOT_COMPILE_REGULAR_EXPRESSION,
            [Status(18680)] [Description("no pattern provided")] NO_PATTERN_PROVIDED,
            [Status(11910)] [Description("no executable file provided")] NO_EXECUTABLE_FILE_PROVIDED,
            [Status(31381)] [Description("timeout waiting for execution")] TIMEOUT_WAITING_FOR_EXECUTION,
            [Status(04541)] [Description("unknown group invite session")] UNKNOWN_GROUP_INVITE_SESSION,
            [Status(38125)] [Description("unable to obtain money balance")] UNABLE_TO_OBTAIN_MONEY_BALANCE,
            [Status(20048)] [Description("timeout getting avatar data")] TIMEOUT_GETTING_AVATAR_DATA,
            [Status(13712)] [Description("timeout retrieving estate list")] TIMEOUT_RETRIEVING_ESTATE_LIST,
            [Status(37559)] [Description("destination too close")] DESTINATION_TOO_CLOSE,
            [Status(11229)] [Description("timeout getting group titles")] TIMEOUT_GETTING_GROUP_TITLES,
            [Status(47101)] [Description("no message provided")] NO_MESSAGE_PROVIDED,
            [Status(04075)] [Description("could not remove brain file")] COULD_NOT_REMOVE_BRAIN_FILE,
            [Status(54456)] [Description("unknown effect")] UNKNOWN_EFFECT,
            [Status(48775)] [Description("no effect UUID provided")] NO_EFFECT_UUID_PROVIDED,
            [Status(38858)] [Description("effect not found")] EFFECT_NOT_FOUND,
            [Status(16572)] [Description("invalid viewer effect")] INVALID_VIEWER_EFFECT,
            [Status(19011)] [Description("ambiguous path")] AMBIGUOUS_PATH,
            [Status(53066)] [Description("path not found")] PATH_NOT_FOUND,
            [Status(13857)] [Description("unexpected item in path")] UNEXPECTED_ITEM_IN_PATH,
            [Status(59282)] [Description("no path provided")] NO_PATH_PROVIDED,
            [Status(26623)] [Description("unable to create folder")] UNABLE_TO_CREATE_FOLDER,
            [Status(28866)] [Description("no permissions provided")] NO_PERMISSIONS_PROVIDED,
            [Status(43615)] [Description("setting permissions failed")] SETTING_PERMISSIONS_FAILED,
            [Status(36716)] [Description("timeout retrieving item")] TIMEOUT_RETRIEVING_ITEM,
            [Status(39391)] [Description("expected item as source")] EXPECTED_ITEM_AS_SOURCE,
            [Status(22655)] [Description("expected folder as target")] EXPECTED_FOLDER_AS_TARGET,
            [Status(63024)] [Description("unable to load configuration")] UNABLE_TO_LOAD_CONFIGURATION,
            [Status(33564)] [Description("unable to save configuration")] UNABLE_TO_SAVE_CONFIGURATION,
            [Status(20900)] [Description("invalid xml path")] INVALID_XML_PATH,
            [Status(03638)] [Description("no data provided")] NO_DATA_PROVIDED,
            [Status(42903)] [Description("unknown image format requested")] UNKNOWN_IMAGE_FORMAT_REQUESTED,
            [Status(02380)] [Description("unknown image format provided")] UNKNOWN_IMAGE_FORMAT_PROVIDED,
            [Status(04994)] [Description("unable to decode asset data")] UNABLE_TO_DECODE_ASSET_DATA,
            [Status(61067)] [Description("unable to convert to requested format")] UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT,
            [Status(08411)] [Description("could not start process")] COULD_NOT_START_PROCESS,
            [Status(11869)] [Description("timeout getting primitive data")] TIMEOUT_GETTING_PRIMITIVE_DATA,
            [Status(22737)] [Description("item is not an object")] ITEM_IS_NOT_AN_OBJECT,
            [Status(19143)] [Description("timeout meshmerizing object")] COULD_NOT_MESHMERIZE_OBJECT,
            [Status(37841)] [Description("could not get primitive properties")] COULD_NOT_GET_PRIMITIVE_PROPERTIES,
            [Status(54854)] [Description("avatar not in range")] AVATAR_NOT_IN_RANGE,
            [Status(03475)] [Description("invalid scale")] INVALID_SCALE,
            [Status(30129)] [Description("could not get current groups")] COULD_NOT_GET_CURRENT_GROUPS,
            [Status(39613)] [Description("maximum number of groups reached")] MAXIMUM_NUMBER_OF_GROUPS_REACHED,
            [Status(43003)] [Description("unknown syntax type")] UNKNOWN_SYNTAX_TYPE,
            [Status(13053)] [Description("too many characters for group name")] TOO_MANY_CHARACTERS_FOR_GROUP_NAME,
            [Status(19325)] [Description("too many characters for group title")] TOO_MANY_CHARACTERS_FOR_GROUP_TITLE,
            [Status(26178)] [Description("too many characters for notice message")] TOO_MANY_CHARACTERS_FOR_NOTICE_MESSAGE,
            [Status(35277)] [Description("notecard message body too large")] NOTECARD_MESSAGE_BODY_TOO_LARGE,
            [Status(47571)] [Description("too many or too few characters for display name")] TOO_MANY_OR_TOO_FEW_CHARACTERS_FOR_DISPLAY_NAME,
            [Status(30293)] [Description("name too large")] NAME_TOO_LARGE,
            [Status(60515)] [Description("position would exceed maximum rez altitude")] POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE,
            [Status(43683)] [Description("description too large")] DESCRIPTION_TOO_LARGE,
            [Status(54154)] [Description("scale would exceed building constraints")] SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS,
            [Status(29745)] [Description("attachments would exceed maximum attachment limit")] ATTACHMENTS_WOULD_EXCEED_MAXIMUM_ATTACHMENT_LIMIT,
            [Status(52299)] [Description("too many or too few characters in message")] TOO_MANY_OR_TOO_FEW_CHARACTERS_IN_MESSAGE,
            [Status(50593)] [Description("maximum ban list length reached")] MAXIMUM_BAN_LIST_LENGTH_REACHED,
            [Status(09935)] [Description("maximum group list length reached")] MAXIMUM_GROUP_LIST_LENGTH_REACHED,
            [Status(42536)] [Description("maximum user list length reached")] MAXIMUM_USER_LIST_LENGTH_REACHED,
            [Status(28625)] [Description("maximum manager list length reached")] MAXIMUM_MANAGER_LIST_LENGTH_REACHED,
            [Status(28126)] [Description("auto return time outside limit range")] AUTO_RETURN_TIME_OUTSIDE_LIMIT_RANGE,
            [Status(56379)] [Description("second life text too large")] SECOND_LIFE_TEXT_TOO_LARGE,
            [Status(09924)] [Description("first life text too large")] FIRST_LIFE_TEXT_TOO_LARGE,
            [Status(50405)] [Description("maximum amount of picks reached")] MAXIMUM_AMOUNT_OF_PICKS_REACHED,
            [Status(17894)] [Description("description would exceed maximum size")] DESCRIPTION_WOULD_EXCEED_MAXIMUM_SIZE,
            [Status(28247)] [Description("maximum amount of classifieds reached")] MAXIMUM_AMOUNT_OF_CLASSIFIEDS_REACHED,
            [Status(38609)] [Description("timeout changing links")] TIMEOUT_CHANGING_LINKS,
            [Status(45074)] [Description("link would exceed maximum link limit")] LINK_WOULD_EXCEED_MAXIMUM_LINK_LIMIT,
            [Status(40773)] [Description("invalid number of items specified")] INVALID_NUMBER_OF_ITEMS_SPECIFIED,
            [Status(52751)] [Description("timeout requesting price")] TIMEOUT_REQUESTING_PRICE,
            [Status(01536)] [Description("primitive not for sale")] PRIMITIVE_NOT_FOR_SALE,
            [Status(36123)] [Description("teleport throttled")] TELEPORT_THROTTLED,
            [Status(06617)] [Description("no matching dialog found")] NO_MATCHING_DIALOG_FOUND,
            [Status(08842)] [Description("unknown tree type")] UNKNOWN_TREE_TYPE,
            [Status(20238)] [Description("parcel must be owned")] PARCEL_MUST_BE_OWNED,
            [Status(62130)] [Description("invalid texture coordinates")] INVALID_TEXTURE_COORDINATES,
            [Status(10945)] [Description("invalid surface coordinates")] INVALID_SURFACE_COORDINATES,
            [Status(28487)] [Description("invalid normal vector")] INVALID_NORMAL_VECTOR,
            [Status(13296)] [Description("invalid binormal vector")] INVALID_BINORMAL_VECTOR,
            [Status(44554)] [Description("primitives not in same region")] PRIMITIVES_NOT_IN_SAME_REGION,
            [Status(38798)] [Description("invalid face specified")] INVALID_FACE_SPECIFIED,
            [Status(61473)] [Description("invalid status supplied")] INVALID_STATUS_SUPPLIED,
            [Status(13764)] [Description("status not found")] STATUS_NOT_FOUND,
            [Status(30556)] [Description("no description for status")] NO_DESCRIPTION_FOR_STATUS,
            [Status(64368)] [Description("unknown grass type")] UNKNOWN_GRASS_TYPE,
            [Status(53274)] [Description("unknown material type")] UNKNOWN_MATERIAL_TYPE,
            [Status(18463)] [Description("could not retrieve object media")] COULD_NOT_RETRIEVE_OBJECT_MEDIA,
            [Status(02193)] [Description("no avatars to ban or unban")] NO_AVATARS_TO_BAN_OR_UNBAN,
            [Status(45568)] [Description("could not retrieve broup ban list")] COULD_NOT_RETRIEVE_GROUP_BAN_LIST,
            [Status(15719)] [Description("timeout retrieving group ban list")] TIMEOUT_RETRIEVING_GROUP_BAN_LIST,
            [Status(26749)] [Description("timeout modifying group ban list")] TIMEOUT_MODIFYING_GROUP_BAN_LIST,
            [Status(26715)] [Description("mute entry not found")] MUTE_ENTRY_NOT_FOUND,
            [Status(51086)] [Description("no name or UUID provided")] NO_NAME_OR_UUID_PROVIDED,
            [Status(16450)] [Description("could not retrieve mute list")] COULD_NOT_RETRIEVE_MUTE_LIST,
            [Status(39647)] [Description("mute entry already exists")] MUTE_ENTRY_ALREADY_EXISTS,
            [Status(22961)] [Description("could not add mute entry")] COULD_NOT_ADD_MUTE_ENTRY
        }

        /// <summary>
        ///     Semaphores that sense the state of the connection. When any of these semaphores fail,
        ///     Corrade does not consider itself connected anymore and terminates.
        /// </summary>
        private static readonly Dictionary<char, ManualResetEvent> ConnectionSemaphores = new Dictionary
            <char, ManualResetEvent>
        {
            {'l', new ManualResetEvent(false)},
            {'s', new ManualResetEvent(false)},
            {'u', new ManualResetEvent(false)}
        };

        public static string InstalledServiceName;
        private static CorradeConfiguration corradeConfiguration = new CorradeConfiguration();
        private static Thread programThread;
        private static Thread HTTPListenerThread;
        private static HttpListener HTTPListener;
        private static Thread EffectsExpirationThread;
        private static readonly Random CorradeRandom = new Random();
        private static readonly EventLog CorradeEventLog = new EventLog();
        private static readonly GridClient Client = new GridClient();

        private static readonly Bot AIMLBot = new Bot
        {
            TrustAIML = false
        };

        private static readonly User AIMLBotUser = new User(CORRADE_CONSTANTS.CORRADE, AIMLBot);
        private static readonly FileSystemWatcher AIMLBotConfigurationWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher ConfigurationWatcher = new FileSystemWatcher();
        private static readonly FileSystemWatcher NotificationsWatcher = new FileSystemWatcher();
        private static readonly object AIMLBotLock = new object();
        private static readonly object ClientInstanceGroupsLock = new object();
        private static readonly object ClientInstanceInventoryLock = new object();
        private static readonly object ClientInstanceAvatarsLock = new object();
        private static readonly object ClientInstanceSelfLock = new object();
        private static readonly object ClientInstanceConfigurationLock = new object();
        private static readonly object ClientInstanceParcelsLock = new object();
        private static readonly object ClientInstanceNetworkLock = new object();
        private static readonly object ClientInstanceGridLock = new object();
        private static readonly object ClientInstanceDirectoryLock = new object();
        private static readonly object ClientInstanceEstateLock = new object();
        private static readonly object ClientInstanceObjectsLock = new object();
        private static readonly object ClientInstanceFriendsLock = new object();
        private static readonly object ClientInstanceAssetsLock = new object();
        private static readonly object ClientInstanceAppearanceLock = new object();
        private static readonly object ConfigurationFileLock = new object();
        private static readonly object ClientLogFileLock = new object();
        private static readonly object GroupLogFileLock = new object();
        private static readonly object LocalLogFileLock = new object();
        private static readonly object RegionLogFileLock = new object();
        private static readonly object InstantMessageLogFileLock = new object();
        private static readonly object DatabaseFileLock = new object();

        private static readonly wasTimedThrottle TimedTeleportThrottle =
            new wasTimedThrottle(LINDEN_CONSTANTS.TELEPORTS.THROTTLE.MAX_TELEPORTS,
                LINDEN_CONSTANTS.TELEPORTS.THROTTLE.GRACE_SECONDS);

        private static readonly Dictionary<string, object> DatabaseLocks = new Dictionary<string, object>();
        private static readonly object GroupNotificationsLock = new object();
        public static HashSet<Notification> GroupNotifications = new HashSet<Notification>();

        private static readonly SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>
            InventoryOffers =
                new SerializableDictionary<InventoryObjectOfferedEventArgs, ManualResetEvent>();

        private static readonly object InventoryOffersLock = new object();

        private static readonly BlockingQueue<CallbackQueueElement> CallbackQueue =
            new BlockingQueue<CallbackQueueElement>();

        private static readonly BlockingQueue<NotificationQueueElement> NotificationQueue =
            new BlockingQueue<NotificationQueueElement>();

        private static readonly HashSet<GroupInvite> GroupInvites = new HashSet<GroupInvite>();
        private static readonly object GroupInviteLock = new object();
        private static readonly HashSet<TeleportLure> TeleportLures = new HashSet<TeleportLure>();
        private static readonly object TeleportLureLock = new object();

        private static readonly HashSet<ScriptPermissionRequest> ScriptPermissionRequests =
            new HashSet<ScriptPermissionRequest>();

        private static readonly object ScriptPermissionRequestLock = new object();
        private static readonly HashSet<ScriptDialog> ScriptDialogs = new HashSet<ScriptDialog>();
        private static readonly object ScriptDialogLock = new object();

        private static readonly SerializableDictionary<UUID, HashSet<UUID>> GroupMembers =
            new SerializableDictionary<UUID, HashSet<UUID>>();

        private static readonly object GroupMembersLock = new object();
        private static readonly Hashtable GroupWorkers = new Hashtable();
        private static readonly object GroupWorkersLock = new object();
        private static readonly Hashtable GroupDirectoryTrackers = new Hashtable();
        private static readonly object GroupDirectoryTrackersLock = new object();
        private static readonly HashSet<LookAtEffect> LookAtEffects = new HashSet<LookAtEffect>();
        private static readonly HashSet<PointAtEffect> PointAtEffects = new HashSet<PointAtEffect>();
        private static readonly HashSet<SphereEffect> SphereEffects = new HashSet<SphereEffect>();
        private static readonly object SphereEffectsLock = new object();
        private static readonly HashSet<BeamEffect> BeamEffects = new HashSet<BeamEffect>();
        private static readonly Dictionary<UUID, Primitive> RadarObjects = new Dictionary<UUID, Primitive>();
        private static readonly object RadarObjectsLock = new object();
        private static readonly object BeamEffectsLock = new object();
        private static readonly object InputFiltersLock = new object();
        private static readonly object OutputFiltersLock = new object();
        private static volatile bool AIMLBotBrainCompiled;

        /// <summary>
        ///     The various types of threads created by Corrade.
        /// </summary>
        private static readonly Dictionary<CorradeThreadType, CorradeThread> CorradeThreadPool =
            new Dictionary<CorradeThreadType, CorradeThread>
            {
                {CorradeThreadType.COMMAND, new CorradeThread(CorradeThreadType.COMMAND)},
                {CorradeThreadType.RLV, new CorradeThread(CorradeThreadType.RLV)},
                {CorradeThreadType.NOTIFICATION, new CorradeThread(CorradeThreadType.NOTIFICATION)},
                {CorradeThreadType.INSTANT_MESSAGE, new CorradeThread(CorradeThreadType.INSTANT_MESSAGE)},
                {CorradeThreadType.LOG, new CorradeThread(CorradeThreadType.LOG)},
                {CorradeThreadType.POST, new CorradeThread(CorradeThreadType.POST)}
            };

        /// <summary>
        ///     Group membership sweep thread.
        /// </summary>
        private static Thread GroupMembershipSweepThread;

        /// <summary>
        ///     Group membership sweep thread starter.
        /// </summary>
        private static readonly System.Action StartGroupMembershipSweepThread = () =>
        {
            if (GroupMembershipSweepThread != null &&
                (GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) ||
                 GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            runGroupMembershipSweepThread = true;
            GroupMembershipSweepThread = new Thread(GroupMembershipSweep)
            {
                IsBackground = true,
                Priority = ThreadPriority.Lowest
            };
            GroupMembershipSweepThread.Start();
        };

        /// <summary>
        ///     Group membership sweep thread stopper.
        /// </summary>
        private static readonly System.Action StopGroupMembershipSweepThread = () =>
        {
            // Stop the notification thread.
            runGroupMembershipSweepThread = false;
            if (GroupMembershipSweepThread == null ||
                (!GroupMembershipSweepThread.ThreadState.Equals(ThreadState.Running) &&
                 !GroupMembershipSweepThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                return;
            if (GroupMembershipSweepThread.Join(1000)) return;
            try
            {
                GroupMembershipSweepThread.Abort();
                GroupMembershipSweepThread.Join();
            }
            catch (ThreadStateException)
            {
            }
        };

        /// <summary>
        ///     Schedules a load of the configuration file.
        /// </summary>
        private static readonly Timer ConfigurationChangedTimer =
            new Timer(ConfigurationChanged =>
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.CONFIGURATION_FILE_MODIFIED));
                lock (ConfigurationFileLock)
                {
                    corradeConfiguration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE, ref corradeConfiguration);
                }
            });

        /// <summary>
        ///     Schedules a load of the configuration file.
        /// </summary>
        private static readonly Timer NotificationsChangedTimer =
            new Timer(NotificationsChanged =>
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.NOTIFICATIONS_FILE_MODIFIED));
                lock (GroupNotificationsLock)
                {
                    LoadNotificationState.Invoke();
                }
            });

        /// <summary>
        ///     Schedules a load of the AIML configuration file.
        /// </summary>
        private static readonly Timer AIMLConfigurationChangedTimer =
            new Timer(AIMLConfigurationChanged =>
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.AIML_CONFIGURATION_MODIFIED));
                new Thread(
                    () =>
                    {
                        lock (AIMLBotLock)
                        {
                            LoadChatBotFiles.Invoke();
                        }
                    })
                {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
            });

        /// <summary>
        ///     Global rebake timer.
        /// </summary>
        private static readonly Timer RebakeTimer = new Timer(Rebake =>
        {
            lock (ClientInstanceAppearanceLock)
            {
                ManualResetEvent AppearanceSetEvent = new ManualResetEvent(false);
                EventHandler<AppearanceSetEventArgs> HandleAppearanceSet = (sender, args) => AppearanceSetEvent.Set();
                Client.Appearance.AppearanceSet += HandleAppearanceSet;
                Client.Appearance.RequestSetAppearance(true);
                AppearanceSetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false);
                Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            }
        });

        /// <summary>
        ///     Current land group activation timer.
        /// </summary>
        private static readonly Timer ActivateCurrentLandGroupTimer =
            new Timer(ActivateCurrentLandGroup =>
            {
                Parcel parcel = null;
                if (!GetParcelAtPosition(Client.Network.CurrentSim, Client.Self.SimPosition, ref parcel)) return;
                Group landGroup =
                    corradeConfiguration.Groups.AsParallel().FirstOrDefault(o => o.UUID.Equals(parcel.GroupID));
                if (landGroup.UUID.Equals(UUID.Zero)) return;
                Client.Groups.ActivateGroup(landGroup.UUID);
            });

        public static EventHandler ConsoleEventHandler;

        /// <summary>
        ///     Corrade's input filter function.
        /// </summary>
        private static readonly Func<string, string> wasInput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Filter> safeFilters;
            lock (InputFiltersLock)
            {
                safeFilters = corradeConfiguration.InputFilters;
            }
            foreach (Filter filter in safeFilters)
            {
                switch (filter)
                {
                    case Filter.RFC1738:
                        o = wasURLUnescapeDataString(o);
                        break;
                    case Filter.RFC3986:
                        o = wasURIUnescapeDataString(o);
                        break;
                    case Filter.ENIGMA:
                        o = wasEnigma(o, corradeConfiguration.ENIGMA.rotors.ToArray(),
                            corradeConfiguration.ENIGMA.plugs.ToArray(),
                            corradeConfiguration.ENIGMA.reflector);
                        break;
                    case Filter.VIGENERE:
                        o = wasDecryptVIGENERE(o, corradeConfiguration.VIGENERESecret);
                        break;
                    case Filter.ATBASH:
                        o = wasATBASH(o);
                        break;
                    case Filter.BASE64:
                        o = Encoding.UTF8.GetString(Convert.FromBase64String(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Corrade's output filter function.
        /// </summary>
        private static readonly Func<string, string> wasOutput = o =>
        {
            if (string.IsNullOrEmpty(o)) return string.Empty;

            List<Filter> safeFilters;
            lock (OutputFiltersLock)
            {
                safeFilters = corradeConfiguration.OutputFilters;
            }
            foreach (Filter filter in safeFilters)
            {
                switch (filter)
                {
                    case Filter.RFC1738:
                        o = wasURLEscapeDataString(o);
                        break;
                    case Filter.RFC3986:
                        o = wasURIEscapeDataString(o);
                        break;
                    case Filter.ENIGMA:
                        o = wasEnigma(o, corradeConfiguration.ENIGMA.rotors.ToArray(),
                            corradeConfiguration.ENIGMA.plugs.ToArray(),
                            corradeConfiguration.ENIGMA.reflector);
                        break;
                    case Filter.VIGENERE:
                        o = wasEncryptVIGENERE(o, corradeConfiguration.VIGENERESecret);
                        break;
                    case Filter.ATBASH:
                        o = wasATBASH(o);
                        break;
                    case Filter.BASE64:
                        o = Convert.ToBase64String(Encoding.UTF8.GetBytes(o));
                        break;
                }
            }
            return o;
        };

        /// <summary>
        ///     Determines whether a string is a Corrade command.
        /// </summary>
        /// <returns>true if the string is a Corrade command</returns>
        private static readonly Func<string, bool> IsCorradeCommand = o =>
        {
            Dictionary<string, string> data = wasKeyValueDecode(o);
            return data.Any() && data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND)) &&
                   data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)) &&
                   data.ContainsKey(wasGetDescriptionFromEnumValue(ScriptKeys.Password));
        };

        /// <summary>
        ///     Gets the first name and last name from an avatar name.
        /// </summary>
        /// <returns>the firstname and the lastname or Resident</returns>
        private static readonly Func<string, IEnumerable<string>> GetAvatarNames =
            o => !string.IsNullOrEmpty(o)
                ? CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(o)
                    .Cast<Match>()
                    .ToDictionary(p => new[]
                    {
                        p.Groups["first"].Value,
                        p.Groups["last"].Value
                    })
                    .SelectMany(
                        p =>
                            new[]
                            {
                                p.Key[0].Trim(),
                                !string.IsNullOrEmpty(p.Key[1])
                                    ? p.Key[1].Trim()
                                    : LINDEN_CONSTANTS.AVATARS.LASTNAME_PLACEHOLDER
                            })
                : null;

        /// <summary>
        ///     Updates the inventory starting from a folder recursively.
        /// </summary>
        private static readonly Action<InventoryFolder> UpdateInventoryRecursive = o =>
        {
            Thread updateInventoryRecursiveThread = new Thread(() =>
            {
                try
                {
                    // Create the queue of folders.
                    // Enqueue the first folder (as the root).
                    Dictionary<UUID, ManualResetEvent> inventoryFolders = new Dictionary<UUID, ManualResetEvent>
                    {
                        {o.UUID, new ManualResetEvent(false)}
                    };
                    // Create a stopwatch for the root folder.
                    Dictionary<UUID, Stopwatch> inventoryStopwatch = new Dictionary<UUID, Stopwatch>
                    {
                        {o.UUID, new Stopwatch()}
                    };

                    HashSet<long> times = new HashSet<long>(new[] {(long) Client.Settings.CAPS_TIMEOUT});

                    object LockObject = new object();

                    EventHandler<FolderUpdatedEventArgs> FolderUpdatedEventHandler = (p, q) =>
                    {
                        // Enqueue all the new folders.
                        Client.Inventory.Store.GetContents(q.FolderID).ForEach(r =>
                        {
                            if (r is InventoryFolder)
                            {
                                UUID inventoryFolderUUID = (r as InventoryFolder).UUID;
                                lock (LockObject)
                                {
                                    if (!inventoryFolders.ContainsKey(inventoryFolderUUID))
                                    {
                                        inventoryFolders.Add(inventoryFolderUUID, new ManualResetEvent(false));
                                    }
                                    if (!inventoryStopwatch.ContainsKey(inventoryFolderUUID))
                                    {
                                        inventoryStopwatch.Add(inventoryFolderUUID, new Stopwatch());
                                    }
                                }
                            }
                            lock (LockObject)
                            {
                                inventoryStopwatch[q.FolderID].Stop();
                                times.Add(inventoryStopwatch[q.FolderID].ElapsedMilliseconds);
                                inventoryFolders[q.FolderID].Set();
                            }
                        });
                    };

                    do
                    {
                        // Don't choke the chicken.
                        Thread.Yield();
                        Dictionary<UUID, ManualResetEvent> closureFolders;
                        lock (LockObject)
                        {
                            closureFolders =
                                new Dictionary<UUID, ManualResetEvent>(
                                    inventoryFolders.Where(p => !p.Key.Equals(UUID.Zero))
                                        .ToDictionary(p => p.Key, q => q.Value));
                        }
                        lock (ClientInstanceInventoryLock)
                        {
                            Parallel.ForEach(closureFolders, p =>
                            {
                                Client.Inventory.FolderUpdated += FolderUpdatedEventHandler;
                                lock (LockObject)
                                {
                                    inventoryStopwatch[p.Key].Start();
                                }
                                Client.Inventory.RequestFolderContents(p.Key, Client.Self.AgentID, true, true,
                                    InventorySortOrder.ByDate);
                                ManualResetEvent folderEvent;
                                int averageTime;
                                lock (LockObject)
                                {
                                    folderEvent = closureFolders[p.Key];
                                    averageTime = (int) times.Average();
                                }
                                folderEvent.WaitOne(averageTime, false);
                                Client.Inventory.FolderUpdated -= FolderUpdatedEventHandler;
                            });
                        }
                        Parallel.ForEach(closureFolders, p =>
                        {
                            if (inventoryFolders.ContainsKey(p.Key))
                            {
                                lock (LockObject)
                                {
                                    inventoryFolders.Remove(p.Key);
                                }
                            }
                            if (inventoryStopwatch.ContainsKey(p.Key))
                            {
                                lock (LockObject)
                                {
                                    inventoryStopwatch.Remove(p.Key);
                                }
                            }
                        });
                    } while (inventoryFolders.Any());
                }
                catch (Exception)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_UPDATING_INVENTORY));
                }
            })
            {IsBackground = true, Priority = ThreadPriority.Lowest};

            updateInventoryRecursiveThread.Start();
            updateInventoryRecursiveThread.Join(Timeout.Infinite);
        };

        /// <summary>
        ///     Loads the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action LoadInventoryCache = () =>
        {
            int itemsLoaded =
                Client.Inventory.Store.RestoreFromDisk(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                    CORRADE_CONSTANTS.INVENTORY_CACHE_FILE));

            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_LOADED),
                itemsLoaded < 0 ? "0" : itemsLoaded.ToString(CultureInfo.DefaultThreadCurrentCulture));
        };

        /// <summary>
        ///     Saves the OpenMetaverse inventory cache.
        /// </summary>
        private static readonly System.Action SaveInventoryCache = () =>
        {
            string path = Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                CORRADE_CONSTANTS.INVENTORY_CACHE_FILE);
            int itemsSaved = Client.Inventory.Store.Items.Count;
            Client.Inventory.Store.SaveToDisk(path);

            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.INVENTORY_CACHE_ITEMS_SAVED),
                itemsSaved.ToString(CultureInfo.DefaultThreadCurrentCulture));
        };

        /// <summary>
        ///     Loads Corrade's caches.
        /// </summary>
        private static readonly System.Action LoadCorradeCache = () =>
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.AgentCache =
                    Cache.Load(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                        Cache.AgentCache);
            }
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.GroupCache =
                    Cache.Load(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                        Cache.GroupCache);
            }
        };

        /// <summary>
        ///     Saves Corrade's caches.
        /// </summary>
        private static readonly System.Action SaveCorradeCache = () =>
        {
            lock (Cache.Locks.AgentCacheLock)
            {
                Cache.Save(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.AGENT_CACHE_FILE),
                    Cache.AgentCache);
            }
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Save(Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY, CORRADE_CONSTANTS.GROUP_CACHE_FILE),
                    Cache.GroupCache);
            }
        };

        /// <summary>
        ///     Saves Corrade group members.
        /// </summary>
        private static readonly System.Action SaveGroupMembersState = () =>
        {
            if (GroupMembers.Any())
            {
                try
                {
                    using (
                        StreamWriter writer =
                            new StreamWriter(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                                CORRADE_CONSTANTS.GROUP_MEMBERS_STATE_FILE), false, Encoding.UTF8))
                    {
                        XmlSerializer serializer =
                            new XmlSerializer(typeof (SerializableDictionary<UUID, HashSet<UUID>>));
                        serializer.Serialize(writer, GroupMembers);
                        writer.Flush();
                    }
                }
                catch (Exception e)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_GROUP_MEMBERS_STATE),
                        e.Message);
                }
            }
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadGroupMembersState = () =>
        {
            string groupMembersStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.GROUP_MEMBERS_STATE_FILE);
            if (File.Exists(groupMembersStateFile))
            {
                try
                {
                    using (StreamReader stream = new StreamReader(groupMembersStateFile, Encoding.UTF8))
                    {
                        XmlSerializer serializer =
                            new XmlSerializer(typeof (SerializableDictionary<UUID, HashSet<UUID>>));
                        Parallel.ForEach((SerializableDictionary<UUID, HashSet<UUID>>) serializer.Deserialize(stream),
                            o =>
                            {
                                if (!corradeConfiguration.Groups.AsParallel().Any(p => p.UUID.Equals(o.Key)) ||
                                    GroupMembers.Contains(o))
                                    return;
                                lock (GroupMembersLock)
                                {
                                    GroupMembers.Add(o.Key, o.Value);
                                }
                            });
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_GROUP_MEMBERS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Saves Corrade notifications.
        /// </summary>
        private static readonly System.Action SaveNotificationState = () =>
        {
            NotificationsWatcher.EnableRaisingEvents = false;
            try
            {
                using (
                    StreamWriter writer =
                        new StreamWriter(Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                            CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE), false, Encoding.UTF8))
                {
                    XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                    serializer.Serialize(writer, GroupNotifications);
                    writer.Flush();
                }
            }
            catch (Exception e)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE),
                    e.Message);
            }
            NotificationsWatcher.EnableRaisingEvents = true;
        };

        /// <summary>
        ///     Loads Corrade notifications.
        /// </summary>
        private static readonly System.Action LoadNotificationState = () =>
        {
            string groupNotificationsStateFile = Path.Combine(CORRADE_CONSTANTS.STATE_DIRECTORY,
                CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE);
            if (File.Exists(groupNotificationsStateFile))
            {
                try
                {
                    using (StreamReader stream = new StreamReader(groupNotificationsStateFile, Encoding.UTF8))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (HashSet<Notification>));
                        Parallel.ForEach((HashSet<Notification>) serializer.Deserialize(stream),
                            o =>
                            {
                                if (!corradeConfiguration.Groups.AsParallel().Any(p => p.Name.Equals(o.GroupName)) ||
                                    GroupNotifications.Contains(o))
                                    return;
                                lock (GroupNotificationsLock)
                                {
                                    GroupNotifications.Add(o);
                                }
                            });
                    }
                }
                catch (Exception ex)
                {
                    Feedback(
                        wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE),
                        ex.Message);
                }
            }
        };

        /// <summary>
        ///     Loads the chatbot configuration and AIML files.
        /// </summary>
        private static readonly System.Action LoadChatBotFiles = () =>
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READING_AIML_BOT_CONFIGURATION));
            try
            {
                AIMLBot.isAcceptingUserInput = false;
                AIMLBot.loadSettings(wasPathCombine(
                    Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                    AIML_BOT_CONSTANTS.CONFIG.DIRECTORY, AIML_BOT_CONSTANTS.CONFIG.SETTINGS_FILE));
                string AIMLBotBrain =
                    wasPathCombine(
                        Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                        AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_FILE);
                switch (File.Exists(AIMLBotBrain))
                {
                    case true:
                        AIMLBot.loadFromBinaryFile(AIMLBotBrain);
                        break;
                    default:
                        AIMLBot.loadAIMLFromFiles();
                        AIMLBot.saveToBinaryFile(AIMLBotBrain);
                        break;
                }
                string AIMLBotUserBrain =
                    wasPathCombine(
                        Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                        AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_SESSION_FILE);
                if (File.Exists(AIMLBotUserBrain))
                {
                    AIMLBotUser.Predicates.loadSettings(AIMLBotUserBrain);
                }
                AIMLBot.isAcceptingUserInput = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_LOADING_AIML_BOT_FILES), ex.Message);
                return;
            }
            finally
            {
                AIMLBotBrainCompiled = true;
            }
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READ_AIML_BOT_CONFIGURATION));
        };

        /// <summary>
        ///     Saves the chatbot configuration and AIML files.
        /// </summary>
        private static readonly System.Action SaveChatBotFiles = () =>
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WRITING_AIML_BOT_CONFIGURATION));
            try
            {
                AIMLBot.isAcceptingUserInput = false;
                AIMLBotUser.Predicates.DictionaryAsXML.Save(wasPathCombine(
                    Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                    AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_SESSION_FILE));
                AIMLBot.isAcceptingUserInput = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SAVING_AIML_BOT_FILES), ex.Message);
                return;
            }
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WROTE_AIML_BOT_CONFIGURATION));
        };

        private static volatile bool runHTTPServer;
        private static volatile bool runCallbackThread = true;
        private static volatile bool runNotificationThread = true;
        private static volatile bool runGroupMembershipSweepThread;
        private static volatile bool runEffectsExpirationThread;

        public Corrade()
        {
            if (Environment.UserInteractive) return;
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32NT:
                    try
                    {
                        InstalledServiceName = (string)
                            new ManagementObjectSearcher("SELECT * FROM Win32_Service where ProcessId = " +
                                                         Process.GetCurrentProcess().Id).Get()
                                .Cast<ManagementBaseObject>()
                                .First()["Name"];
                    }
                    catch (Exception)
                    {
                        InstalledServiceName = CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME;
                    }
                    break;
                default:
                    InstalledServiceName = CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME;
                    break;
            }
            CorradeEventLog.Source = InstalledServiceName;
            CorradeEventLog.Log = CORRADE_CONSTANTS.LOG_FACILITY;
            ((ISupportInitialize) (CorradeEventLog)).BeginInit();
            if (!EventLog.SourceExists(CorradeEventLog.Source))
            {
                EventLog.CreateEventSource(CorradeEventLog.Source, CorradeEventLog.Log);
            }
            ((ISupportInitialize) (CorradeEventLog)).EndInit();
        }

        /// <summary>
        ///     Sweep for group members.
        /// </summary>
        private static void GroupMembershipSweep()
        {
            Queue<UUID> groupUUIDs = new Queue<UUID>();
            Queue<int> memberCount = new Queue<int>();
            // The total list of members.
            HashSet<UUID> groupMembers = new HashSet<UUID>();
            // New members that have joined the group.
            HashSet<UUID> joinedMembers = new HashSet<UUID>();
            // Members that have parted the group.
            HashSet<UUID> partedMembers = new HashSet<UUID>();

            ManualResetEvent GroupMembersReplyEvent = new ManualResetEvent(false);
            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
            {
                lock (GroupMembersLock)
                {
                    if (GroupMembers.ContainsKey(args.GroupID))
                    {
                        object LockObject = new object();
                        Parallel.ForEach(
                            args.Members.Values,
                            o =>
                            {
                                if (GroupMembers[args.GroupID].Contains(o.ID)) return;
                                lock (LockObject)
                                {
                                    joinedMembers.Add(o.ID);
                                }
                            });
                        Parallel.ForEach(
                            GroupMembers[args.GroupID],
                            o =>
                            {
                                if (args.Members.Values.Any(p => p.ID.Equals(o))) return;
                                lock (LockObject)
                                {
                                    partedMembers.Add(o);
                                }
                            });
                    }
                }
                groupMembers.UnionWith(args.Members.Values.Select(o => o.ID));
                GroupMembersReplyEvent.Set();
            };

            while (runGroupMembershipSweepThread)
            {
                Thread.Sleep((int) corradeConfiguration.MembershipSweepInterval);
                if (!Client.Network.Connected) continue;

                IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                if (!GetCurrentGroups(corradeConfiguration.ServicesTimeout, ref currentGroups))
                    continue;

                // Enqueue configured groups that are currently joined groups.
                groupUUIDs.Clear();
                object LockObject = new object();
                Parallel.ForEach(
                    corradeConfiguration.Groups.AsParallel().Select(o => new {group = o, groupUUID = o.UUID})
                        .Where(p => currentGroups.ToList().Any(o => o.Equals(p.groupUUID)))
                        .Select(o => o.group), o =>
                        {
                            lock (LockObject)
                            {
                                groupUUIDs.Enqueue(o.UUID);
                            }
                        });


                // Bail if no configured groups are also joined.
                if (!groupUUIDs.Any()) continue;

                // Get the last member count.
                memberCount.Clear();
                lock (GroupMembersLock)
                {
                    Parallel.ForEach(GroupMembers.AsParallel().SelectMany(
                        members => groupUUIDs,
                        (members, groupUUID) => new {members, groupUUID})
                        .Where(o => o.groupUUID.Equals(o.members.Key))
                        .Select(p => p.members), o =>
                        {
                            lock (LockObject)
                            {
                                memberCount.Enqueue(o.Value.Count);
                            }
                        });
                }

                do
                {
                    // Pause a second between group sweeps.
                    Thread.Sleep(1000);
                    // Dequeue the first group.
                    UUID groupUUID = groupUUIDs.Dequeue();
                    // Clear the total list of members.
                    groupMembers.Clear();
                    // Clear the members that have joined the group.
                    joinedMembers.Clear();
                    // Clear the members that have left the group.
                    partedMembers.Clear();
                    lock (ClientInstanceGroupsLock)
                    {
                        Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                        GroupMembersReplyEvent.Reset();
                        Client.Groups.RequestGroupMembers(groupUUID);
                        if (!GroupMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                        {
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                            continue;
                        }
                        Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                    }

                    if (!GroupMembers.ContainsKey(groupUUID))
                    {
                        lock (GroupMembersLock)
                        {
                            GroupMembers.Add(groupUUID, new HashSet<UUID>(groupMembers));
                        }
                        continue;
                    }

                    if (memberCount.Any())
                    {
                        if (!memberCount.Dequeue().Equals(groupMembers.Count))
                        {
                            if (joinedMembers.Any())
                            {
                                Parallel.ForEach(
                                    joinedMembers,
                                    o =>
                                    {
                                        string agentName = string.Empty;
                                        string groupName = string.Empty;
                                        if (AgentUUIDToName(
                                            o,
                                            corradeConfiguration.ServicesTimeout,
                                            ref agentName) &&
                                            GroupUUIDToName(groupUUID, corradeConfiguration.ServicesTimeout,
                                                ref groupName))
                                        {
                                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                                () => SendNotification(
                                                    Notifications.GroupMembership,
                                                    new GroupMembershipEventArgs
                                                    {
                                                        AgentName = agentName,
                                                        AgentUUID = o,
                                                        Action = Action.JOINED,
                                                        GroupName = groupName,
                                                        GroupUUID = groupUUID
                                                    }),
                                                corradeConfiguration.MaximumNotificationThreads);
                                        }
                                    });
                            }
                            joinedMembers.Clear();
                            if (partedMembers.Any())
                            {
                                Parallel.ForEach(
                                    partedMembers,
                                    o =>
                                    {
                                        string agentName = string.Empty;
                                        string groupName = string.Empty;
                                        if (AgentUUIDToName(
                                            o,
                                            corradeConfiguration.ServicesTimeout,
                                            ref agentName) &&
                                            GroupUUIDToName(groupUUID, corradeConfiguration.ServicesTimeout,
                                                ref groupName))
                                        {
                                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                                () => SendNotification(
                                                    Notifications.GroupMembership,
                                                    new GroupMembershipEventArgs
                                                    {
                                                        AgentName = agentName,
                                                        AgentUUID = o,
                                                        Action = Action.PARTED,
                                                        GroupName = groupName,
                                                        GroupUUID = groupUUID
                                                    }),
                                                corradeConfiguration.MaximumNotificationThreads);
                                        }
                                    });
                            }
                        }
                        partedMembers.Clear();
                    }
                    lock (GroupMembersLock)
                    {
                        GroupMembers[groupUUID].Clear();
                        Parallel.ForEach(groupMembers, o =>
                        {
                            lock (LockObject)
                            {
                                GroupMembers[groupUUID].Add(o);
                            }
                        });
                    }
                    groupMembers.Clear();
                } while (groupUUIDs.Any() && runGroupMembershipSweepThread);
            }
        }

        private static bool ConsoleCtrlCheck(NativeMethods.CtrlType ctrlType)
        {
            // Set the user disconnect semaphore.
            ConnectionSemaphores['u'].Set();
            // Wait for threads to finish.
            Thread.Sleep((int) corradeConfiguration.ServicesTimeout);
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Serialize an RLV message to a string.
        /// </summary>
        /// <returns>in order: behaviours, options, parameters</returns>
        private static IEnumerable<string> wasRLVToString(string message)
        {
            if (string.IsNullOrEmpty(message)) yield break;

            // Split all commands.
            string[] unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            string first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            Match match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            yield return match.Groups["behaviour"].ToString().ToLowerInvariant();
            yield return match.Groups["option"].ToString().ToLowerInvariant();
            yield return match.Groups["param"].ToString().ToLowerInvariant();

            CONTINUE:
            foreach (string slice in wasRLVToString(message))
            {
                yield return slice;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Combine multiple paths.
        /// </summary>
        /// <param name="paths">an array of paths</param>
        /// <returns>a combined path</returns>
        private static string wasPathCombine(params string[] paths)
        {
            return paths.Any()
                ? paths.Length < 2
                    ? paths[0]
                    : Path.Combine(Path.Combine(paths[0], paths[1]), wasPathCombine(paths.Skip(2).ToArray()))
                : string.Empty;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Retrieves an attribute of type T from an enumeration.
        /// </summary>
        /// <returns>an attribute of type T</returns>
        private static T wasGetAttributeFromEnumValue<T>(Enum value)
        {
            return (T) value.GetType()
                .GetField(value.ToString())
                .GetCustomAttributes(typeof (T), false)
                .SingleOrDefault();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns all the attributes of type T of an enumeration.
        /// </summary>
        /// <typeparam name="T">the attribute to retrieve</typeparam>
        /// <returns>a list of attributes</returns>
        private static IEnumerable<T> wasGetEnumAttributes<T>(Enum e)
        {
            return e.GetType().GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel().Select(o => wasGetAttributeFromEnumValue<T>((Enum) o.GetValue(null)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns all the field descriptions of an enumeration.
        /// </summary>
        /// <returns>the field descriptions</returns>
        private static IEnumerable<string> wasGetEnumDescriptions<T>()
        {
            return typeof (T).GetFields(BindingFlags.Static | BindingFlags.Public)
                .AsParallel().Select(o => wasGetDescriptionFromEnumValue((Enum) o.GetValue(null)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the description from an enumeration value.
        /// </summary>
        /// <param name="value">an enumeration value</param>
        /// <returns>the description or the empty string</returns>
        private static string wasGetDescriptionFromEnumValue(Enum value)
        {
            DescriptionAttribute attribute = value.GetType()
                .GetField(value.ToString())
                .GetCustomAttributes(typeof (DescriptionAttribute), false)
                .SingleOrDefault() as DescriptionAttribute;
            return attribute != null ? attribute.Description : string.Empty;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get enumeration value from its description.
        /// </summary>
        /// <typeparam name="T">the enumeration type</typeparam>
        /// <param name="description">the description of a member</param>
        /// <returns>the value or the default of T if case no description found</returns>
        private static T wasGetEnumValueFromDescription<T>(string description)
        {
            var field = typeof (T).GetFields()
                .AsParallel().SelectMany(f => f.GetCustomAttributes(
                    typeof (DescriptionAttribute), false), (
                        f, a) => new {Field = f, Att = a}).SingleOrDefault(a => ((DescriptionAttribute) a.Att)
                            .Description.Equals(description));
            return field != null ? (T) field.Field.GetRawConstantValue() : default(T);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the description of structure member.
        /// </summary>
        /// <typeparam name="T">the type of the structure to search</typeparam>
        /// <param name="structure">the structure to search</param>
        /// <param name="item">the value of the item to search</param>
        /// <returns>the description or the empty string</returns>
        private static string wasGetStructureMemberDescription<T>(T structure, object item) where T : struct
        {
            var field = typeof (T).GetFields()
                .AsParallel().SelectMany(f => f.GetCustomAttributes(typeof (DescriptionAttribute), false),
                    (f, a) => new {Field = f, Att = a}).SingleOrDefault(f => f.Field.GetValue(structure).Equals(item));
            return field != null ? ((DescriptionAttribute) field.Att).Description : string.Empty;
        }

        /// <summary>
        ///     Can an inventory item be worn?
        /// </summary>
        /// <param name="item">item to check</param>
        /// <returns>true if the inventory item can be worn</returns>
        private static bool CanBeWorn(InventoryBase item)
        {
            return item is InventoryWearable || item is InventoryAttachment || item is InventoryObject;
        }

        /// <summary>
        ///     Resolves inventory links and returns a real inventory item that
        ///     the link is pointing to
        /// </summary>
        /// <param name="item">a link or inventory item</param>
        /// <returns>the real inventory item</returns>
        private static InventoryItem ResolveItemLink(InventoryItem item)
        {
            return item.IsLink() && Client.Inventory.Store.Contains(item.AssetUUID) &&
                   Client.Inventory.Store[item.AssetUUID] is InventoryItem
                ? Client.Inventory.Store[item.AssetUUID] as InventoryItem
                : item;
        }

        /// <summary>
        ///     Get current outfit folder links.
        /// </summary>
        /// <returns>a list of inventory items that can be part of appearance (attachments, wearables)</returns>
        private static HashSet<InventoryItem> GetCurrentOutfitFolderLinks(InventoryFolder outfitFolder)
        {
            HashSet<InventoryItem> ret = new HashSet<InventoryItem>();
            if (outfitFolder == null) return ret;

            object LockObject = new object();
            Parallel.ForEach(
                Client.Inventory.Store.GetContents(outfitFolder)
                    .AsParallel()
                    .Where(o => CanBeWorn(o) && ((InventoryItem) o).AssetType.Equals(AssetType.Link)),
                o =>
                {
                    lock (LockObject)
                    {
                        ret.Add((InventoryItem) o);
                    }
                });

            return ret;
        }

        private static void Attach(InventoryItem item, AttachmentPoint point, bool replace)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.Attach(realItem, point, replace);
                AddLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        private static void Detach(InventoryItem item)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                RemoveLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
                Client.Appearance.Detach(realItem);
            }
        }

        private static void Wear(InventoryItem item, bool replace)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.AddToOutfit(realItem, replace);
                AddLink(realItem,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        private static void UnWear(InventoryItem item)
        {
            lock (ClientInstanceInventoryLock)
            {
                InventoryItem realItem = ResolveItemLink(item);
                if (realItem == null) return;
                Client.Appearance.RemoveFromOutfit(realItem);
                InventoryItem link = GetCurrentOutfitFolderLinks(
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder)
                    .AsParallel()
                    .FirstOrDefault(o => o.AssetType.Equals(AssetType.Link) && o.Name.Equals(item.Name));
                if (link == null) return;
                RemoveLink(link,
                    Client.Inventory.Store[Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)] as
                        InventoryFolder);
            }
        }

        /// <summary>
        ///     Is the item a body part?
        /// </summary>
        /// <param name="item">the item to check</param>
        /// <returns>true if the item is a body part</returns>
        private static bool IsBodyPart(InventoryItem item)
        {
            InventoryItem realItem = ResolveItemLink(item);
            if (!(realItem is InventoryWearable)) return false;
            WearableType t = ((InventoryWearable) realItem).WearableType;
            return t.Equals(WearableType.Shape) ||
                   t.Equals(WearableType.Skin) ||
                   t.Equals(WearableType.Eyes) ||
                   t.Equals(WearableType.Hair);
        }

        /// <summary>
        ///     Creates a new current outfit folder link.
        /// </summary>
        /// <param name="item">item to be linked</param>
        /// <param name="outfitFolder">the outfit folder</param>
        private static void AddLink(InventoryItem item, InventoryFolder outfitFolder)
        {
            if (outfitFolder == null) return;

            /* If the link already exists, then don't add another one. */
            if (GetCurrentOutfitFolderLinks(outfitFolder).AsParallel().Any(o => o.AssetUUID.Equals(item.UUID))) return;

            string description = (item.InventoryType.Equals(InventoryType.Wearable) && !IsBodyPart(item))
                ? string.Format("@{0}{1:00}", (int) ((InventoryWearable) item).WearableType, 0)
                : string.Empty;
            lock (ClientInstanceInventoryLock)
            {
                Client.Inventory.CreateLink(Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder), item.UUID,
                    item.Name, description, AssetType.Link,
                    item.InventoryType, UUID.Random(), (success, newItem) =>
                    {
                        if (success)
                        {
                            Client.Inventory.RequestFetchInventory(newItem.UUID, newItem.OwnerID);
                        }
                    });
            }
        }

        /// <summary>
        ///     Remove current outfit folder links for multiple specified inventory item.
        /// </summary>
        /// <param name="item">the item whose link should be removed</param>
        /// <param name="outfitFolder">the outfit folder</param>
        private static void RemoveLink(InventoryItem item, InventoryFolder outfitFolder)
        {
            if (outfitFolder == null) return;

            HashSet<UUID> removeItems = new HashSet<UUID>();
            object LockOject = new object();
            Parallel.ForEach(GetCurrentOutfitFolderLinks(outfitFolder).AsParallel().Where(o =>
                o.AssetUUID.Equals(item is InventoryWearable ? item.AssetUUID : item.UUID)), o =>
                {
                    lock (LockOject)
                    {
                        removeItems.Add(o.UUID);
                    }
                });

            lock (ClientInstanceInventoryLock)
            {
                Client.Inventory.Remove(removeItems.ToList(), null);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Swaps two integers passed by reference using XOR.
        /// </summary>
        /// <param name="q">first integer to swap</param>
        /// <param name="p">second integer to swap</param>
        private static void wasXORSwap(ref int q, ref int p)
        {
            q ^= p;
            p ^= q;
            q ^= p;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the fields of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<FieldInfo, object>> wasGetFields(object @object, string @namespace)
        {
            if (@object == null) yield break;

            foreach (FieldInfo fi in @object.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public))
            {
                if (fi.FieldType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.InvariantCultureIgnoreCase))
                {
                    foreach (KeyValuePair<FieldInfo, object> sf in wasGetFields(fi.GetValue(@object), @namespace))
                    {
                        yield return sf;
                    }
                }
                yield return new KeyValuePair<FieldInfo, object>(fi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Enumerates the properties of an object along with the child objects,
        ///     provided that all child objects are part of a specified namespace.
        /// </summary>
        /// <param name="object">the object to enumerate</param>
        /// <param name="namespace">the namespace to enumerate in</param>
        /// <returns>child objects of the object</returns>
        private static IEnumerable<KeyValuePair<PropertyInfo, object>> wasGetProperties(object @object,
            string @namespace)
        {
            if (@object == null) yield break;

            foreach (PropertyInfo pi in @object.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public))
            {
                if (pi.PropertyType.FullName.Split('.', '+')
                    .Contains(@namespace, StringComparer.InvariantCultureIgnoreCase))
                {
                    MethodInfo getMethod = pi.GetGetMethod();
                    if (getMethod.ReturnType.IsArray)
                    {
                        var array = (Array) getMethod.Invoke(@object, null);
                        foreach (KeyValuePair<PropertyInfo, object> sp in
                            array.Cast<object>().SelectMany(element => wasGetProperties(element, @namespace)))
                        {
                            yield return sp;
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> sp in
                            wasGetProperties(pi.GetValue(@object, null), @namespace))
                    {
                        yield return sp;
                    }
                }
                yield return new KeyValuePair<PropertyInfo, object>(pi, @object);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo SetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="object">the object to set the value on</param>
        /// <param name="value">the value to set</param>
        private static void wasSetInfoValue<TK, TV>(TK info, ref TV @object, object value)
        {
            object o = @object;
            FieldInfo fi = (object) info as FieldInfo;
            if (fi != null)
            {
                fi.SetValue(o, value);
                @object = (TV) o;
                return;
            }
            PropertyInfo pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                pi.SetValue(o, value, null);
                @object = (TV) o;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     This is a wrapper for both FieldInfo and PropertyInfo GetValue.
        /// </summary>
        /// <param name="info">either a FieldInfo or PropertyInfo</param>
        /// <param name="value">the object to get from</param>
        /// <returns>the value of the field or property</returns>
        private static object wasGetInfoValue<T>(T info, object value)
        {
            FieldInfo fi = (object) info as FieldInfo;
            if (fi != null)
            {
                return fi.GetValue(value);
            }
            PropertyInfo pi = (object) info as PropertyInfo;
            if (pi != null)
            {
                if (pi.GetIndexParameters().Any())
                {
                    return value;
                }
                return pi.GetValue(value, null);
            }
            return null;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     The function gets the value from FieldInfo or PropertyInfo.
        /// </summary>
        /// <param name="info">a FieldInfo or PropertyInfo structure</param>
        /// <param name="value">the value to get</param>
        /// <returns>the value or values as a string</returns>
        private static IEnumerable<string> wasGetInfo(object info, object value)
        {
            if (info == null) yield break;
            object data = wasGetInfoValue(info, value);
            if (data == null) yield break;
            // Handle arrays and lists
            if (data is Array || data is IList)
            {
                IList iList = (IList) data;
                foreach (object item in iList.Cast<object>().Where(o => o != null))
                {
                    // These are index collections so pre-prend an index.
                    yield return "Index";
                    yield return iList.IndexOf(item).ToString();
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(item, item.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (KeyValuePair<PropertyInfo, object> pi in wasGetProperties(item, item.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Don't bother with primitive types.
                    if (item.GetType().IsPrimitive)
                    {
                        yield return item.ToString();
                    }
                }
                yield break;
            }
            // Handle Dictionary
            if (data is IDictionary)
            {
                IDictionary dictionary = (IDictionary) data;
                foreach (DictionaryEntry entry in dictionary)
                {
                    // First the keys.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Then the values.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                        )
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in
                            wasGetProperties(entry.Value, entry.Value.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                }
                yield break;
            }
            // Handle InternalDictionary
            FieldInfo internalDictionaryInfo = data.GetType()
                .GetField("Dictionary",
                    BindingFlags.Default | BindingFlags.CreateInstance | BindingFlags.Instance | BindingFlags.NonPublic);
            if (internalDictionaryInfo != null)
            {
                IDictionary iDictionary = internalDictionaryInfo.GetValue(data) as IDictionary;
                if (iDictionary == null) yield break;
                foreach (DictionaryEntry entry in iDictionary)
                {
                    // First the keys.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Key, entry.Key.GetType().Name))
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in wasGetProperties(entry.Key, entry.Key.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                    // Then the values.
                    foreach (KeyValuePair<FieldInfo, object> fi in wasGetFields(entry.Value, entry.Value.GetType().Name)
                        )
                    {
                        if (fi.Key != null)
                        {
                            foreach (string fieldString in wasGetInfo(fi.Key, fi.Value))
                            {
                                yield return fi.Key.Name;
                                yield return fieldString;
                            }
                        }
                    }
                    foreach (
                        KeyValuePair<PropertyInfo, object> pi in
                            wasGetProperties(entry.Value, entry.Value.GetType().Name))
                    {
                        if (pi.Key != null)
                        {
                            foreach (string propertyString in wasGetInfo(pi.Key, pi.Value))
                            {
                                yield return pi.Key.Name;
                                yield return propertyString;
                            }
                        }
                    }
                }
                yield break;
            }

            string @string = data.ToString();
            if (string.IsNullOrEmpty(@string)) yield break;
            yield return @string;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Sets the value of FieldInfo or PropertyInfo.
        /// </summary>
        /// <typeparam name="T">the type to set</typeparam>
        /// <param name="info">a FieldInfo or PropertyInfo object</param>
        /// <param name="value">the object's value</param>
        /// <param name="setting">the value to set to</param>
        /// <param name="object">the object to set the values for</param>
        private static void wasSetInfo<T>(object info, object value, string setting, ref T @object)
        {
            if (info == null) return;

            // OpenMetaverse particular flags.
            if (wasGetInfoValue(info, value) is ParcelFlags)
            {
                uint parcelFlags;
                switch (!uint.TryParse(setting, out parcelFlags))
                {
                    case true:
                        Parallel.ForEach(wasCSVToEnumerable(setting).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                            {
                                Parallel.ForEach(
                                    typeof (ParcelFlags).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    p => { parcelFlags |= ((uint) p.GetValue(null)); });
                            });
                        break;
                }
                wasSetInfoValue(info, ref @object, parcelFlags);
                return;
            }
            if (wasGetInfoValue(info, value) is GroupPowers)
            {
                uint groupPowers;
                switch (!uint.TryParse(setting, out groupPowers))
                {
                    case true:
                        Parallel.ForEach(wasCSVToEnumerable(setting).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                            {
                                Parallel.ForEach(
                                    typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    p => { groupPowers |= ((uint) p.GetValue(null)); });
                            });
                        break;
                }
                wasSetInfoValue(info, ref @object, groupPowers);
                return;
            }
            if (wasGetInfoValue(info, value) is AttachmentPoint)
            {
                byte attachmentPoint;
                switch (!byte.TryParse(setting, out attachmentPoint))
                {
                    case true:
                        FieldInfo attachmentPointFieldInfo =
                            typeof (AttachmentPoint).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel()
                                .FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (attachmentPointFieldInfo == null) break;
                        attachmentPoint = (byte) attachmentPointFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, attachmentPoint);
                return;
            }
            if (wasGetInfoValue(info, value) is Tree)
            {
                byte tree;
                switch (!byte.TryParse(setting, out tree))
                {
                    case true:
                        FieldInfo treeFieldInfo = typeof (Tree).GetFields(BindingFlags.Public |
                                                                          BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (treeFieldInfo == null) break;
                        tree = (byte) treeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, tree);
                return;
            }
            if (wasGetInfoValue(info, value) is Material)
            {
                byte material;
                switch (!byte.TryParse(setting, out material))
                {
                    case true:
                        FieldInfo materialFieldInfo = typeof (Material).GetFields(BindingFlags.Public |
                                                                                  BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (materialFieldInfo == null) break;
                        material = (byte) materialFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, material);
                return;
            }
            if (wasGetInfoValue(info, value) is PathCurve)
            {
                byte pathCurve;
                switch (!byte.TryParse(setting, out pathCurve))
                {
                    case true:
                        FieldInfo pathCurveFieldInfo = typeof (PathCurve).GetFields(BindingFlags.Public |
                                                                                    BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (pathCurveFieldInfo == null) break;
                        pathCurve = (byte) pathCurveFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, pathCurve);
                return;
            }
            if (wasGetInfoValue(info, value) is PCode)
            {
                byte pCode;
                switch (!byte.TryParse(setting, out pCode))
                {
                    case true:
                        FieldInfo pCodeFieldInfo = typeof (PCode).GetFields(BindingFlags.Public | BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (pCodeFieldInfo == null) break;
                        pCode = (byte) pCodeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, pCode);
                return;
            }
            if (wasGetInfoValue(info, value) is ProfileCurve)
            {
                byte profileCurve;
                switch (!byte.TryParse(setting, out profileCurve))
                {
                    case true:
                        FieldInfo profileCurveFieldInfo =
                            typeof (ProfileCurve).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel()
                                .FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (profileCurveFieldInfo == null) break;
                        profileCurve = (byte) profileCurveFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, profileCurve);
                return;
            }
            if (wasGetInfoValue(info, value) is HoleType)
            {
                byte holeType;
                switch (!byte.TryParse(setting, out holeType))
                {
                    case true:
                        FieldInfo holeTypeFieldInfo = typeof (HoleType).GetFields(BindingFlags.Public |
                                                                                  BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (holeTypeFieldInfo == null) break;
                        holeType = (byte) holeTypeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, holeType);
                return;
            }
            if (wasGetInfoValue(info, value) is SculptType)
            {
                byte sculptType;
                switch (!byte.TryParse(setting, out sculptType))
                {
                    case true:
                        FieldInfo sculptTypeFieldInfo = typeof (SculptType).GetFields(BindingFlags.Public |
                                                                                      BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(setting, StringComparison.Ordinal));
                        if (sculptTypeFieldInfo == null) break;
                        sculptType = (byte) sculptTypeFieldInfo.GetValue(null);
                        break;
                }
                wasSetInfoValue(info, ref @object, sculptType);
                return;
            }
            // OpenMetaverse Primitive Types
            if (wasGetInfoValue(info, value) is UUID)
            {
                UUID UUIDData;
                if (!UUID.TryParse(setting, out UUIDData))
                {
                    InventoryItem item = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                        setting).FirstOrDefault() as InventoryItem;
                    if (item == null)
                    {
                        throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                    }
                    UUIDData = item.UUID;
                }
                switch (!UUIDData.Equals(UUID.Zero))
                {
                    case true:
                        wasSetInfoValue(info, ref @object, UUIDData);
                        return;
                    default:
                        throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                }
            }
            if (wasGetInfoValue(info, value) is Vector3)
            {
                Vector3 vector3Data;
                if (Vector3.TryParse(setting, out vector3Data))
                {
                    wasSetInfoValue(info, ref @object, vector3Data);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is Vector2)
            {
                Vector3 vector2Data;
                if (Vector2.TryParse(setting, out vector2Data))
                {
                    wasSetInfoValue(info, ref @object, vector2Data);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is Vector3d)
            {
                Vector3d vector3DData;
                if (Vector3d.TryParse(setting, out vector3DData))
                {
                    wasSetInfoValue(info, ref @object, vector3DData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is Vector4)
            {
                Vector4 vector4Data;
                if (Vector4.TryParse(setting, out vector4Data))
                {
                    wasSetInfoValue(info, ref @object, vector4Data);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is Quaternion)
            {
                Quaternion quaternionData;
                if (Quaternion.TryParse(setting, out quaternionData))
                {
                    wasSetInfoValue(info, ref @object, quaternionData);
                    return;
                }
            }
            // Primitive types.
            if (wasGetInfoValue(info, value) is bool)
            {
                bool boolData;
                if (bool.TryParse(setting, out boolData))
                {
                    wasSetInfoValue(info, ref @object, boolData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is char)
            {
                char charData;
                if (char.TryParse(setting, out charData))
                {
                    wasSetInfoValue(info, ref @object, charData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is decimal)
            {
                decimal decimalData;
                if (decimal.TryParse(setting, out decimalData))
                {
                    wasSetInfoValue(info, ref @object, decimalData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is byte)
            {
                byte byteData;
                if (byte.TryParse(setting, out byteData))
                {
                    wasSetInfoValue(info, ref @object, byteData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is int)
            {
                int intData;
                if (int.TryParse(setting, out intData))
                {
                    wasSetInfoValue(info, ref @object, intData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is uint)
            {
                uint uintData;
                if (uint.TryParse(setting, out uintData))
                {
                    wasSetInfoValue(info, ref @object, uintData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is float)
            {
                float floatData;
                if (float.TryParse(setting, out floatData))
                {
                    wasSetInfoValue(info, ref @object, floatData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is long)
            {
                long longData;
                if (long.TryParse(setting, out longData))
                {
                    wasSetInfoValue(info, ref @object, longData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is float)
            {
                float singleData;
                if (float.TryParse(setting, out singleData))
                {
                    wasSetInfoValue(info, ref @object, singleData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is DateTime)
            {
                DateTime dateTimeData;
                if (DateTime.TryParse(setting, out dateTimeData))
                {
                    wasSetInfoValue(info, ref @object, dateTimeData);
                    return;
                }
            }
            if (wasGetInfoValue(info, value) is string)
            {
                wasSetInfoValue(info, ref @object, setting);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts Linden item permissions to a formatted string:
        ///     CDEMVT - Copy, Damage, Export, Modify, Move, Transfer
        ///     BBBBBBEEEEEEGGGGGGNNNNNNOOOOOO - Base, Everyone, Group, Next, Owner
        /// </summary>
        /// <param name="permissions">the item permissions</param>
        /// <returns>the literal permissions for an item</returns>
        private static string wasPermissionsToString(OpenMetaverse.Permissions permissions)
        {
            Func<PermissionMask, string> segment = o =>
            {
                StringBuilder seg = new StringBuilder();

                switch (!((uint) o & (uint) PermissionMask.Copy).Equals(0))
                {
                    case true:
                        seg.Append("c");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Damage).Equals(0))
                {
                    case true:
                        seg.Append("d");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Export).Equals(0))
                {
                    case true:
                        seg.Append("e");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Modify).Equals(0))
                {
                    case true:
                        seg.Append("m");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Move).Equals(0))
                {
                    case true:
                        seg.Append("v");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                switch (!((uint) o & (uint) PermissionMask.Transfer).Equals(0))
                {
                    case true:
                        seg.Append("t");
                        break;
                    default:
                        seg.Append("-");
                        break;
                }

                return seg.ToString();
            };

            StringBuilder x = new StringBuilder();
            x.Append(segment(permissions.BaseMask));
            x.Append(segment(permissions.EveryoneMask));
            x.Append(segment(permissions.GroupMask));
            x.Append(segment(permissions.NextOwnerMask));
            x.Append(segment(permissions.OwnerMask));
            return x.ToString();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a formatted string to item permissions:
        ///     CDEMVT - Copy, Damage, Export, Modify, Move, Transfer
        ///     BBBBBBEEEEEEGGGGGGNNNNNNOOOOOO - Base, Everyone, Group, Next, Owner
        /// </summary>
        /// <param name="permissions">the item permissions</param>
        /// <returns>the permissions for an item</returns>
        private static OpenMetaverse.Permissions wasStringToPermissions(string permissions)
        {
            Func<string, uint> segment = o =>
            {
                uint r = 0;
                switch (!char.ToLower(o[0]).Equals('c'))
                {
                    case false:
                        r |= (uint) PermissionMask.Copy;
                        break;
                }

                switch (!char.ToLower(o[1]).Equals('d'))
                {
                    case false:
                        r |= (uint) PermissionMask.Damage;
                        break;
                }

                switch (!char.ToLower(o[2]).Equals('e'))
                {
                    case false:
                        r |= (uint) PermissionMask.Export;
                        break;
                }

                switch (!char.ToLower(o[3]).Equals('m'))
                {
                    case false:
                        r |= (uint) PermissionMask.Modify;
                        break;
                }

                switch (!char.ToLower(o[4]).Equals('v'))
                {
                    case false:
                        r |= (uint) PermissionMask.Move;
                        break;
                }

                switch (!char.ToLower(o[5]).Equals('t'))
                {
                    case false:
                        r |= (uint) PermissionMask.Transfer;
                        break;
                }

                return r;
            };

            return new OpenMetaverse.Permissions(segment(permissions.Substring(0, 6)),
                segment(permissions.Substring(6, 6)), segment(permissions.Substring(12, 6)),
                segment(permissions.Substring(18, 6)), segment(permissions.Substring(24, 6)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether an agent has a set of powers for a group.
        /// </summary>
        /// <param name="agentUUID">the agent UUID</param>
        /// <param name="groupUUID">the UUID of the group</param>
        /// <param name="powers">a GroupPowers structure</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <returns>true if the agent has the powers</returns>
        private static bool HasGroupPowers(UUID agentUUID, UUID groupUUID, GroupPowers powers,
            uint millisecondsTimeout)
        {
            ManualResetEvent AvatarGroupsReceivedEvent = new ManualResetEvent(false);
            List<AvatarGroup> avatarGroups = null;
            EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
            {
                avatarGroups = args.Groups;
                AvatarGroupsReceivedEvent.Set();
            };
            lock (ClientInstanceAvatarsLock)
            {
                Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                Client.Avatars.RequestAvatarProperties(agentUUID);
                if (!AvatarGroupsReceivedEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                    return false;
                }
                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
            }
            return avatarGroups != null && avatarGroups.AsParallel().Any(
                o => o.GroupID.Equals(groupUUID) && !(o.GroupPowers & powers).Equals(GroupPowers.None));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Attempts to join the group chat for a given group.
        /// </summary>
        /// <param name="groupUUID">the UUID of the group to join the group chat for</param>
        /// <param name="millisecondsTimeout">timeout for joining the group chat</param>
        /// <returns>true if the group chat was joined</returns>
        private static bool JoinGroupChat(UUID groupUUID, uint millisecondsTimeout)
        {
            bool succeeded = false;
            ManualResetEvent GroupChatJoinedEvent = new ManualResetEvent(false);
            EventHandler<GroupChatJoinedEventArgs> GroupChatJoinedEventHandler =
                (sender, args) =>
                {
                    succeeded = args.Success;
                    GroupChatJoinedEvent.Set();
                };
            lock (ClientInstanceSelfLock)
            {
                Client.Self.GroupChatJoined += GroupChatJoinedEventHandler;
                Client.Self.RequestJoinGroupChat(groupUUID);
                if (!GroupChatJoinedEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Self.GroupChatJoined -= GroupChatJoinedEventHandler;
                    return false;
                }
                Client.Self.GroupChatJoined -= GroupChatJoinedEventHandler;
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether an agent referenced by an UUID is in a group
        ///     referenced by an UUID.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="groupUUID">the UUID of the groupt</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <returns>true if the agent is in the group</returns>
        private static bool AgentInGroup(UUID agentUUID, UUID groupUUID, uint millisecondsTimeout)
        {
            ManualResetEvent groupMembersReceivedEvent = new ManualResetEvent(false);
            Dictionary<UUID, GroupMember> groupMembers = null;
            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
            {
                groupMembers = args.Members;
                groupMembersReceivedEvent.Set();
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                Client.Groups.RequestGroupMembers(groupUUID);
                if (!groupMembersReceivedEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                    return false;
                }
                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
            }
            return groupMembers != null && groupMembers.AsParallel().Any(o => o.Value.ID.Equals(agentUUID));
        }

        /// <summary>
        ///     Used to check whether a group name matches a group password.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="password">the password for the group</param>
        /// <returns>true if the agent has authenticated</returns>
        private static bool Authenticate(string group, string password)
        {
            UUID groupUUID;
            return UUID.TryParse(group, out groupUUID)
                ? corradeConfiguration.Groups.AsParallel().Any(
                    o =>
                        groupUUID.Equals(o.UUID) &&
                        password.Equals(o.Password, StringComparison.Ordinal))
                : corradeConfiguration.Groups.AsParallel().Any(
                    o =>
                        o.Name.Equals(group, StringComparison.OrdinalIgnoreCase) &&
                        password.Equals(o.Password, StringComparison.Ordinal));
        }

        /// <summary>
        ///     Used to check whether a group has certain permissions for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="permission">the numeric Corrade permission</param>
        /// <returns>true if the group has permission</returns>
        private static bool HasCorradePermission(string group, int permission)
        {
            UUID groupUUID;
            return !permission.Equals(0) && UUID.TryParse(group, out groupUUID)
                ? corradeConfiguration.Groups.AsParallel()
                    .Any(o => groupUUID.Equals(o.UUID) && !(o.PermissionMask & permission).Equals(0))
                : corradeConfiguration.Groups.AsParallel().Any(
                    o =>
                        o.Name.Equals(group, StringComparison.OrdinalIgnoreCase) &&
                        !(o.PermissionMask & permission).Equals(0));
        }

        /// <summary>
        ///     Fetches a Corrade group from a key-value formatted message message.
        /// </summary>
        /// <param name="message">the message to inspect</param>
        /// <returns>the configured group</returns>
        private static Group GetCorradeGroupFromMessage(string message)
        {
            string group =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP)), message));
            UUID groupUUID;
            return UUID.TryParse(group, out groupUUID)
                ? corradeConfiguration.Groups.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID))
                : corradeConfiguration.Groups.AsParallel()
                    .FirstOrDefault(o => o.Name.Equals(group, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        ///     Used to check whether a group has a certain notification for Corrade.
        /// </summary>
        /// <param name="group">the name of the group</param>
        /// <param name="notification">the numeric Corrade notification</param>
        /// <returns>true if the group has the notification</returns>
        private static bool GroupHasNotification(string group, uint notification)
        {
            UUID groupUUID;
            return !notification.Equals(0) && UUID.TryParse(group, out groupUUID)
                ? corradeConfiguration.Groups.AsParallel().Any(
                    o => groupUUID.Equals(o.UUID) &&
                         !(o.NotificationMask & notification).Equals(0))
                : corradeConfiguration.Groups.AsParallel().Any(
                    o => o.Name.Equals(group, StringComparison.OrdinalIgnoreCase) &&
                         !(o.NotificationMask & notification).Equals(0));
        }

        /// <summary>
        ///     Used to determine whether the current grid is Second Life.
        /// </summary>
        /// <returns>true if the connected grid is Second Life</returns>
        private static bool IsSecondLife()
        {
            return Client.Network.CurrentSim.SimVersion.Contains(LINDEN_CONSTANTS.GRID.SECOND_LIFE);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches a group.
        /// </summary>
        /// <param name="groupUUID">the UUID of the group</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="group">a group object to store the group profile</param>
        /// <returns>true if the group was found and false otherwise</returns>
        private static bool RequestGroup(UUID groupUUID, uint millisecondsTimeout, ref OpenMetaverse.Group group)
        {
            OpenMetaverse.Group localGroup = new OpenMetaverse.Group();
            ManualResetEvent GroupProfileEvent = new ManualResetEvent(false);
            EventHandler<GroupProfileEventArgs> GroupProfileDelegate = (sender, args) =>
            {
                localGroup = args.Group;
                GroupProfileEvent.Set();
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupProfile += GroupProfileDelegate;
                Client.Groups.RequestGroupProfile(groupUUID);
                if (!GroupProfileEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Groups.GroupProfile -= GroupProfileDelegate;
                    return false;
                }
                Client.Groups.GroupProfile -= GroupProfileDelegate;
            }
            group = localGroup;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get the parcel of a simulator given a position.
        /// </summary>
        /// <param name="simulator">the simulator containing the parcel</param>
        /// <param name="position">a position within the parcel</param>
        /// <param name="parcel">a parcel object where to store the found parcel</param>
        /// <returns>true if the parcel could be found</returns>
        private static bool GetParcelAtPosition(Simulator simulator, Vector3 position,
            ref Parcel parcel)
        {
            ManualResetEvent RequestAllSimParcelsEvent = new ManualResetEvent(false);
            EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedDelegate =
                (sender, args) => RequestAllSimParcelsEvent.Set();
            lock (ClientInstanceParcelsLock)
            {
                Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedDelegate;
                switch (!simulator.IsParcelMapFull())
                {
                    case true:
                        Client.Parcels.RequestAllSimParcels(simulator);
                        break;
                    default:
                        RequestAllSimParcelsEvent.Set();
                        break;
                }
                if (!RequestAllSimParcelsEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                {
                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedDelegate;
                    return false;
                }
                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedDelegate;
            }
            HashSet<Parcel> localParcels = new HashSet<Parcel>();
            simulator.Parcels.ForEach(o =>
            {
                if (!(position.X >= o.AABBMin.X) || !(position.X <= o.AABBMax.X) ||
                    !(position.Y >= o.AABBMin.Y) || !(position.Y <= o.AABBMax.Y))
                    return;
                localParcels.Add(o);
            });
            Parcel localParcel = localParcels.OrderBy(o => Vector3.Distance(o.AABBMin, o.AABBMax)).FirstOrDefault();
            switch (localParcel != null)
            {
                case true:
                    parcel = localParcel;
                    return true;
                default:
                    return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Determines whether a vector falls within a parcel.
        /// </summary>
        /// <param name="position">a 3D vector</param>
        /// <param name="parcel">a parcel</param>
        /// <returns>true if the vector falls within the parcel bounds</returns>
        private static bool IsVectorInParcel(Vector3 position, Parcel parcel)
        {
            return position.X >= parcel.AABBMin.X && position.X <= parcel.AABBMax.X &&
                   position.Y >= parcel.AABBMin.Y && position.Y <= parcel.AABBMax.Y;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Find a named primitive in range (whether attachment or in-world).
        /// </summary>
        /// <param name="item">the name or UUID of the primitive</param>
        /// <param name="range">the range in meters to search for the object</param>
        /// <param name="primitive">a primitive object to store the result</param>
        /// <param name="millisecondsTimeout">the services timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>true if the primitive could be found</returns>
        private static bool FindPrimitive<T>(T item, float range, ref Primitive primitive, uint millisecondsTimeout,
            uint dataTimeout)
        {
            HashSet<Primitive> selectedPrimitives = new HashSet<Primitive>();
            HashSet<Primitive> objectsPrimitives =
                new HashSet<Primitive>(GetPrimitives(range, millisecondsTimeout, dataTimeout));
            HashSet<Avatar> objectsAvatars = new HashSet<Avatar>(GetAvatars(range, millisecondsTimeout, dataTimeout));
            object LockObject = new object();
            Parallel.ForEach(objectsPrimitives, o =>
            {
                switch (o.ParentID)
                {
                    // primitive is a parent and it is in range
                    case 0:
                        if (Vector3.Distance(o.Position, Client.Self.SimPosition) <= range)
                        {
                            if (item is UUID)
                            {
                                switch (!o.ID.Equals(item))
                                {
                                    case false:
                                        lock (LockObject)
                                        {
                                            selectedPrimitives.Add(o);
                                        }
                                        break;
                                }
                                break;
                            }
                            if (item is string)
                            {
                                lock (LockObject)
                                {
                                    selectedPrimitives.Add(o);
                                }
                            }
                        }
                        break;
                    // primitive is a child
                    default:
                        // find the parent of the primitive
                        Primitive primitiveParent = objectsPrimitives.FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                        // if the primitive has a parent
                        if (primitiveParent != null)
                        {
                            // if the parent is in range, add the child
                            if (Vector3.Distance(primitiveParent.Position, Client.Self.SimPosition) <= range)
                            {
                                if (item is UUID)
                                {
                                    switch (!o.ID.Equals(item))
                                    {
                                        case false:
                                            lock (LockObject)
                                            {
                                                selectedPrimitives.Add(o);
                                            }
                                            break;
                                    }
                                    break;
                                }
                                if (item is string)
                                {
                                    lock (LockObject)
                                    {
                                        selectedPrimitives.Add(o);
                                    }
                                }
                                break;
                            }
                        }
                        // check if an avatar is the parent of the parent primitive
                        Avatar avatarParent =
                            objectsAvatars.FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                        // parent avatar not found, this should not happen
                        if (avatarParent != null)
                        {
                            // check if the avatar is in range
                            if (Vector3.Distance(avatarParent.Position, Client.Self.SimPosition) <= range)
                            {
                                if (item is UUID)
                                {
                                    switch (!o.ID.Equals(item))
                                    {
                                        case false:
                                            lock (LockObject)
                                            {
                                                selectedPrimitives.Add(o);
                                            }
                                            break;
                                    }
                                    break;
                                }
                                if (item is string)
                                {
                                    lock (LockObject)
                                    {
                                        selectedPrimitives.Add(o);
                                    }
                                }
                            }
                        }
                        break;
                }
            });
            if (!selectedPrimitives.Any()) return false;
            if (!UpdatePrimitives(ref selectedPrimitives, dataTimeout))
                return false;
            primitive =
                selectedPrimitives.FirstOrDefault(
                    o =>
                        (item is UUID && o.ID.Equals(item)) ||
                        (item is string && (item as string).Equals(o.Properties.Name, StringComparison.Ordinal)));
            return primitive != null;
        }

        /// <summary>
        ///     Creates a faceted mesh from a primitive.
        /// </summary>
        /// <param name="primitive">the primitive to convert</param>
        /// <param name="mesher">the mesher to use</param>
        /// <param name="facetedMesh">a reference to an output facted mesh object</param>
        /// <param name="millisecondsTimeout">the services timeout</param>
        /// <returns>true if the mesh could be created successfully</returns>
        private static bool MakeFacetedMesh(Primitive primitive, MeshmerizerR mesher, ref FacetedMesh facetedMesh,
            uint millisecondsTimeout)
        {
            if (primitive.Sculpt == null || primitive.Sculpt.SculptTexture.Equals(UUID.Zero))
            {
                facetedMesh = mesher.GenerateFacetedMesh(primitive, DetailLevel.Highest);
                return true;
            }
            if (!primitive.Sculpt.Type.Equals(SculptType.Mesh))
            {
                byte[] assetData = null;
                switch (!Client.Assets.Cache.HasAsset(primitive.Sculpt.SculptTexture))
                {
                    case true:
                        lock (ClientInstanceAssetsLock)
                        {
                            ManualResetEvent ImageDownloadedEvent = new ManualResetEvent(false);
                            Client.Assets.RequestImage(primitive.Sculpt.SculptTexture, (state, args) =>
                            {
                                if (!state.Equals(TextureRequestState.Finished)) return;
                                assetData = args.AssetData;
                                ImageDownloadedEvent.Set();
                            });
                            if (!ImageDownloadedEvent.WaitOne((int) millisecondsTimeout, false))
                                return false;
                        }
                        Client.Assets.Cache.SaveAssetToCache(primitive.Sculpt.SculptTexture, assetData);
                        break;
                    default:
                        assetData = Client.Assets.Cache.GetCachedAssetBytes(primitive.Sculpt.SculptTexture);
                        break;
                }
                Image image;
                ManagedImage managedImage;
                switch (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                {
                    case true:
                        return false;
                    default:
                        if ((managedImage.Channels & ManagedImage.ImageChannels.Alpha) != 0)
                        {
                            managedImage.ConvertChannels(managedImage.Channels & ~ManagedImage.ImageChannels.Alpha);
                        }
                        image = LoadTGAClass.LoadTGA(new MemoryStream(managedImage.ExportTGA()));
                        break;
                }
                facetedMesh = mesher.GenerateFacetedSculptMesh(primitive, (Bitmap) image, DetailLevel.Highest);
                return true;
            }
            FacetedMesh localFacetedMesh = null;
            ManualResetEvent MeshDownloadedEvent = new ManualResetEvent(false);
            lock (ClientInstanceAssetsLock)
            {
                Client.Assets.RequestMesh(primitive.Sculpt.SculptTexture, (success, meshAsset) =>
                {
                    FacetedMesh.TryDecodeFromAsset(primitive, meshAsset, DetailLevel.Highest, out localFacetedMesh);
                    MeshDownloadedEvent.Set();
                });

                if (!MeshDownloadedEvent.WaitOne((int) millisecondsTimeout, false))
                    return false;
            }

            switch (localFacetedMesh != null)
            {
                case true:
                    facetedMesh = localFacetedMesh;
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        ///     Generates a Collada DAE XML Document.
        /// </summary>
        /// <param name="facetedMeshSet">the faceted meshes</param>
        /// <param name="textures">a dictionary of UUID to texture names</param>
        /// <param name="imageFormat">the image export format</param>
        /// <returns>the DAE document</returns>
        /// <remarks>
        ///     This function is a branch-in of several functions of the Radegast Viewer with some changes by Wizardry and
        ///     Steamworks.
        /// </remarks>
        private static XmlDocument GenerateCollada(IEnumerable<FacetedMesh> facetedMeshSet,
            Dictionary<UUID, string> textures, string imageFormat)
        {
            List<MaterialInfo> AllMeterials = new List<MaterialInfo>();

            XmlDocument Doc = new XmlDocument();
            var root = Doc.AppendChild(Doc.CreateElement("COLLADA"));
            root.Attributes.Append(Doc.CreateAttribute("xmlns")).Value = "http://www.collada.org/2005/11/COLLADASchema";
            root.Attributes.Append(Doc.CreateAttribute("version")).Value = "1.4.1";

            var asset = root.AppendChild(Doc.CreateElement("asset"));
            var contributor = asset.AppendChild(Doc.CreateElement("contributor"));
            contributor.AppendChild(Doc.CreateElement("author")).InnerText = "Radegast User";
            contributor.AppendChild(Doc.CreateElement("authoring_tool")).InnerText = "Radegast Collada Export";

            asset.AppendChild(Doc.CreateElement("created")).InnerText = DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss");
            asset.AppendChild(Doc.CreateElement("modified")).InnerText = DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss");

            var unit = asset.AppendChild(Doc.CreateElement("unit"));
            unit.Attributes.Append(Doc.CreateAttribute("name")).Value = "meter";
            unit.Attributes.Append(Doc.CreateAttribute("meter")).Value = "1";

            asset.AppendChild(Doc.CreateElement("up_axis")).InnerText = "Z_UP";

            var images = root.AppendChild(Doc.CreateElement("library_images"));
            var geomLib = root.AppendChild(Doc.CreateElement("library_geometries"));
            var effects = root.AppendChild(Doc.CreateElement("library_effects"));
            var materials = root.AppendChild(Doc.CreateElement("library_materials"));
            var scene = root.AppendChild(Doc.CreateElement("library_visual_scenes"))
                .AppendChild(Doc.CreateElement("visual_scene"));
            scene.Attributes.Append(Doc.CreateAttribute("id")).InnerText = "Scene";
            scene.Attributes.Append(Doc.CreateAttribute("name")).InnerText = "Scene";

            foreach (string name in textures.Values)
            {
                string colladaName = name + "_" + imageFormat.ToLower();
                var image = images.AppendChild(Doc.CreateElement("image"));
                image.Attributes.Append(Doc.CreateAttribute("id")).InnerText = colladaName;
                image.Attributes.Append(Doc.CreateAttribute("name")).InnerText = colladaName;
                image.AppendChild(Doc.CreateElement("init_from")).InnerText =
                    wasURIUnescapeDataString(name + "." + imageFormat.ToLower());
            }

            Func<XmlNode, string, string, List<float>, bool> addSource = (mesh, src_id, param, vals) =>
            {
                var source = mesh.AppendChild(Doc.CreateElement("source"));
                source.Attributes.Append(Doc.CreateAttribute("id")).InnerText = src_id;
                var src_array = source.AppendChild(Doc.CreateElement("float_array"));

                src_array.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}", src_id,
                    "array");
                src_array.Attributes.Append(Doc.CreateAttribute("count")).InnerText = vals.Count.ToString();

                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < vals.Count; i++)
                {
                    sb.Append(vals[i].ToString(CultureInfo.DefaultThreadCurrentCulture));
                    if (i != vals.Count - 1)
                    {
                        sb.Append(" ");
                    }
                }
                src_array.InnerText = sb.ToString();

                var acc = source.AppendChild(Doc.CreateElement("technique_common"))
                    .AppendChild(Doc.CreateElement("accessor"));
                acc.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}", src_id,
                    "array");
                acc.Attributes.Append(Doc.CreateAttribute("count")).InnerText = (vals.Count/param.Length).ToString();
                acc.Attributes.Append(Doc.CreateAttribute("stride")).InnerText = param.Length.ToString();

                foreach (char c in param)
                {
                    var pX = acc.AppendChild(Doc.CreateElement("param"));
                    pX.Attributes.Append(Doc.CreateAttribute("name")).InnerText = c.ToString();
                    pX.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "float";
                }

                return true;
            };

            Func<Primitive.TextureEntryFace, MaterialInfo> getMaterial = o =>
            {
                MaterialInfo ret = AllMeterials.FirstOrDefault(mat => mat.Matches(o));

                if (ret != null) return ret;
                ret = new MaterialInfo
                {
                    TextureID = o.TextureID,
                    Color = o.RGBA,
                    Name = string.Format("Material{0}", AllMeterials.Count)
                };
                AllMeterials.Add(ret);

                return ret;
            };

            Func<FacetedMesh, List<MaterialInfo>> getMaterials = o =>
            {
                var ret = new List<MaterialInfo>();

                for (int face_num = 0; face_num < o.Faces.Count; face_num++)
                {
                    var te = o.Faces[face_num].TextureFace;
                    if (te.RGBA.A < 0.01f)
                    {
                        continue;
                    }
                    var mat = getMaterial.Invoke(te);
                    if (!ret.Contains(mat))
                    {
                        ret.Add(mat);
                    }
                }
                return ret;
            };

            Func<XmlNode, string, string, FacetedMesh, List<int>, bool> addPolygons =
                (mesh, geomID, materialID, obj, faces_to_include) =>
                {
                    var polylist = mesh.AppendChild(Doc.CreateElement("polylist"));
                    polylist.Attributes.Append(Doc.CreateAttribute("material")).InnerText = materialID;

                    // Vertices semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "VERTEX";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "vertices");
                    }

                    // Normals semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "NORMAL";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "normals");
                    }

                    // UV semantic
                    {
                        var input = polylist.AppendChild(Doc.CreateElement("input"));
                        input.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "TEXCOORD";
                        input.Attributes.Append(Doc.CreateAttribute("offset")).InnerText = "0";
                        input.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format("#{0}-{1}",
                            geomID, "map0");
                    }

                    // Save indices
                    var vcount = polylist.AppendChild(Doc.CreateElement("vcount"));
                    var p = polylist.AppendChild(Doc.CreateElement("p"));
                    int index_offset = 0;
                    int num_tris = 0;
                    StringBuilder pBuilder = new StringBuilder();
                    StringBuilder vcountBuilder = new StringBuilder();

                    for (int face_num = 0; face_num < obj.Faces.Count; face_num++)
                    {
                        var face = obj.Faces[face_num];
                        if (faces_to_include == null || faces_to_include.Contains(face_num))
                        {
                            for (int i = 0; i < face.Indices.Count; i++)
                            {
                                int index = index_offset + face.Indices[i];
                                pBuilder.Append(index);
                                pBuilder.Append(" ");
                                if (i%3 == 0)
                                {
                                    vcountBuilder.Append("3 ");
                                    num_tris++;
                                }
                            }
                        }
                        index_offset += face.Vertices.Count;
                    }

                    p.InnerText = pBuilder.ToString().TrimEnd();
                    vcount.InnerText = vcountBuilder.ToString().TrimEnd();
                    polylist.Attributes.Append(Doc.CreateAttribute("count")).InnerText = num_tris.ToString();

                    return true;
                };

            Func<FacetedMesh, MaterialInfo, List<int>> getFacesWithMaterial = (obj, mat) =>
            {
                var ret = new List<int>();
                for (int face_num = 0; face_num < obj.Faces.Count; face_num++)
                {
                    if (mat == getMaterial.Invoke(obj.Faces[face_num].TextureFace))
                    {
                        ret.Add(face_num);
                    }
                }
                return ret;
            };

            Func<Vector3, Quaternion, Vector3, float[]> createSRTMatrix = (scale, q, pos) =>
            {
                float[] mat = new float[16];

                // Transpose the quaternion (don't ask me why)
                q.X = q.X*-1f;
                q.Y = q.Y*-1f;
                q.Z = q.Z*-1f;

                float x2 = q.X + q.X;
                float y2 = q.Y + q.Y;
                float z2 = q.Z + q.Z;
                float xx = q.X*x2;
                float xy = q.X*y2;
                float xz = q.X*z2;
                float yy = q.Y*y2;
                float yz = q.Y*z2;
                float zz = q.Z*z2;
                float wx = q.W*x2;
                float wy = q.W*y2;
                float wz = q.W*z2;

                mat[0] = (1.0f - (yy + zz))*scale.X;
                mat[1] = (xy - wz)*scale.X;
                mat[2] = (xz + wy)*scale.X;
                mat[3] = 0.0f;

                mat[4] = (xy + wz)*scale.Y;
                mat[5] = (1.0f - (xx + zz))*scale.Y;
                mat[6] = (yz - wx)*scale.Y;
                mat[7] = 0.0f;

                mat[8] = (xz - wy)*scale.Z;
                mat[9] = (yz + wx)*scale.Z;
                mat[10] = (1.0f - (xx + yy))*scale.Z;
                mat[11] = 0.0f;

                //Positional parts
                mat[12] = pos.X;
                mat[13] = pos.Y;
                mat[14] = pos.Z;
                mat[15] = 1.0f;

                return mat;
            };

            Func<XmlNode, bool> generateEffects = o =>
            {
                // Effects (face color, alpha)
                foreach (var mat in AllMeterials)
                {
                    var color = mat.Color;
                    var effect = effects.AppendChild(Doc.CreateElement("effect"));
                    effect.Attributes.Append(Doc.CreateAttribute("id")).InnerText = mat.Name + "-fx";
                    var profile = effect.AppendChild(Doc.CreateElement("profile_COMMON"));
                    string colladaName = null;

                    KeyValuePair<UUID, string> kvp = textures.FirstOrDefault(p => p.Key.Equals(mat.TextureID));

                    if (!kvp.Equals(default(KeyValuePair<UUID, string>)))
                    {
                        UUID textID = kvp.Key;
                        colladaName = textures[textID] + "_" + imageFormat.ToLower();
                        var newparam = profile.AppendChild(Doc.CreateElement("newparam"));
                        newparam.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = colladaName + "-surface";
                        var surface = newparam.AppendChild(Doc.CreateElement("surface"));
                        surface.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "2D";
                        surface.AppendChild(Doc.CreateElement("init_from")).InnerText = colladaName;
                        newparam = profile.AppendChild(Doc.CreateElement("newparam"));
                        newparam.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = colladaName + "-sampler";
                        newparam.AppendChild(Doc.CreateElement("sampler2D"))
                            .AppendChild(Doc.CreateElement("source"))
                            .InnerText = colladaName + "-surface";
                    }

                    var t = profile.AppendChild(Doc.CreateElement("technique"));
                    t.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = "common";
                    var phong = t.AppendChild(Doc.CreateElement("phong"));

                    var diffuse = phong.AppendChild(Doc.CreateElement("diffuse"));
                    // Only one <color> or <texture> can appear inside diffuse element
                    if (colladaName != null)
                    {
                        var txtr = diffuse.AppendChild(Doc.CreateElement("texture"));
                        txtr.Attributes.Append(Doc.CreateAttribute("texture")).InnerText = colladaName + "-sampler";
                        txtr.Attributes.Append(Doc.CreateAttribute("texcoord")).InnerText = colladaName;
                    }
                    else
                    {
                        var diffuseColor = diffuse.AppendChild(Doc.CreateElement("color"));
                        diffuseColor.Attributes.Append(Doc.CreateAttribute("sid")).InnerText = "diffuse";
                        diffuseColor.InnerText = string.Format("{0} {1} {2} {3}",
                            color.R.ToString(CultureInfo.DefaultThreadCurrentCulture),
                            color.G.ToString(CultureInfo.DefaultThreadCurrentCulture),
                            color.B.ToString(CultureInfo.DefaultThreadCurrentCulture),
                            color.A.ToString(CultureInfo.DefaultThreadCurrentCulture));
                    }

                    phong.AppendChild(Doc.CreateElement("transparency"))
                        .AppendChild(Doc.CreateElement("float"))
                        .InnerText = color.A.ToString(CultureInfo.DefaultThreadCurrentCulture);
                }

                return true;
            };

            int prim_nr = 0;
            foreach (var obj in facetedMeshSet)
            {
                int total_num_vertices = 0;
                string name = string.Format("prim{0}", prim_nr++);
                string geomID = name;

                var geom = geomLib.AppendChild(Doc.CreateElement("geometry"));
                geom.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}", geomID, "mesh");
                var mesh = geom.AppendChild(Doc.CreateElement("mesh"));

                List<float> position_data = new List<float>();
                List<float> normal_data = new List<float>();
                List<float> uv_data = new List<float>();

                int num_faces = obj.Faces.Count;

                for (int face_num = 0; face_num < num_faces; face_num++)
                {
                    var face = obj.Faces[face_num];
                    total_num_vertices += face.Vertices.Count;

                    foreach (var v in face.Vertices)
                    {
                        position_data.Add(v.Position.X);
                        position_data.Add(v.Position.Y);
                        position_data.Add(v.Position.Z);

                        normal_data.Add(v.Normal.X);
                        normal_data.Add(v.Normal.Y);
                        normal_data.Add(v.Normal.Z);

                        uv_data.Add(v.TexCoord.X);
                        uv_data.Add(v.TexCoord.Y);
                    }
                }

                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "positions"), "XYZ", position_data);
                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "normals"), "XYZ", normal_data);
                addSource.Invoke(mesh, string.Format("{0}-{1}", geomID, "map0"), "ST", uv_data);

                // Add the <vertices> element
                {
                    var verticesNode = mesh.AppendChild(Doc.CreateElement("vertices"));
                    verticesNode.Attributes.Append(Doc.CreateAttribute("id")).InnerText = string.Format("{0}-{1}",
                        geomID, "vertices");
                    var verticesInput = verticesNode.AppendChild(Doc.CreateElement("input"));
                    verticesInput.Attributes.Append(Doc.CreateAttribute("semantic")).InnerText = "POSITION";
                    verticesInput.Attributes.Append(Doc.CreateAttribute("source")).InnerText = string.Format(
                        "#{0}-{1}", geomID, "positions");
                }

                var objMaterials = getMaterials.Invoke(obj);

                // Add triangles
                foreach (var objMaterial in objMaterials)
                {
                    addPolygons.Invoke(mesh, geomID, objMaterial.Name + "-material", obj,
                        getFacesWithMaterial.Invoke(obj, objMaterial));
                }

                var node = scene.AppendChild(Doc.CreateElement("node"));
                node.Attributes.Append(Doc.CreateAttribute("type")).InnerText = "NODE";
                node.Attributes.Append(Doc.CreateAttribute("id")).InnerText = geomID;
                node.Attributes.Append(Doc.CreateAttribute("name")).InnerText = geomID;

                // Set tranform matrix (node position, rotation and scale)
                var matrix = node.AppendChild(Doc.CreateElement("matrix"));

                var srt = createSRTMatrix.Invoke(obj.Prim.Scale, obj.Prim.Rotation, obj.Prim.Position);
                string matrixVal = string.Empty;
                for (int i = 0; i < 4; i++)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        matrixVal += srt[j*4 + i].ToString(CultureInfo.DefaultThreadCurrentCulture) + " ";
                    }
                }
                matrix.InnerText = matrixVal.TrimEnd();

                // Geometry of the node
                var nodeGeometry = node.AppendChild(Doc.CreateElement("instance_geometry"));

                // Bind materials
                var tq = nodeGeometry.AppendChild(Doc.CreateElement("bind_material"))
                    .AppendChild(Doc.CreateElement("technique_common"));
                foreach (var objMaterial in objMaterials)
                {
                    var instanceMaterial = tq.AppendChild(Doc.CreateElement("instance_material"));
                    instanceMaterial.Attributes.Append(Doc.CreateAttribute("symbol")).InnerText =
                        string.Format("{0}-{1}", objMaterial.Name, "material");
                    instanceMaterial.Attributes.Append(Doc.CreateAttribute("target")).InnerText =
                        string.Format("#{0}-{1}", objMaterial.Name, "material");
                }

                nodeGeometry.Attributes.Append(Doc.CreateAttribute("url")).InnerText = string.Format("#{0}-{1}", geomID,
                    "mesh");
            }

            generateEffects.Invoke(effects);

            // Materials
            foreach (var objMaterial in AllMeterials)
            {
                var mat = materials.AppendChild(Doc.CreateElement("material"));
                mat.Attributes.Append(Doc.CreateAttribute("id")).InnerText = objMaterial.Name + "-material";
                var matEffect = mat.AppendChild(Doc.CreateElement("instance_effect"));
                matEffect.Attributes.Append(Doc.CreateAttribute("url")).InnerText = string.Format("#{0}-{1}",
                    objMaterial.Name, "fx");
            }

            root.AppendChild(Doc.CreateElement("scene"))
                .AppendChild(Doc.CreateElement("instance_visual_scene"))
                .Attributes.Append(Doc.CreateAttribute("url")).InnerText = "#Scene";

            return Doc;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches all the avatars in-range.
        /// </summary>
        /// <param name="range">the range to extend or contract to</param>
        /// <param name="millisecondsTimeout">the timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>the avatars in range</returns>
        private static IEnumerable<Avatar> GetAvatars(float range, uint millisecondsTimeout, uint dataTimeout)
        {
            switch (Client.Self.Movement.Camera.Far < range)
            {
                case true:
                    IEnumerable<Avatar> avatars;
                    wasAdaptiveAlarm RangeUpdateAlarm = new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                    EventHandler<AvatarUpdateEventArgs> AvatarUpdateEventHandler =
                        (sender, args) =>
                        {
                            // ignore if this is not a new avatar being added
                            if (!args.IsNew) return;
                            RangeUpdateAlarm.Alarm(dataTimeout);
                        };
                    lock (ClientInstanceObjectsLock)
                    {
                        Client.Objects.AvatarUpdate += AvatarUpdateEventHandler;
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = range;
                        }
                        RangeUpdateAlarm.Alarm(dataTimeout);
                        RangeUpdateAlarm.Signal.WaitOne((int) millisecondsTimeout, false);
                        avatars =
                            Client.Network.Simulators.AsParallel().Select(o => o.ObjectsAvatars)
                                .Select(o => o.Copy().Values)
                                .SelectMany(o => o);
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = corradeConfiguration.Range;
                        }
                        Client.Objects.AvatarUpdate -= AvatarUpdateEventHandler;
                    }
                    return avatars;
                default:
                    return Client.Network.Simulators.AsParallel().Select(o => o.ObjectsAvatars)
                        .Select(o => o.Copy().Values)
                        .SelectMany(o => o);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Fetches all the primitives in-range.
        /// </summary>
        /// <param name="range">the range to extend or contract to</param>
        /// <param name="millisecondsTimeout">the timeout in milliseconds</param>
        /// <param name="dataTimeout">the data timeout in milliseconds</param>
        /// <returns>the primitives in range</returns>
        private static IEnumerable<Primitive> GetPrimitives(float range, uint millisecondsTimeout, uint dataTimeout)
        {
            switch (Client.Self.Movement.Camera.Far < range)
            {
                case true:
                    IEnumerable<Primitive> primitives;
                    wasAdaptiveAlarm RangeUpdateAlarm = new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                    EventHandler<PrimEventArgs> ObjectUpdateEventHandler =
                        (sender, args) =>
                        {
                            // ignore if this is not a new primitive being added
                            if (!args.IsNew) return;
                            RangeUpdateAlarm.Alarm(dataTimeout);
                        };
                    lock (ClientInstanceObjectsLock)
                    {
                        Client.Objects.ObjectUpdate += ObjectUpdateEventHandler;
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = range;
                        }
                        RangeUpdateAlarm.Alarm(dataTimeout);
                        RangeUpdateAlarm.Signal.WaitOne((int) millisecondsTimeout, false);
                        primitives =
                            Client.Network.Simulators.AsParallel().Select(o => o.ObjectsPrimitives)
                                .Select(o => o.Copy().Values).ToList()
                                .SelectMany(o => o);
                        lock (ClientInstanceConfigurationLock)
                        {
                            Client.Self.Movement.Camera.Far = corradeConfiguration.Range;
                        }
                        Client.Objects.ObjectUpdate -= ObjectUpdateEventHandler;
                    }
                    return primitives;
                default:
                    return Client.Network.Simulators.AsParallel().Select(o => o.ObjectsPrimitives)
                        .Select(o => o.Copy().Values).ToList()
                        .SelectMany(o => o);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates a set of primitives by scanning their properties.
        /// </summary>
        /// <param name="primitives">a list of primitives to update</param>
        /// <param name="dataTimeout">the timeout for receiving data from the grid</param>
        /// <returns>a list of updated primitives</returns>
        private static bool UpdatePrimitives(ref HashSet<Primitive> primitives, uint dataTimeout)
        {
            HashSet<Primitive> scansPrimitives = new HashSet<Primitive>(primitives);
            HashSet<Primitive> localPrimitives = new HashSet<Primitive>();
            Dictionary<UUID, ManualResetEvent> primitiveEvents =
                new Dictionary<UUID, ManualResetEvent>(
                    scansPrimitives
                        .AsParallel().ToDictionary(o => o.ID, p => new ManualResetEvent(false)));
            Dictionary<UUID, Stopwatch> stopWatch = new Dictionary<UUID, Stopwatch>(
                scansPrimitives
                    .AsParallel().ToDictionary(o => o.ID, p => new Stopwatch()));
            HashSet<long> times = new HashSet<long>(new[] {(long) dataTimeout});
            object LockObject = new object();
            EventHandler<ObjectPropertiesEventArgs> ObjectPropertiesEventHandler = (sender, args) =>
            {
                KeyValuePair<UUID, ManualResetEvent> queueElement =
                    primitiveEvents.AsParallel().FirstOrDefault(o => o.Key.Equals(args.Properties.ObjectID));
                switch (!queueElement.Equals(default(KeyValuePair<UUID, ManualResetEvent>)))
                {
                    case true:
                        Primitive updatedPrimitive =
                            scansPrimitives.AsParallel().FirstOrDefault(o => o.ID.Equals(args.Properties.ObjectID));
                        if (updatedPrimitive == null) return;
                        updatedPrimitive.Properties = args.Properties;
                        lock (LockObject)
                        {
                            localPrimitives.Add(updatedPrimitive);
                            stopWatch[queueElement.Key].Stop();
                            times.Add(stopWatch[queueElement.Key].ElapsedMilliseconds);
                            queueElement.Value.Set();
                        }
                        break;
                }
            };
            lock (ClientInstanceObjectsLock)
            {
                Parallel.ForEach(primitiveEvents, o =>
                {
                    Primitive queryPrimitive =
                        scansPrimitives.AsParallel().SingleOrDefault(p => p.ID.Equals(o.Key));
                    if (queryPrimitive == null) return;
                    lock (LockObject)
                    {
                        stopWatch[queryPrimitive.ID].Start();
                    }
                    Client.Objects.ObjectProperties += ObjectPropertiesEventHandler;
                    Client.Objects.SelectObject(
                        Client.Network.Simulators.FirstOrDefault(p => p.Handle.Equals(queryPrimitive.RegionHandle)),
                        queryPrimitive.LocalID,
                        true);
                    ManualResetEvent primitiveEvent;
                    int averageTime;
                    lock (LockObject)
                    {
                        primitiveEvent = primitiveEvents[queryPrimitive.ID];
                        averageTime = (int) times.Average();
                    }
                    primitiveEvent.WaitOne(averageTime != 0 ? averageTime : (int) dataTimeout, false);
                    Client.Objects.ObjectProperties -= ObjectPropertiesEventHandler;
                });
            }
            if (!scansPrimitives.Count.Equals(localPrimitives.Count))
                return false;
            primitives = localPrimitives;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates a set of avatars by scanning their profile data.
        /// </summary>
        /// <param name="avatars">a list of avatars to update</param>
        /// <param name="millisecondsTimeout">the amount of time in milliseconds to timeout</param>
        /// <param name="dataTimeout">the data timeout</param>
        /// <returns>true if any avatars were updated</returns>
        private static bool UpdateAvatars(ref HashSet<Avatar> avatars, uint millisecondsTimeout,
            uint dataTimeout)
        {
            HashSet<Avatar> scansAvatars = new HashSet<Avatar>(avatars);
            Dictionary<UUID, wasAdaptiveAlarm> avatarAlarms =
                new Dictionary<UUID, wasAdaptiveAlarm>(scansAvatars.AsParallel()
                    .ToDictionary(o => o.ID, p => new wasAdaptiveAlarm(corradeConfiguration.DataDecayType)));
            Dictionary<UUID, Avatar> avatarUpdates = new Dictionary<UUID, Avatar>(scansAvatars.AsParallel()
                .ToDictionary(o => o.ID, p => p));
            object LockObject = new object();
            EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
            {
                lock (LockObject)
                {
                    avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                    avatarUpdates[args.AvatarID].ProfileInterests = args.Interests;
                }
            };
            EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                (sender, args) =>
                {
                    lock (LockObject)
                    {
                        avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                        avatarUpdates[args.AvatarID].ProfileProperties = args.Properties;
                    }
                };
            EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
            {
                lock (LockObject)
                {
                    avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                    avatarUpdates[args.AvatarID].Groups.AddRange(args.Groups.Select(o => o.GroupID));
                }
            };
            EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                (sender, args) =>
                {
                    lock (LockObject)
                    {
                        avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                    }
                };
            EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                (sender, args) =>
                {
                    lock (LockObject)
                    {
                        avatarAlarms[args.AvatarID].Alarm(dataTimeout);
                    }
                };
            lock (ClientInstanceAvatarsLock)
            {
                Parallel.ForEach(scansAvatars, o =>
                {
                    Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                    Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                    Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                    Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                    Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                    Client.Avatars.RequestAvatarProperties(o.ID);
                    Client.Avatars.RequestAvatarPicks(o.ID);
                    Client.Avatars.RequestAvatarClassified(o.ID);
                    wasAdaptiveAlarm avatarAlarm;
                    lock (LockObject)
                    {
                        avatarAlarm = avatarAlarms[o.ID];
                    }
                    avatarAlarm.Signal.WaitOne((int) millisecondsTimeout, false);
                    Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                    Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                    Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                    Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                    Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                });
            }

            switch (
                avatarUpdates.Values.AsParallel()
                    .Any(
                        o =>
                            o != null && !o.ProfileInterests.Equals(default(Avatar.Interests)) &&
                            !o.ProfileProperties.Equals(default(Avatar.AvatarProperties))))
            {
                case true:
                    avatars = new HashSet<Avatar>(avatarUpdates.Values);
                    return true;
                default:
                    return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Requests the UUIDs of all the current groups.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="groups">a hashset where to store the UUIDs</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool directGetCurrentGroups(uint millisecondsTimeout, ref IEnumerable<UUID> groups)
        {
            ManualResetEvent CurrentGroupsReceivedEvent = new ManualResetEvent(false);
            Dictionary<UUID, OpenMetaverse.Group> currentGroups = null;
            EventHandler<CurrentGroupsEventArgs> CurrentGroupsEventHandler = (sender, args) =>
            {
                currentGroups = args.Groups;
                CurrentGroupsReceivedEvent.Set();
            };
            Client.Groups.CurrentGroups += CurrentGroupsEventHandler;
            Client.Groups.RequestCurrentGroups();
            if (!CurrentGroupsReceivedEvent.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Groups.CurrentGroups -= CurrentGroupsEventHandler;
                return false;
            }
            Client.Groups.CurrentGroups -= CurrentGroupsEventHandler;
            switch (currentGroups.Any())
            {
                case true:
                    groups = currentGroups.Keys;
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        ///     A wrapper for retrieveing all the current groups that implements caching.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="groups">a hashset where to store the UUIDs</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool GetCurrentGroups(uint millisecondsTimeout, ref IEnumerable<UUID> groups)
        {
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                if (Cache.CurrentGroupsCache.Any())
                {
                    groups = Cache.CurrentGroupsCache;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceGroupsLock)
            {
                succeeded = directGetCurrentGroups(millisecondsTimeout, ref groups);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.CurrentGroupsCache = new HashSet<UUID>(groups);
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Requests the UUIDs of all the current groups.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="mutes">an enumerable where to store mute entries</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool directGetMutes(uint millisecondsTimeout, ref IEnumerable<MuteEntry> mutes)
        {
            ManualResetEvent MuteListUpdatedEvent = new ManualResetEvent(false);
            EventHandler<EventArgs> MuteListUpdatedEventHandler =
                (sender, args) => MuteListUpdatedEvent.Set();
            Client.Self.MuteListUpdated += MuteListUpdatedEventHandler;
            Client.Self.RequestMuteList();
            if (!MuteListUpdatedEvent.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                return false;
            }
            Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
            mutes = Client.Self.MuteList.Copy().Values;
            return true;
        }

        /// <summary>
        ///     A wrapper for retrieveing all the current groups that implements caching.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="mutes">an enumerable where to store mute entries</param>
        /// <returns>true if the current groups could be fetched</returns>
        private static bool GetMutes(uint millisecondsTimeout, ref IEnumerable<MuteEntry> mutes)
        {
            lock (Cache.Locks.MutesCacheLock)
            {
                if (Cache.MutesCache.Any())
                {
                    mutes = Cache.MutesCache;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceSelfLock)
            {
                succeeded = directGetMutes(millisecondsTimeout, ref mutes);
            }
            if (succeeded)
            {
                lock (Cache.Locks.MutesCacheLock)
                {
                    Cache.MutesCache = new HashSet<MuteEntry>(mutes);
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Get all worn attachments.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">the alarm timeout for receiving object properties</param>
        /// <returns>attachment points by primitives</returns>
        private static IEnumerable<KeyValuePair<Primitive, AttachmentPoint>> GetAttachments(
            uint millisecondsTimeout, uint dataTimeout)
        {
            HashSet<Primitive> primitives;
            lock (ClientInstanceNetworkLock)
            {
                primitives =
                    new HashSet<Primitive>(Client.Network.CurrentSim.ObjectsPrimitives.FindAll(
                        o => o.ParentID.Equals(Client.Self.LocalID)));
            }
            Dictionary<UUID, uint> primitiveQueue = primitives.ToDictionary(o => o.ID, o => o.LocalID);
            object LockObject = new object();
            wasAdaptiveAlarm ObjectPropertiesAlarm = new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
            EventHandler<ObjectPropertiesEventArgs> ObjectPropertiesEventHandler = (sender, args) =>
            {
                ObjectPropertiesAlarm.Alarm(dataTimeout);
                lock (LockObject)
                {
                    primitiveQueue.Remove(args.Properties.ObjectID);
                    if (!primitiveQueue.Any()) ObjectPropertiesAlarm.Signal.Set();
                }
            };
            lock (ClientInstanceObjectsLock)
            {
                Client.Objects.ObjectProperties += ObjectPropertiesEventHandler;
                Client.Objects.SelectObjects(Client.Network.CurrentSim, primitiveQueue.Values.ToArray(),
                    true);
                ObjectPropertiesAlarm.Signal.WaitOne((int) millisecondsTimeout, false);
                Client.Objects.ObjectProperties -= ObjectPropertiesEventHandler;
            }
            return primitives
                .AsParallel()
                .Select(
                    o =>
                        new KeyValuePair<Primitive, AttachmentPoint>(o,
                            (AttachmentPoint) (((o.PrimData.State & 0xF0) >> 4) |
                                               ((o.PrimData.State & ~0xF0) << 4))));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets the inventory wearables that are currently being worn.
        /// </summary>
        /// <param name="root">the folder to start the search from</param>
        /// <returns>key value pairs of wearables by name</returns>
        private static IEnumerable<KeyValuePair<AppearanceManager.WearableData, WearableType>> GetWearables(
            InventoryNode root)
        {
            InventoryFolder inventoryFolder = Client.Inventory.Store[root.Data.UUID] as InventoryFolder;
            if (inventoryFolder == null)
            {
                InventoryItem inventoryItem = Client.Inventory.Store[root.Data.UUID] as InventoryItem;
                if (inventoryItem != null)
                {
                    WearableType wearableType = Client.Appearance.IsItemWorn(inventoryItem);
                    if (!wearableType.Equals(WearableType.Invalid))
                    {
                        foreach (
                            KeyValuePair<WearableType, AppearanceManager.WearableData> wearable in
                                Client.Appearance.GetWearables()
                                    .AsParallel().Where(o => o.Value.ItemID.Equals(inventoryItem.UUID)))
                        {
                            yield return
                                new KeyValuePair<AppearanceManager.WearableData, WearableType>(wearable.Value,
                                    wearable.Key);
                        }
                    }
                    yield break;
                }
            }
            foreach (
                KeyValuePair<AppearanceManager.WearableData, WearableType> item in
                    root.Nodes.Values.AsParallel().SelectMany(GetWearables))
            {
                yield return item;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Fetches items by searching the inventory starting with an inventory
        ///     node where the search criteria finds:
        ///     - name as string
        ///     - name as Regex
        ///     - UUID as UUID
        /// </summary>
        /// <param name="root">the node to start the search from</param>
        /// <param name="criteria">the name, UUID or Regex of the item to be found</param>
        /// <returns>a list of items matching the item name</returns>
        private static IEnumerable<T> FindInventory<T>(InventoryNode root, object criteria)
        {
            if ((criteria is Regex && (criteria as Regex).IsMatch(root.Data.Name)) ||
                (criteria is string &&
                 (criteria as string).Equals(root.Data.Name, StringComparison.Ordinal)) ||
                (criteria is UUID &&
                 (criteria.Equals(root.Data.UUID) ||
                  (Client.Inventory.Store[root.Data.UUID] is InventoryItem &&
                   (Client.Inventory.Store[root.Data.UUID] as InventoryItem).AssetUUID.Equals(criteria)))))
            {
                if (typeof (T) == typeof (InventoryNode))
                {
                    yield return (T) (object) root;
                }
                if (typeof (T) == typeof (InventoryBase))
                {
                    yield return (T) (object) Client.Inventory.Store[root.Data.UUID];
                }
            }
            foreach (T item in root.Nodes.Values.AsParallel().SelectMany(node => FindInventory<T>(node, criteria)))
            {
                yield return item;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Fetches items and their full path from the inventory starting with
        ///     an inventory node where the search criteria finds:
        ///     - name as string
        ///     - name as Regex
        ///     - UUID as UUID
        /// </summary>
        /// <param name="root">the node to start the search from</param>
        /// <param name="criteria">the name, UUID or Regex of the item to be found</param>
        /// <param name="prefix">any prefix to append to the found paths</param>
        /// <returns>items matching criteria and their full inventoy path</returns>
        private static IEnumerable<KeyValuePair<T, LinkedList<string>>> FindInventoryPath<T>(
            InventoryNode root, object criteria, LinkedList<string> prefix)
        {
            if ((criteria is Regex && (criteria as Regex).IsMatch(root.Data.Name)) ||
                (criteria is string &&
                 (criteria as string).Equals(root.Data.Name, StringComparison.Ordinal)) ||
                (criteria is UUID &&
                 (criteria.Equals(root.Data.UUID) ||
                  (Client.Inventory.Store[root.Data.UUID] is InventoryItem &&
                   (Client.Inventory.Store[root.Data.UUID] as InventoryItem).AssetUUID.Equals(criteria)))))
            {
                if (typeof (T) == typeof (InventoryBase))
                {
                    yield return
                        new KeyValuePair<T, LinkedList<string>>((T) (object) Client.Inventory.Store[root.Data.UUID],
                            new LinkedList<string>(
                                prefix.Concat(new[] {root.Data.Name})));
                }
                if (typeof (T) == typeof (InventoryNode))
                {
                    yield return
                        new KeyValuePair<T, LinkedList<string>>((T) (object) root,
                            new LinkedList<string>(
                                prefix.Concat(new[] {root.Data.Name})));
                }
            }
            foreach (
                KeyValuePair<T, LinkedList<string>> o in
                    root.Nodes.Values.AsParallel()
                        .SelectMany(o => FindInventoryPath<T>(o, criteria, new LinkedList<string>(
                            prefix.Concat(new[] {root.Data.Name})))))
            {
                yield return o;
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets all the items from an inventory folder and returns the items.
        /// </summary>
        /// <param name="rootFolder">a folder from which to search</param>
        /// <param name="folder">the folder to search for</param>
        /// <returns>a list of items from the folder</returns>
        private static IEnumerable<T> GetInventoryFolderContents<T>(InventoryNode rootFolder,
            string folder)
        {
            foreach (
                InventoryNode node in
                    rootFolder.Nodes.Values.AsParallel()
                        .Where(
                            node =>
                                node.Data is InventoryFolder && node.Data.Name.Equals(folder, StringComparison.Ordinal))
                )
            {
                foreach (InventoryNode item in node.Nodes.Values)
                {
                    if (typeof (T) == typeof (InventoryNode))
                    {
                        yield return (T) (object) item;
                    }
                    if (typeof (T) == typeof (InventoryBase))
                    {
                        yield return (T) (object) Client.Inventory.Store[item.Data.UUID];
                    }
                }
                break;
            }
        }

        /// <summary>
        ///     Posts messages to console or log-files.
        /// </summary>
        /// <param name="messages">a list of messages</param>
        private static void Feedback(params string[] messages)
        {
            CorradeThreadPool[CorradeThreadType.LOG].Spawn(
                () =>
                {
                    List<string> output = new List<string>
                    {
                        !string.IsNullOrEmpty(InstalledServiceName)
                            ? InstalledServiceName
                            : CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME,
                        string.Format(CultureInfo.DefaultThreadCurrentCulture, "[{0}]",
                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat))
                    };

                    output.AddRange(messages.Select(message => message));

                    // Attempt to write to log file,
                    if (corradeConfiguration.ClientLogEnabled)
                    {
                        try
                        {
                            lock (ClientLogFileLock)
                            {
                                using (
                                    StreamWriter logWriter =
                                        new StreamWriter(corradeConfiguration.ClientLogFile, true, Encoding.UTF8))
                                {
                                    logWriter.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()));
                                    //logWriter.Flush();
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // or fail and append the fail message.
                            output.Add(string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0} {1}",
                                wasGetDescriptionFromEnumValue(
                                    ConsoleError.COULD_NOT_WRITE_TO_CLIENT_LOG_FILE),
                                ex.Message));
                        }
                    }

                    if (!Environment.UserInteractive)
                    {
                        switch (Environment.OSVersion.Platform)
                        {
                            case PlatformID.Win32NT:
                                CorradeEventLog.WriteEntry(
                                    string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()),
                                    EventLogEntryType.Information);
                                break;
                        }
                        return;
                    }
                    Console.WriteLine(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR, output.ToArray()));
                },
                corradeConfiguration.MaximumLogThreads);
        }

        /// <summary>
        ///     Posts messages to console or log-files.
        /// </summary>
        /// <param name="multiline">whether to treat the messages as separate lines</param>
        /// <param name="messages">a list of messages</param>
        private static void Feedback(bool multiline, params string[] messages)
        {
            if (!multiline)
            {
                Feedback(messages);
                return;
            }
            CorradeThreadPool[CorradeThreadType.LOG].Spawn(
                () =>
                {
                    List<string> output =
                        new List<string>(
                            messages.Select(
                                o => string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0}{1}[{2}]{3}{4}",
                                    !string.IsNullOrEmpty(InstalledServiceName)
                                        ? InstalledServiceName
                                        : CORRADE_CONSTANTS.DEFAULT_SERVICE_NAME, CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                        CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                    CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                    o)));

                    // Attempt to write to log file,
                    if (corradeConfiguration.ClientLogEnabled)
                    {
                        try
                        {
                            lock (ClientLogFileLock)
                            {
                                using (
                                    StreamWriter logWriter =
                                        new StreamWriter(corradeConfiguration.ClientLogFile, true, Encoding.UTF8))
                                {
                                    foreach (string message in output)
                                    {
                                        logWriter.WriteLine(message);
                                    }
                                    //logWriter.Flush();
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // or fail and append the fail message.
                            output.Add(string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0} {1}",
                                wasGetDescriptionFromEnumValue(
                                    ConsoleError.COULD_NOT_WRITE_TO_CLIENT_LOG_FILE),
                                ex.Message));
                        }
                    }

                    if (!Environment.UserInteractive)
                    {
                        switch (Environment.OSVersion.Platform)
                        {
                            case PlatformID.Win32NT:
                                foreach (string message in output)
                                {
                                    CorradeEventLog.WriteEntry(message, EventLogEntryType.Information);
                                }
                                break;
                        }
                        return;
                    }

                    foreach (string message in output)
                    {
                        Console.WriteLine(message);
                    }
                },
                corradeConfiguration.MaximumLogThreads);
        }

        public static int Main(string[] args)
        {
            if (Environment.UserInteractive)
            {
                if (args.Any())
                {
                    string action = string.Empty;
                    for (int i = 0; i < args.Length; ++i)
                    {
                        switch (args[i].ToUpper())
                        {
                            case "/INSTALL":
                                action = "INSTALL";
                                break;
                            case "/UNINSTALL":
                                action = "UNINSTALL";
                                break;
                            case "/NAME":
                                if (args.Length > i + 1)
                                {
                                    InstalledServiceName = args[++i];
                                }
                                break;
                        }
                    }

                    switch (action)
                    {
                        case "INSTALL":
                            return InstallService();
                        case "UNINSTALL":
                            return UninstallService();
                    }
                }
                // run interactively and log to console
                Corrade corrade = new Corrade();
                corrade.OnStart(null);
                return 0;
            }

            // run as a standard service
            Run(new Corrade());
            return 0;
        }

        private static int InstallService()
        {
            try
            {
                // install the service with the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException != null && ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    Win32Exception we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service already installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        private static int UninstallService()
        {
            try
            {
                // uninstall the service from the Windows Service Control Manager (SCM)
                ManagedInstallerClass.InstallHelper(new[] {"/u", Assembly.GetExecutingAssembly().Location});
            }
            catch (Exception ex)
            {
                if (ex.InnerException.GetType() == typeof (Win32Exception))
                {
                    Win32Exception we = (Win32Exception) ex.InnerException;
                    Console.WriteLine("Error(0x{0:X}): Service not installed!", we.ErrorCode);
                    return we.ErrorCode;
                }
                Console.WriteLine(ex.ToString());
                return -1;
            }

            return 0;
        }

        protected override void OnStop()
        {
            base.OnStop();
            ConnectionSemaphores['u'].Set();
        }

        protected override void OnStart(string[] args)
        {
            base.OnStart(args);
            //Debugger.Break();
            programThread = new Thread(new Corrade().Program);
            programThread.Start();
        }

        // Main entry point.
        public void Program()
        {
            // Set the current directory to the service directory.
            Directory.SetCurrentDirectory(AppDomain.CurrentDomain.BaseDirectory);
            // Load the Linden Lab Globalization.
            try
            {
                // If the Linden Lab culture exists, then unregister it (for updates).
                CultureInfo[] customCultures = CultureInfo.GetCultures(CultureTypes.UserCustomCulture);
                if (
                    customCultures.FirstOrDefault(
                        o => o.Name.Equals(CORRADE_CONSTANTS.LINDEN_GLOBALIZATION_NAME)) != null)
                {
                    CultureAndRegionInfoBuilder.Unregister(CORRADE_CONSTANTS.LINDEN_GLOBALIZATION_NAME);
                }
                // Create the Linden culture from the globalization file and register it.
                CultureAndRegionInfoBuilder cultureAndRegionInfoBuilder =
                    CultureAndRegionInfoBuilder.CreateFromLdml(CORRADE_CONSTANTS.LINDEN_GLOBALIZATION_FILE);
                cultureAndRegionInfoBuilder.Register();
                CultureInfo.DefaultThreadCurrentCulture =
                    CultureInfo.CreateSpecificCulture(CORRADE_CONSTANTS.LINDEN_GLOBALIZATION_NAME);
            }
            catch (Exception ex)
            {
                // If the culture could not be created and registered then abort everything since we need this.
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_LINDEN_GLOBALIZATION), ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Load the configuration file.
            lock (ConfigurationFileLock)
            {
                corradeConfiguration.Load(CORRADE_CONSTANTS.CONFIGURATION_FILE, ref corradeConfiguration);
            }
            // Write the logo.
            Feedback(true, CORRADE_CONSTANTS.LOGO.ToArray());
            // Branch on platform and set-up termination handlers.
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32NT:
                    if (Environment.UserInteractive)
                    {
                        // Setup console handler.
                        ConsoleEventHandler += ConsoleCtrlCheck;
                        NativeMethods.SetConsoleCtrlHandler(ConsoleEventHandler, true);
                        if (Environment.UserInteractive)
                        {
                            Console.CancelKeyPress +=
                                (sender, args) => ConnectionSemaphores['u'].Set();
                        }
                    }
                    break;
            }
            // Set-up watcher for dynamically reading the configuration file.
            FileSystemEventHandler HandleConfigurationFileChanged = null;
            try
            {
                ConfigurationWatcher.Path = Directory.GetCurrentDirectory();
                ConfigurationWatcher.Filter = CORRADE_CONSTANTS.CONFIGURATION_FILE;
                ConfigurationWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleConfigurationFileChanged = (sender, args) => ConfigurationChangedTimer.Change(1000, 0);
                ConfigurationWatcher.Changed += HandleConfigurationFileChanged;
                ConfigurationWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_CONFIGURATION_WATCHER), ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up watcher for dynamically reading the configuration file.
            FileSystemEventHandler HandleNotificationsFileChanged = null;
            try
            {
                NotificationsWatcher.Path = wasPathCombine(Directory.GetCurrentDirectory(),
                    CORRADE_CONSTANTS.STATE_DIRECTORY);
                NotificationsWatcher.Filter = CORRADE_CONSTANTS.NOTIFICATIONS_STATE_FILE;
                NotificationsWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleNotificationsFileChanged = (sender, args) => NotificationsChangedTimer.Change(1000, 0);
                NotificationsWatcher.Changed += HandleNotificationsFileChanged;
                NotificationsWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_CONFIGURATION_WATCHER), ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Set-up the AIML bot in case it has been enabled.
            FileSystemEventHandler HandleAIMLBotConfigurationChanged = null;
            try
            {
                AIMLBotConfigurationWatcher.Path = wasPathCombine(Directory.GetCurrentDirectory(),
                    AIML_BOT_CONSTANTS.DIRECTORY);
                AIMLBotConfigurationWatcher.NotifyFilter = NotifyFilters.LastWrite;
                HandleAIMLBotConfigurationChanged = (sender, args) => AIMLConfigurationChangedTimer.Change(1000, 0);
                AIMLBotConfigurationWatcher.Changed += HandleAIMLBotConfigurationChanged;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_AIML_CONFIGURATION_WATCHER),
                    ex.Message);
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Network Settings
            ServicePointManager.DefaultConnectionLimit = (int) corradeConfiguration.ConnectionLimit;
            ServicePointManager.UseNagleAlgorithm = corradeConfiguration.UseNaggle;
            ServicePointManager.Expect100Continue = corradeConfiguration.UseExpect100Continue;
            ServicePointManager.MaxServicePointIdleTime = (int) corradeConfiguration.ConnectionIdleTime;
            // Suppress standard OpenMetaverse logs, we have better ones.
            Settings.LOG_LEVEL = Helpers.LogLevel.None;
            Client.Settings.ALWAYS_REQUEST_PARCEL_ACL = true;
            Client.Settings.ALWAYS_DECODE_OBJECTS = true;
            Client.Settings.ALWAYS_REQUEST_OBJECTS = true;
            Client.Settings.SEND_AGENT_APPEARANCE = true;
            Client.Settings.AVATAR_TRACKING = true;
            Client.Settings.OBJECT_TRACKING = true;
            Client.Settings.PARCEL_TRACKING = true;
            Client.Settings.ALWAYS_REQUEST_PARCEL_DWELL = true;
            Client.Settings.ALWAYS_REQUEST_PARCEL_ACL = true;
            Client.Settings.SEND_AGENT_UPDATES = true;
            // Smoother movement for autopilot.
            Client.Settings.DISABLE_AGENT_UPDATE_DUPLICATE_CHECK = true;
            Client.Settings.ENABLE_CAPS = true;
            // Set the asset cache directory.
            Client.Settings.ASSET_CACHE_DIR = Path.Combine(CORRADE_CONSTANTS.CACHE_DIRECTORY,
                CORRADE_CONSTANTS.ASSET_CACHE_DIRECTORY);
            Client.Settings.USE_ASSET_CACHE = true;
            Client.Assets.Cache.AutoPruneEnabled = false;
            // More precision for object and avatar tracking updates.
            Client.Settings.USE_INTERPOLATION_TIMER = true;
            Client.Settings.FETCH_MISSING_INVENTORY = true;
            Client.Settings.HTTP_INVENTORY = true;
            // Transfer textures over HTTP if possible.
            Client.Settings.USE_HTTP_TEXTURES = true;
            // Needed for commands dealing with terrain height.
            Client.Settings.STORE_LAND_PATCHES = true;
            // Decode simulator statistics.
            Client.Settings.ENABLE_SIMSTATS = true;
            // Throttling.
            Client.Settings.THROTTLE_OUTGOING_PACKETS = false;
            Client.Throttle.Total = corradeConfiguration.ThrottleTotal;
            Client.Throttle.Land = corradeConfiguration.ThrottleLand;
            Client.Throttle.Task = corradeConfiguration.ThrottleTask;
            Client.Throttle.Texture = corradeConfiguration.ThrottleTexture;
            Client.Throttle.Wind = corradeConfiguration.ThrottleWind;
            Client.Throttle.Resend = corradeConfiguration.ThrottleResend;
            Client.Throttle.Asset = corradeConfiguration.ThrottleAsset;
            Client.Throttle.Cloud = corradeConfiguration.ThrottleCloud;
            // Enable multiple simulators
            Client.Settings.MULTIPLE_SIMS = true;
            // Check TOS
            if (!corradeConfiguration.TOSAccepted)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TOS_NOT_ACCEPTED));
                Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
            }
            // Proceed to log-in.
            LoginParams login = new LoginParams(
                Client,
                corradeConfiguration.FirstName,
                corradeConfiguration.LastName,
                corradeConfiguration.Password,
                CORRADE_CONSTANTS.CLIENT_CHANNEL,
                CORRADE_CONSTANTS.CORRADE_VERSION.ToString(CultureInfo.DefaultThreadCurrentCulture),
                corradeConfiguration.LoginURL)
            {
                Author = CORRADE_CONSTANTS.WIZARDRY_AND_STEAMWORKS,
                AgreeToTos = corradeConfiguration.TOSAccepted,
                Start = corradeConfiguration.StartLocation,
                UserAgent = CORRADE_CONSTANTS.USER_AGENT
            };
            // Set the outgoing IP address if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.BindIPAddress))
            {
                try
                {
                    Settings.BIND_ADDR = IPAddress.Parse(corradeConfiguration.BindIPAddress);
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNKNOWN_IP_ADDRESS), ex.Message);
                    Environment.Exit(corradeConfiguration.ExitCodeAbnormal);
                }
            }
            // Set the ID0 if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.DriveIdentifierHash))
            {
                login.ID0 = Utils.MD5String(corradeConfiguration.DriveIdentifierHash);
            }
            // Set the MAC if specified in the configuration file.
            if (!string.IsNullOrEmpty(corradeConfiguration.NetworkCardMAC))
            {
                login.MAC = Utils.MD5String(corradeConfiguration.NetworkCardMAC);
            }
            // Load Corrade caches.
            LoadCorradeCache.Invoke();
            // Load group members.
            LoadGroupMembersState.Invoke();
            // Load Corrade states.
            LoadNotificationState.Invoke();
            // Start the callback thread to send callbacks.
            Thread CallbackThread = new Thread(() =>
            {
                do
                {
                    try
                    {
                        Thread.Sleep((int) corradeConfiguration.CallbackThrottle);
                        if (!CallbackQueue.Any()) continue;
                        CallbackQueueElement callbackQueueElement = CallbackQueue.Dequeue();
                        if (!callbackQueueElement.Equals(default(CallbackQueueElement)))
                        {
                            CorradeThreadPool[CorradeThreadType.POST].Spawn(
                                () => wasPOST(callbackQueueElement.URL, callbackQueueElement.message,
                                    corradeConfiguration.CallbackTimeout), corradeConfiguration.MaximumPOSTThreads);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.CALLBACK_ERROR),
                            ex.Message);
                    }
                } while (runCallbackThread);
            })
            {IsBackground = true, Priority = ThreadPriority.Lowest};
            CallbackThread.Start();
            // Start the notification thread for notifications.
            Thread NotificationThread = new Thread(() =>
            {
                do
                {
                    try
                    {
                        Thread.Sleep((int) corradeConfiguration.NotificationThrottle);
                        if (!NotificationQueue.Any()) continue;
                        NotificationQueueElement notificationQueueElement = NotificationQueue.Dequeue();
                        if (!notificationQueueElement.Equals(default(NotificationQueueElement)))
                        {
                            CorradeThreadPool[CorradeThreadType.POST].Spawn(
                                () => wasPOST(notificationQueueElement.URL, notificationQueueElement.message,
                                    corradeConfiguration.NotificationTimeout), corradeConfiguration.MaximumPOSTThreads);
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR),
                            ex.Message);
                    }
                } while (runNotificationThread);
            })
            {IsBackground = true, Priority = ThreadPriority.Lowest};
            NotificationThread.Start();
            // Install non-dynamic global event handlers.
            Client.Inventory.InventoryObjectOffered += HandleInventoryObjectOffered;
            Client.Network.LoginProgress += HandleLoginProgress;
            Client.Appearance.AppearanceSet += HandleAppearanceSet;
            Client.Network.SimConnected += HandleSimulatorConnected;
            Client.Network.Disconnected += HandleDisconnected;
            Client.Network.SimDisconnected += HandleSimulatorDisconnected;
            Client.Network.EventQueueRunning += HandleEventQueueRunning;
            Client.Self.TeleportProgress += HandleTeleportProgress;
            Client.Self.ChatFromSimulator += HandleChatFromSimulator;
            Client.Groups.GroupJoinedReply += HandleGroupJoined;
            Client.Groups.GroupLeaveReply += HandleGroupLeave;
            // Each Instant Message is processed in its own thread.
            Client.Self.IM += (sender, args) => CorradeThreadPool[CorradeThreadType.INSTANT_MESSAGE].Spawn(
                () => HandleSelfIM(sender, args),
                corradeConfiguration.MaximumInstantMessageThreads);
            // Log-in to the grid.
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGGING_IN));
            Client.Network.Login(login);
            /*
             * The main thread spins around waiting for the semaphores to become invalidated,
             * at which point Corrade will consider its connection to the grid severed and
             * will terminate.
             *
             */
            WaitHandle.WaitAny(ConnectionSemaphores.Values.Select(o => (WaitHandle) o).ToArray());
            // Now log-out.
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGGING_OUT));
            // Uninstall all installed handlers
            Client.Self.IM -= HandleSelfIM;
            Client.Network.SimChanged -= HandleRadarObjects;
            Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
            Client.Objects.ObjectUpdate -= HandleObjectUpdate;
            Client.Objects.KillObject -= HandleKillObject;
            Client.Self.LoadURL -= HandleLoadURL;
            Client.Self.ScriptControlChange -= HandleScriptControlChange;
            Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
            Client.Network.SimChanged -= HandleSimChanged;
            Client.Self.RegionCrossed -= HandleRegionCrossed;
            Client.Self.MeanCollision -= HandleMeanCollision;
            Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
            Client.Avatars.ViewerEffect -= HandleViewerEffect;
            Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
            Client.Self.ScriptDialog -= HandleScriptDialog;
            Client.Self.ChatFromSimulator -= HandleChatFromSimulator;
            Client.Self.MoneyBalance -= HandleMoneyBalance;
            Client.Self.AlertMessage -= HandleAlertMessage;
            Client.Self.ScriptQuestion -= HandleScriptQuestion;
            Client.Self.TeleportProgress -= HandleTeleportProgress;
            Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
            Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
            Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
            Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
            Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
            Client.Network.EventQueueRunning -= HandleEventQueueRunning;
            Client.Network.SimDisconnected -= HandleSimulatorDisconnected;
            Client.Network.Disconnected -= HandleDisconnected;
            Client.Network.SimConnected -= HandleSimulatorConnected;
            Client.Appearance.AppearanceSet -= HandleAppearanceSet;
            Client.Network.LoginProgress -= HandleLoginProgress;
            Client.Inventory.InventoryObjectOffered -= HandleInventoryObjectOffered;
            // Save Corrade states.
            lock (GroupNotificationsLock)
            {
                SaveNotificationState.Invoke();
            }
            // Save group members.
            lock (GroupMembersLock)
            {
                SaveGroupMembersState.Invoke();
            }
            // Save Corrade caches.
            SaveCorradeCache.Invoke();
            // Stop the sphere effects expiration thread.
            runEffectsExpirationThread = false;
            if (EffectsExpirationThread != null)
            {
                try
                {
                    if (
                        (EffectsExpirationThread.ThreadState.Equals(ThreadState.Running) ||
                         EffectsExpirationThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                    {
                        if (!EffectsExpirationThread.Join(1000))
                        {
                            EffectsExpirationThread.Abort();
                            EffectsExpirationThread.Join();
                        }
                    }
                }
                catch (Exception)
                {
                    /* We are going down and we do not care. */
                }
                finally
                {
                    EffectsExpirationThread = null;
                }
            }
            // Stop the group member sweep thread.
            StopGroupMembershipSweepThread.Invoke();
            // Stop the notification thread.
            try
            {
                runNotificationThread = false;
                if (
                    (NotificationThread.ThreadState.Equals(ThreadState.Running) ||
                     NotificationThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                {
                    if (!NotificationThread.Join(1000))
                    {
                        NotificationThread.Abort();
                        NotificationThread.Join();
                    }
                }
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            finally
            {
                NotificationThread = null;
            }

            // Stop the callback thread.
            try
            {
                runCallbackThread = false;
                if (
                    (CallbackThread.ThreadState.Equals(ThreadState.Running) ||
                     CallbackThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                {
                    if (!CallbackThread.Join(1000))
                    {
                        CallbackThread.Abort();
                        CallbackThread.Join();
                    }
                }
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            finally
            {
                NotificationThread = null;
            }

            // Close HTTP server
            if (HttpListener.IsSupported && corradeConfiguration.EnableHTTPServer)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.STOPPING_HTTP_SERVER));
                runHTTPServer = false;
                try
                {
                    if (HTTPListenerThread != null)
                    {
                        HTTPListener.Stop();
                        if (
                            (HTTPListenerThread.ThreadState.Equals(ThreadState.Running) ||
                             HTTPListenerThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                        {
                            if (!HTTPListenerThread.Join(1000))
                            {
                                HTTPListenerThread.Abort();
                                HTTPListenerThread.Join();
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    /* We are going down and we do not care. */
                }
                finally
                {
                    HTTPListenerThread = null;
                }
            }
            // Reject any inventory that has not been accepted.
            lock (InventoryOffersLock)
            {
                Parallel.ForEach(InventoryOffers, o =>
                {
                    o.Key.Accept = false;
                    o.Value.Set();
                });
            }
            // Disable the configuration watcher.
            try
            {
                ConfigurationWatcher.EnableRaisingEvents = false;
                ConfigurationWatcher.Changed -= HandleConfigurationFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the notifications watcher.
            try
            {
                NotificationsWatcher.EnableRaisingEvents = false;
                NotificationsWatcher.Changed -= HandleNotificationsFileChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Disable the AIML bot configuration watcher.
            try
            {
                AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                AIMLBotConfigurationWatcher.Changed -= HandleAIMLBotConfigurationChanged;
            }
            catch (Exception)
            {
                /* We are going down and we do not care. */
            }
            // Save the AIML user session.
            lock (AIMLBotLock)
            {
                if (AIMLBotBrainCompiled)
                {
                    SaveChatBotFiles.Invoke();
                }
            }
            // Logout
            if (Client.Network.Connected)
            {
                // Full speed ahead; do not even attempt to grab a lock.
                ManualResetEvent LoggedOutEvent = new ManualResetEvent(false);
                EventHandler<LoggedOutEventArgs> LoggedOutEventHandler = (sender, args) => LoggedOutEvent.Set();
                Client.Network.LoggedOut += LoggedOutEventHandler;
                Client.Network.RequestLogout();
                if (!LoggedOutEvent.WaitOne((int) corradeConfiguration.LogoutGrace, false))
                {
                    Client.Network.LoggedOut -= LoggedOutEventHandler;
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TIMEOUT_LOGGING_OUT));
                }
                Client.Network.LoggedOut -= LoggedOutEventHandler;
            }
            if (Client.Network.Connected)
            {
                Client.Network.Shutdown(NetworkManager.DisconnectType.ClientInitiated);
            }

            // Terminate.
            Environment.Exit(corradeConfiguration.ExitCodeExpected);
        }

        private static void HandleAvatarUpdate(object sender, AvatarUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.RadarAvatars, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleObjectUpdate(object sender, PrimEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.RadarPrimitives, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleKillObject(object sender, KillObjectEventArgs e)
        {
            KeyValuePair<UUID, Primitive> tracked;
            lock (RadarObjectsLock)
            {
                tracked =
                    RadarObjects.AsParallel().FirstOrDefault(o => o.Value.LocalID.Equals(e.ObjectLocalID));
            }
            switch (!tracked.Equals(default(KeyValuePair<UUID, Primitive>)))
            {
                case true:
                    switch (tracked.Value is Avatar)
                    {
                        case true:
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Notifications.RadarAvatars, e),
                                corradeConfiguration.MaximumNotificationThreads);
                            break;
                        default:
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Notifications.RadarPrimitives, e),
                                corradeConfiguration.MaximumNotificationThreads);
                            break;
                    }
                    break;
            }
        }

        private static void HandleGroupJoined(object sender, GroupOperationEventArgs e)
        {
            // Add the group to the cache.
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                if (!Cache.CurrentGroupsCache.Contains(e.GroupID))
                {
                    Cache.CurrentGroupsCache.Add(e.GroupID);
                }
            }
            // Join group chat if possible.
            if (!Client.Self.GroupChatSessions.ContainsKey(e.GroupID) &&
                HasGroupPowers(Client.Self.AgentID, e.GroupID, GroupPowers.JoinChat,
                    corradeConfiguration.ServicesTimeout))
            {
                JoinGroupChat(e.GroupID, corradeConfiguration.ServicesTimeout);
            }
        }

        private static void HandleGroupLeave(object sender, GroupOperationEventArgs e)
        {
            // Remove the group from the cache.
            lock (Cache.Locks.CurrentGroupsCacheLock)
            {
                Cache.CurrentGroupsCache.Remove(e.GroupID);
            }
        }

        private static void HandleLoadURL(object sender, LoadUrlEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.LoadURL, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleScriptControlChange(object sender, ScriptControlEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.ScriptControl, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleAppearanceSet(object sender, AppearanceSetEventArgs e)
        {
            switch (e.Success)
            {
                case true:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_SUCCEEDED));
                    break;
                default:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.APPEARANCE_SET_FAILED));
                    break;
            }
        }

        private static void HandleRegionCrossed(object sender, RegionCrossedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.RegionCrossed, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMeanCollision(object sender, MeanCollisionEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.MeanCollision, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleViewerEffect(object sender, object e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.ViewerEffect, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        /// <summary>
        ///     Processes HTTP POST web-requests.
        /// </summary>
        /// <param name="ar">the async HTTP listener object</param>
        private static void ProcessHTTPRequest(IAsyncResult ar)
        {
            // We need to grab the context and everything else outside of the main request.
            HttpListenerContext httpContext;
            HttpListenerRequest httpRequest;
            string message;
            Group commandGroup;
            // Now grab the message and check that the group is set or abandon.
            try
            {
                HttpListener httpListener = ar.AsyncState as HttpListener;
                // bail if we are not listening
                if (httpListener == null || !httpListener.IsListening) return;
                httpContext = httpListener.EndGetContext(ar);
                if (httpContext.Request == null) return;
                httpRequest = httpContext.Request;
                // only accept POST requests
                if (!httpRequest.HttpMethod.Equals(WebRequestMethods.Http.Post, StringComparison.OrdinalIgnoreCase))
                    return;
                // only accept connected remote endpoints
                if (httpRequest.RemoteEndPoint == null) return;
                // retrieve the message sent.
                using (StreamReader reader = new StreamReader(httpRequest.InputStream, httpRequest.ContentEncoding))
                {
                    message = reader.ReadToEnd();
                }
                // ignore empty messages right-away.
                if (string.IsNullOrEmpty(message)) return;
                commandGroup = GetCorradeGroupFromMessage(message);
                // do not process anything from unknown groups.
                switch (!commandGroup.Equals(default(Group)))
                {
                    case false:
                        return;
                }
            }
            catch (HttpListenerException)
            {
                /* This happens when the server goes down, so do not scare the user since it is completely harmelss. */
                return;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_PROCESSING_ABORTED), ex.Message);
                return;
            }

            // We have the group so schedule the Corrade command though the group scheduler.
            CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(() =>
            {
                try
                {
                    Dictionary<string, string> result = HandleCorradeCommand(message,
                        CORRADE_CONSTANTS.WEB_REQUEST,
                        httpRequest.RemoteEndPoint.ToString(), commandGroup);
                    if (result == null) return;
                    using (HttpListenerResponse response = httpContext.Response)
                    {
                        // set the content type based on chosen output filers
                        switch (corradeConfiguration.OutputFilters.Last())
                        {
                            case Filter.RFC1738:
                                response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                                break;
                            default:
                                response.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                                break;
                        }
                        byte[] data = result.Any()
                            ? Encoding.UTF8.GetBytes(wasKeyValueEncode(wasKeyValueEscape(result)))
                            : new byte[0];
                        response.StatusCode = (int) HttpStatusCode.OK;
                        response.StatusDescription = "OK";
                        response.ProtocolVersion = HttpVersion.Version11;
                        response.KeepAlive = corradeConfiguration.HTTPServerKeepAlive;
                        using (MemoryStream outputStream = new MemoryStream())
                        {
                            switch (corradeConfiguration.HTTPServerCompression)
                            {
                                case HTTPCompressionMethod.GZIP:
                                    using (GZipStream dataGZipStream = new GZipStream(outputStream,
                                        CompressionMode.Compress, false))
                                    {
                                        dataGZipStream.Write(data, 0, data.Length);
                                        dataGZipStream.Flush();
                                    }
                                    response.AddHeader("Content-Encoding", "gzip");
                                    data = outputStream.ToArray();
                                    break;
                                case HTTPCompressionMethod.DEFLATE:
                                    using (
                                        DeflateStream dataDeflateStream = new DeflateStream(outputStream,
                                            CompressionMode.Compress, false))
                                    {
                                        dataDeflateStream.Write(data, 0, data.Length);
                                        dataDeflateStream.Flush();
                                    }
                                    response.AddHeader("Content-Encoding", "deflate");
                                    data = outputStream.ToArray();
                                    break;
                                default:
                                    response.AddHeader("Content-Encoding", "UTF-8");
                                    break;
                            }
                        }
                        response.ContentLength64 += data.Length;
                        using (Stream responseStream = response.OutputStream)
                        {
                            responseStream.Write(data, 0, (int) response.ContentLength64);
                            //responseStream.Flush();
                        }
                    }
                }
                catch (HttpListenerException)
                {
                    /* This happens when the server goes down, so do not scare the user since it is completely harmless. */
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_PROCESSING_ABORTED), ex.Message);
                }
            }, corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                corradeConfiguration.SchedulerExpiration);
        }

        /// <summary>
        ///     Sends a notification to each group with a configured and installed notification.
        /// </summary>
        /// <param name="notification">the notification to send</param>
        /// <param name="args">the event arguments</param>
        private static void SendNotification(Notifications notification, object args)
        {
            // Create a list of groups that have the notification installed.
            List<Notification> notifyGroups = new List<Notification>();
            lock (GroupNotificationsLock)
            {
                notifyGroups.AddRange(GroupNotifications.AsParallel()
                    .Where(
                        o =>
                            !(o.NotificationMask & (uint) notification).Equals(0) &&
                            corradeConfiguration.Groups.AsParallel().Any(
                                p => p.Name.Equals(o.GroupName, StringComparison.OrdinalIgnoreCase) &&
                                     !(p.NotificationMask & (uint) notification).Equals(0))));
            }

            // No groups to notify so bail directly.
            if (!notifyGroups.Any()) return;

            // For each group build the notification.
            Parallel.ForEach(notifyGroups, z =>
            {
                // Set the notification type
                Dictionary<string, string> notificationData = new Dictionary<string, string>();

                // Create the executable delegate.
                System.Action execute;

                // Build the notification data
                switch (notification)
                {
                    case Notifications.ScriptDialog:
                        execute = () =>
                        {
                            ScriptDialogEventArgs scriptDialogEventArgs = (ScriptDialogEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(scriptDialogEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                scriptDialogEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                scriptDialogEventArgs.FirstName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                scriptDialogEventArgs.LastName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL),
                                scriptDialogEventArgs.Channel.ToString(CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                scriptDialogEventArgs.ObjectName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                scriptDialogEventArgs.ObjectID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                scriptDialogEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BUTTON),
                                wasEnumerableToCSV(scriptDialogEventArgs.ButtonLabels));
                        };
                        break;
                    case Notifications.LocalChat:
                        execute = () =>
                        {
                            ChatEventArgs localChatEventArgs = (ChatEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(localChatEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(localChatEventArgs.FromName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                localChatEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                localChatEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                localChatEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                localChatEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                Enum.GetName(typeof (ChatSourceType), localChatEventArgs.SourceType));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AUDIBLE),
                                Enum.GetName(typeof (ChatAudibleLevel), localChatEventArgs.AudibleLevel));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.VOLUME),
                                Enum.GetName(typeof (ChatType), localChatEventArgs.Type));
                        };
                        break;
                    case Notifications.Balance:
                        execute = () =>
                        {
                            BalanceEventArgs balanceEventArgs = (BalanceEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(balanceEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BALANCE),
                                balanceEventArgs.Balance.ToString(CultureInfo.DefaultThreadCurrentCulture));
                        };
                        break;
                    case Notifications.AlertMessage:
                        execute = () =>
                        {
                            AlertMessageEventArgs alertMessageEventArgs = (AlertMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(alertMessageEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                alertMessageEventArgs.Message);
                        };
                        break;
                    case Notifications.Inventory:
                        execute = () =>
                        {
                            System.Type inventoryOfferedType = args.GetType();
                            if (inventoryOfferedType == typeof (InstantMessageEventArgs))
                            {
                                InstantMessageEventArgs inventoryOfferEventArgs = (InstantMessageEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(inventoryOfferEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                List<string> inventoryObjectOfferedName =
                                    new List<string>(CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(
                                        inventoryOfferEventArgs.IM.FromAgentName)
                                        .Cast<Match>()
                                        .ToDictionary(p => new[]
                                        {
                                            p.Groups["first"].Value,
                                            p.Groups["last"].Value
                                        })
                                        .SelectMany(
                                            p =>
                                                new[]
                                                {
                                                    p.Key[0].Trim(),
                                                    !string.IsNullOrEmpty(p.Key[1])
                                                        ? p.Key[1].Trim()
                                                        : string.Empty
                                                }));
                                switch (!string.IsNullOrEmpty(inventoryObjectOfferedName.Last()))
                                {
                                    case true:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            inventoryObjectOfferedName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            inventoryObjectOfferedName.Last());
                                        break;
                                    default:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                            inventoryObjectOfferedName.First());
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    inventoryOfferEventArgs.IM.FromAgentID.ToString());
                                switch (inventoryOfferEventArgs.IM.Dialog)
                                {
                                    case InstantMessageDialog.InventoryAccepted:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                            wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                        break;
                                    case InstantMessageDialog.InventoryDeclined:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                            wasGetDescriptionFromEnumValue(Action.DECLINE));
                                        break;
                                    case InstantMessageDialog.TaskInventoryOffered:
                                    case InstantMessageDialog.InventoryOffered:
                                        lock (InventoryOffersLock)
                                        {
                                            KeyValuePair<InventoryObjectOfferedEventArgs, ManualResetEvent>
                                                inventoryObjectOfferedEventArgs =
                                                    InventoryOffers.AsParallel().FirstOrDefault(p =>
                                                        p.Key.Offer.IMSessionID.Equals(
                                                            inventoryOfferEventArgs.IM.IMSessionID));
                                            if (
                                                !inventoryObjectOfferedEventArgs.Equals(
                                                    default(
                                                        KeyValuePair
                                                            <InventoryObjectOfferedEventArgs, ManualResetEvent>)))
                                            {
                                                switch (inventoryObjectOfferedEventArgs.Key.Accept)
                                                {
                                                    case true:
                                                        notificationData.Add(
                                                            wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                                            wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                                        break;
                                                    default:
                                                        notificationData.Add(
                                                            wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                                            wasGetDescriptionFromEnumValue(Action.DECLINE));
                                                        break;
                                                }
                                            }
                                            GroupCollection groups =
                                                CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(
                                                    inventoryObjectOfferedEventArgs.Key.Offer.Message).Groups;
                                            if (groups.Count > 0)
                                            {
                                                notificationData.Add(
                                                    wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                                    groups[1].Value);
                                            }
                                            InventoryOffers.Remove(inventoryObjectOfferedEventArgs.Key);
                                        }
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION),
                                    wasGetDescriptionFromEnumValue(Action.REPLY));
                                return;
                            }
                            if (inventoryOfferedType == typeof (InventoryObjectOfferedEventArgs))
                            {
                                InventoryObjectOfferedEventArgs inventoryObjectOfferedEventArgs =
                                    (InventoryObjectOfferedEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(inventoryObjectOfferedEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                List<string> inventoryObjectOfferedName =
                                    new List<string>(CORRADE_CONSTANTS.AvatarFullNameRegex.Matches(
                                        inventoryObjectOfferedEventArgs.Offer.FromAgentName)
                                        .Cast<Match>()
                                        .ToDictionary(p => new[]
                                        {
                                            p.Groups["first"].Value,
                                            p.Groups["last"].Value
                                        })
                                        .SelectMany(
                                            p =>
                                                new[]
                                                {
                                                    p.Key[0],
                                                    !string.IsNullOrEmpty(p.Key[1])
                                                        ? p.Key[1]
                                                        : string.Empty
                                                }));
                                switch (!string.IsNullOrEmpty(inventoryObjectOfferedName.Last()))
                                {
                                    case true:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            inventoryObjectOfferedName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            inventoryObjectOfferedName.Last());
                                        break;
                                    default:
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                            inventoryObjectOfferedName.First());
                                        break;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    inventoryObjectOfferedEventArgs.Offer.FromAgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ASSET),
                                    inventoryObjectOfferedEventArgs.AssetType.ToString());
                                GroupCollection groups =
                                    CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(
                                        inventoryObjectOfferedEventArgs.Offer.Message).Groups;
                                if (groups.Count > 0)
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                        groups[1].Value);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                    inventoryObjectOfferedEventArgs.Offer.IMSessionID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION),
                                    wasGetDescriptionFromEnumValue(Action.OFFER));
                            }
                        };
                        break;
                    case Notifications.ScriptPermission:
                        execute = () =>
                        {
                            ScriptQuestionEventArgs scriptQuestionEventArgs = (ScriptQuestionEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(scriptQuestionEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                scriptQuestionEventArgs.ItemID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TASK),
                                scriptQuestionEventArgs.TaskID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS),
                                wasEnumerableToCSV(typeof (ScriptPermission).GetFields(BindingFlags.Public |
                                                                                       BindingFlags.Static)
                                    .AsParallel().Where(
                                        p =>
                                            !(((int) p.GetValue(null) &
                                               (int) scriptQuestionEventArgs.Questions)).Equals(0))
                                    .Select(p => p.Name)));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.REGION),
                                scriptQuestionEventArgs.Simulator.Name);
                        };
                        break;
                    case Notifications.Friendship:
                        execute = () =>
                        {
                            System.Type friendshipNotificationType = args.GetType();
                            if (friendshipNotificationType == typeof (FriendInfoEventArgs))
                            {
                                FriendInfoEventArgs friendInfoEventArgs = (FriendInfoEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(friendInfoEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                IEnumerable<string> name = GetAvatarNames(friendInfoEventArgs.Friend.Name);
                                if (name != null)
                                {
                                    List<string> fullName = new List<string>(name);
                                    if (fullName.Count.Equals(2))
                                    {
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            fullName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            fullName.Last());
                                    }
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendInfoEventArgs.Friend.UUID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.STATUS),
                                    friendInfoEventArgs.Friend.IsOnline
                                        ? wasGetDescriptionFromEnumValue(Action.ONLINE)
                                        : wasGetDescriptionFromEnumValue(Action.OFFLINE));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.RIGHTS),
                                    // Return the friend rights as a nice CSV string.
                                    wasEnumerableToCSV(typeof (FriendRights).GetFields(BindingFlags.Public |
                                                                                       BindingFlags.Static)
                                        .AsParallel().Where(
                                            p =>
                                                !(((int) p.GetValue(null) &
                                                   (int) friendInfoEventArgs.Friend.MyFriendRights))
                                                    .Equals(
                                                        0))
                                        .Select(p => p.Name)));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.UPDATE));
                                return;
                            }
                            if (friendshipNotificationType == typeof (FriendshipResponseEventArgs))
                            {
                                FriendshipResponseEventArgs friendshipResponseEventArgs =
                                    (FriendshipResponseEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(friendshipResponseEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                IEnumerable<string> name = GetAvatarNames(friendshipResponseEventArgs.AgentName);
                                if (name != null)
                                {
                                    List<string> fullName = new List<string>(name);
                                    if (fullName.Count.Equals(2))
                                    {
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            fullName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            fullName.Last());
                                    }
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendshipResponseEventArgs.AgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.RESPONSE));
                                return;
                            }
                            if (friendshipNotificationType == typeof (FriendshipOfferedEventArgs))
                            {
                                FriendshipOfferedEventArgs friendshipOfferedEventArgs =
                                    (FriendshipOfferedEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(friendshipOfferedEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                IEnumerable<string> name = GetAvatarNames(friendshipOfferedEventArgs.AgentName);
                                if (name != null)
                                {
                                    List<string> fullName = new List<string>(name);
                                    if (fullName.Count.Equals(2))
                                    {
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                            fullName.First());
                                        notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                            fullName.Last());
                                    }
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                    friendshipOfferedEventArgs.AgentID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.REQUEST));
                            }
                        };
                        break;
                    case Notifications.TeleportLure:
                        execute = () =>
                        {
                            InstantMessageEventArgs teleportLureEventArgs = (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(teleportLureEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(teleportLureEventArgs.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                teleportLureEventArgs.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                teleportLureEventArgs.IM.IMSessionID.ToString());
                        };
                        break;
                    case Notifications.GroupNotice:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationGroupNoticeEventArgs =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationGroupNoticeEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(notificationGroupNoticeEventArgs.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupNoticeEventArgs.IM.FromAgentID.ToString());
                            string[] noticeData = notificationGroupNoticeEventArgs.IM.Message.Split('|');
                            if (noticeData.Length > 0 && !string.IsNullOrEmpty(noticeData[0]))
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SUBJECT),
                                    noticeData[0]);
                            }
                            if (noticeData.Length > 1 && !string.IsNullOrEmpty(noticeData[1]))
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                    noticeData[1]);
                            }
                            switch (notificationGroupNoticeEventArgs.IM.Dialog)
                            {
                                case InstantMessageDialog.GroupNoticeInventoryAccepted:
                                case InstantMessageDialog.GroupNoticeInventoryDeclined:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !notificationGroupNoticeEventArgs.IM.Dialog.Equals(
                                            InstantMessageDialog.GroupNoticeInventoryAccepted)
                                            ? wasGetDescriptionFromEnumValue(Action.DECLINE)
                                            : wasGetDescriptionFromEnumValue(Action.ACCEPT));
                                    break;
                                case InstantMessageDialog.GroupNotice:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        wasGetDescriptionFromEnumValue(Action.RECEIVED));
                                    break;
                            }
                        };
                        break;
                    case Notifications.InstantMessage:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationInstantMessage =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationInstantMessage,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(notificationInstantMessage.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationInstantMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationInstantMessage.IM.Message);
                        };
                        break;
                    case Notifications.RegionMessage:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationRegionMessage =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationRegionMessage,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(notificationRegionMessage.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationRegionMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationRegionMessage.IM.Message);
                        };
                        break;
                    case Notifications.GroupMessage:
                        execute = () =>
                        {
                            GroupMessageEventArgs notificationGroupMessage = (GroupMessageEventArgs) args;
                            // Set-up filters.
                            if (!notificationGroupMessage.GroupUUID.Equals(z.GroupUUID)) return;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationGroupMessage,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                notificationGroupMessage.FirstName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                notificationGroupMessage.LastName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupMessage.AgentUUID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                notificationGroupMessage.GroupName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationGroupMessage.Message);
                        };
                        break;
                    case Notifications.ViewerEffect:
                        execute = () =>
                        {
                            System.Type viewerEffectType = args.GetType();
                            if (viewerEffectType == typeof (ViewerEffectEventArgs))
                            {
                                ViewerEffectEventArgs notificationViewerEffectEventArgs =
                                    (ViewerEffectEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(notificationViewerEffectEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT),
                                    notificationViewerEffectEventArgs.Type.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerEffectEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerEffectEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerEffectEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerEffectEventArgs.Duration.ToString(
                                        CultureInfo.DefaultThreadCurrentCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerEffectEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.GENERIC));
                                return;
                            }
                            if (viewerEffectType == typeof (ViewerEffectPointAtEventArgs))
                            {
                                ViewerEffectPointAtEventArgs notificationViewerPointAtEventArgs =
                                    (ViewerEffectPointAtEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(notificationViewerPointAtEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerPointAtEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerPointAtEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerPointAtEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerPointAtEventArgs.Duration.ToString(
                                        CultureInfo.DefaultThreadCurrentCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerPointAtEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.POINT));
                                return;
                            }
                            if (viewerEffectType == typeof (ViewerEffectLookAtEventArgs))
                            {
                                ViewerEffectLookAtEventArgs notificationViewerLookAtEventArgs =
                                    (ViewerEffectLookAtEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(notificationViewerLookAtEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                    notificationViewerLookAtEventArgs.SourceID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                    notificationViewerLookAtEventArgs.TargetID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    notificationViewerLookAtEventArgs.TargetPosition.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION),
                                    notificationViewerLookAtEventArgs.Duration.ToString(
                                        CultureInfo.DefaultThreadCurrentCulture));
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    notificationViewerLookAtEventArgs.EffectID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.LOOK));
                            }
                        };
                        break;
                    case Notifications.MeanCollision:
                        execute = () =>
                        {
                            MeanCollisionEventArgs meanCollisionEventArgs =
                                (MeanCollisionEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(meanCollisionEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGGRESSOR),
                                meanCollisionEventArgs.Aggressor.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MAGNITUDE),
                                meanCollisionEventArgs.Magnitude.ToString(CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TIME),
                                meanCollisionEventArgs.Time.ToLongDateString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                meanCollisionEventArgs.Type.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.VICTIM),
                                meanCollisionEventArgs.Victim.ToString());
                        };
                        break;
                    case Notifications.RegionCrossed:
                        execute = () =>
                        {
                            System.Type regionChangeType = args.GetType();
                            if (regionChangeType == typeof (SimChangedEventArgs))
                            {
                                SimChangedEventArgs simChangedEventArgs = (SimChangedEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(simChangedEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                if (simChangedEventArgs.PreviousSimulator != null)
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OLD),
                                        simChangedEventArgs.PreviousSimulator.Name);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NEW),
                                    Client.Network.CurrentSim.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.CHANGED));
                                return;
                            }
                            if (regionChangeType == typeof (RegionCrossedEventArgs))
                            {
                                RegionCrossedEventArgs regionCrossedEventArgs =
                                    (RegionCrossedEventArgs) args;
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(regionCrossedEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                if (regionCrossedEventArgs.OldSimulator != null)
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OLD),
                                        regionCrossedEventArgs.OldSimulator.Name);
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NEW),
                                    regionCrossedEventArgs.NewSimulator.Name);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.CROSSED));
                            }
                        };
                        break;
                    case Notifications.TerseUpdates:
                        execute = () =>
                        {
                            TerseObjectUpdateEventArgs terseObjectUpdateEventArgs =
                                (TerseObjectUpdateEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(terseObjectUpdateEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                terseObjectUpdateEventArgs.Prim.ID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                terseObjectUpdateEventArgs.Prim.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                terseObjectUpdateEventArgs.Prim.Rotation.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                terseObjectUpdateEventArgs.Prim.PrimData.PCode.ToString());
                        };
                        break;
                    case Notifications.Typing:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationTypingMessageEventArgs =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationTypingMessageEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name =
                                GetAvatarNames(notificationTypingMessageEventArgs.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationTypingMessageEventArgs.IM.FromAgentID.ToString());
                            switch (notificationTypingMessageEventArgs.IM.Dialog)
                            {
                                case InstantMessageDialog.StartTyping:
                                case InstantMessageDialog.StopTyping:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !notificationTypingMessageEventArgs.IM.Dialog.Equals(
                                            InstantMessageDialog.StartTyping)
                                            ? wasGetDescriptionFromEnumValue(Action.STOP)
                                            : wasGetDescriptionFromEnumValue(Action.START));
                                    break;
                            }
                        };
                        break;
                    case Notifications.GroupInvite:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationGroupInviteEventArgs =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationGroupInviteEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(notificationGroupInviteEventArgs.IM.FromAgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                notificationGroupInviteEventArgs.IM.FromAgentID.ToString());
                            lock (GroupInviteLock)
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                    GroupInvites.AsParallel().FirstOrDefault(
                                        p => p.Session.Equals(notificationGroupInviteEventArgs.IM.IMSessionID))
                                        .Group);
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                notificationGroupInviteEventArgs.IM.IMSessionID.ToString());
                        };
                        break;
                    case Notifications.Economy:
                        execute = () =>
                        {
                            MoneyBalanceReplyEventArgs notificationMoneyBalanceEventArgs =
                                (MoneyBalanceReplyEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationMoneyBalanceEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.BALANCE),
                                notificationMoneyBalanceEventArgs.Balance.ToString(
                                    CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION),
                                notificationMoneyBalanceEventArgs.Description);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.COMMITTED),
                                notificationMoneyBalanceEventArgs.MetersCommitted.ToString(
                                    CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.CREDIT),
                                notificationMoneyBalanceEventArgs.MetersCredit.ToString(
                                    CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SUCCESS),
                                notificationMoneyBalanceEventArgs.Success.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                notificationMoneyBalanceEventArgs.TransactionID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT),
                                notificationMoneyBalanceEventArgs.TransactionInfo.Amount.ToString(
                                    CultureInfo.DefaultThreadCurrentCulture));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET),
                                notificationMoneyBalanceEventArgs.TransactionInfo.DestID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE),
                                notificationMoneyBalanceEventArgs.TransactionInfo.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TRANSACTION),
                                Enum.GetName(typeof (MoneyTransactionType),
                                    notificationMoneyBalanceEventArgs.TransactionInfo.TransactionType));
                        };
                        break;
                    case Notifications.GroupMembership:
                        execute = () =>
                        {
                            GroupMembershipEventArgs groupMembershipEventArgs = (GroupMembershipEventArgs) args;
                            // Set-up filters.
                            if (!groupMembershipEventArgs.GroupUUID.Equals(z.GroupUUID)) return;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(groupMembershipEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            IEnumerable<string> name = GetAvatarNames(groupMembershipEventArgs.AgentName);
                            if (name != null)
                            {
                                List<string> fullName = new List<string>(name);
                                if (fullName.Count.Equals(2))
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                        fullName.First());
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                        fullName.Last());
                                }
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT),
                                groupMembershipEventArgs.AgentUUID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                groupMembershipEventArgs.GroupName);
                            switch (groupMembershipEventArgs.Action)
                            {
                                case Action.JOINED:
                                case Action.PARTED:
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                        !groupMembershipEventArgs.Action.Equals(
                                            Action.JOINED)
                                            ? wasGetDescriptionFromEnumValue(Action.PARTED)
                                            : wasGetDescriptionFromEnumValue(Action.JOINED));
                                    break;
                            }
                        };
                        break;
                    case Notifications.LoadURL:
                        execute = () =>
                        {
                            LoadUrlEventArgs loadURLEventArgs = (LoadUrlEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(loadURLEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                loadURLEventArgs.ObjectName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                loadURLEventArgs.ObjectID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                loadURLEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.GROUP),
                                loadURLEventArgs.OwnerIsGroup.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                loadURLEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.URL),
                                loadURLEventArgs.URL);
                        };
                        break;
                    case Notifications.OwnerSay:
                        execute = () =>
                        {
                            ChatEventArgs ownerSayEventArgs = (ChatEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(ownerSayEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                ownerSayEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                ownerSayEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                ownerSayEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                ownerSayEventArgs.Position.ToString());
                        };
                        break;
                    case Notifications.RegionSayTo:
                        execute = () =>
                        {
                            ChatEventArgs regionSayToEventArgs = (ChatEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(regionSayToEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                regionSayToEventArgs.Message);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                regionSayToEventArgs.OwnerID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                regionSayToEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                regionSayToEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                regionSayToEventArgs.Position.ToString());
                        };
                        break;
                    case Notifications.ObjectInstantMessage:
                        execute = () =>
                        {
                            InstantMessageEventArgs notificationObjectInstantMessage =
                                (InstantMessageEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(notificationObjectInstantMessage,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                notificationObjectInstantMessage.IM.FromAgentID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                notificationObjectInstantMessage.IM.IMSessionID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                notificationObjectInstantMessage.IM.FromAgentName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                notificationObjectInstantMessage.IM.Message);
                        };
                        break;
                    case Notifications.RLVMessage:
                        execute = () =>
                        {
                            ChatEventArgs RLVEventArgs = (ChatEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(RLVEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                RLVEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                RLVEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                RLVEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.RLV),
                                wasEnumerableToCSV(wasRLVToString(RLVEventArgs.Message)));
                        };
                        break;
                    case Notifications.DebugMessage:
                        execute = () =>
                        {
                            ChatEventArgs DebugEventArgs = (ChatEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(DebugEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM),
                                DebugEventArgs.SourceID.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.NAME),
                                DebugEventArgs.FromName);
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                DebugEventArgs.Position.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE),
                                DebugEventArgs.Message);
                        };
                        break;
                    case Notifications.RadarAvatars:
                        execute = () =>
                        {
                            System.Type radarAvatarsType = args.GetType();
                            if (radarAvatarsType == typeof (AvatarUpdateEventArgs))
                            {
                                AvatarUpdateEventArgs avatarUpdateEventArgs =
                                    (AvatarUpdateEventArgs) args;
                                lock (RadarObjectsLock)
                                {
                                    if (RadarObjects.ContainsKey(avatarUpdateEventArgs.Avatar.ID)) return;
                                    RadarObjects.Add(avatarUpdateEventArgs.Avatar.ID, avatarUpdateEventArgs.Avatar);
                                }
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(avatarUpdateEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    avatarUpdateEventArgs.Avatar.FirstName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    avatarUpdateEventArgs.Avatar.LastName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    avatarUpdateEventArgs.Avatar.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    avatarUpdateEventArgs.Avatar.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    avatarUpdateEventArgs.Avatar.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    avatarUpdateEventArgs.Avatar.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.APPEAR));
                                return;
                            }
                            if (radarAvatarsType == typeof (KillObjectEventArgs))
                            {
                                KillObjectEventArgs killObjectEventArgs =
                                    (KillObjectEventArgs) args;
                                Avatar avatar;
                                lock (RadarObjectsLock)
                                {
                                    KeyValuePair<UUID, Primitive> tracked =
                                        RadarObjects.AsParallel().FirstOrDefault(
                                            p => p.Value.LocalID.Equals(killObjectEventArgs.ObjectLocalID));
                                    switch (!tracked.Equals(default(KeyValuePair<UUID, Primitive>)))
                                    {
                                        case true:
                                            RadarObjects.Remove(tracked.Key);
                                            break;
                                        default:
                                            return;
                                    }
                                    if (!(tracked.Value is Avatar)) return;
                                    avatar = tracked.Value as Avatar;
                                }
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(killObjectEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME),
                                    avatar.FirstName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME),
                                    avatar.LastName);
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    avatar.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    avatar.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    avatar.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    avatar.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.VANISH));
                            }
                        };
                        break;
                    case Notifications.RadarPrimitives:
                        execute = () =>
                        {
                            System.Type radarPrimitivesType = args.GetType();
                            if (radarPrimitivesType == typeof (PrimEventArgs))
                            {
                                PrimEventArgs primEventArgs =
                                    (PrimEventArgs) args;
                                lock (RadarObjectsLock)
                                {
                                    if (RadarObjects.ContainsKey(primEventArgs.Prim.ID)) return;
                                    RadarObjects.Add(primEventArgs.Prim.ID, primEventArgs.Prim);
                                }
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(primEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                    primEventArgs.Prim.OwnerID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    primEventArgs.Prim.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    primEventArgs.Prim.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    primEventArgs.Prim.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    primEventArgs.Prim.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.APPEAR));
                                return;
                            }
                            if (radarPrimitivesType == typeof (KillObjectEventArgs))
                            {
                                KillObjectEventArgs killObjectEventArgs =
                                    (KillObjectEventArgs) args;
                                Primitive prim;
                                lock (RadarObjectsLock)
                                {
                                    KeyValuePair<UUID, Primitive> tracked =
                                        RadarObjects.AsParallel().FirstOrDefault(
                                            p => p.Value.LocalID.Equals(killObjectEventArgs.ObjectLocalID));
                                    switch (!tracked.Equals(default(KeyValuePair<UUID, Primitive>)))
                                    {
                                        case true:
                                            RadarObjects.Remove(tracked.Key);
                                            prim = tracked.Value;
                                            break;
                                        default:
                                            return;
                                    }
                                }
                                // In case we should send specific data then query the structure and return.
                                if (z.Data != null && z.Data.Any())
                                {
                                    notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                        wasEnumerableToCSV(GetStructuredData(killObjectEventArgs,
                                            wasEnumerableToCSV(z.Data))));
                                    return;
                                }
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.OWNER),
                                    prim.OwnerID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ID),
                                    prim.ID.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION),
                                    prim.Position.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION),
                                    prim.Rotation.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY),
                                    prim.PrimData.PCode.ToString());
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION),
                                    wasGetDescriptionFromEnumValue(Action.VANISH));
                            }
                        };
                        break;
                    case Notifications.ScriptControl:
                        execute = () =>
                        {
                            ScriptControlEventArgs scriptControlEventArgs =
                                (ScriptControlEventArgs) args;
                            // In case we should send specific data then query the structure and return.
                            if (z.Data != null && z.Data.Any())
                            {
                                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    wasEnumerableToCSV(GetStructuredData(scriptControlEventArgs,
                                        wasEnumerableToCSV(z.Data))));
                                return;
                            }
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.CONTROLS),
                                wasEnumerableToCSV(typeof (ScriptControlChange).GetFields(BindingFlags.Public |
                                                                                          BindingFlags.Static)
                                    .AsParallel().Where(
                                        p =>
                                            !(((uint) p.GetValue(null) &
                                               (uint) scriptControlEventArgs.Controls)).Equals(0))
                                    .Select(p => p.Name)));
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.PASS),
                                scriptControlEventArgs.Pass.ToString());
                            notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TAKE),
                                scriptControlEventArgs.Take.ToString());
                        };
                        break;
                    default:
                        execute = () =>
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(ConsoleError.UNKNOWN_NOTIFICATION_TYPE));
                        };
                        break;
                }

                try
                {
                    execute.Invoke();
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_ERROR), ex.Message);
                    return;
                }

                // Do not send empty notifications.
                if (!notificationData.Any()) return;

                // Add the notification type.
                notificationData.Add(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE),
                    wasGetDescriptionFromEnumValue(notification));

                // Build the afterburn.
                if (z.Afterburn != null && z.Afterburn.Any())
                {
                    object LockObject = new object();
                    Parallel.ForEach(z.Afterburn, o =>
                    {
                        lock (LockObject)
                        {
                            notificationData.Add(o.Key, o.Value);
                        }
                    });
                }

                // Check that the notification queue is not already full.
                if (NotificationQueue.Count >= corradeConfiguration.NotificationQueueLength)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.NOTIFICATION_THROTTLED));
                    return;
                }

                // Enqueue the notification for the group.
                Parallel.ForEach(
                    z.NotificationDestination.AsParallel()
                        .Where(p => p.Key.Equals(notification))
                        .SelectMany(p => p.Value), p =>
                        {
                            NotificationQueue.Enqueue(new NotificationQueueElement
                            {
                                URL = p,
                                message = wasKeyValueEscape(notificationData)
                            });
                        });
            });
        }

        private static void HandleScriptDialog(object sender, ScriptDialogEventArgs e)
        {
            lock (ScriptDialogLock)
            {
                ScriptDialogs.Add(new ScriptDialog
                {
                    Message = e.Message,
                    Agent = new Agent
                    {
                        FirstName = e.FirstName,
                        LastName = e.LastName,
                        UUID = e.OwnerID
                    },
                    Channel = e.Channel,
                    Name = e.ObjectName,
                    Item = e.ObjectID,
                    Button = e.ButtonLabels
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.ScriptDialog, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleChatFromSimulator(object sender, ChatEventArgs e)
        {
            // Ignore chat with no message (ie: start / stop typing)
            if (string.IsNullOrEmpty(e.Message)) return;
            List<string> fullName = new List<string>(GetAvatarNames(e.FromName));
            switch (e.Type)
            {
                case ChatType.OwnerSay:
                    // If this is a message from an agent, add the agent to the cache.
                    if (e.SourceType.Equals(ChatSourceType.Agent))
                    {
                        Cache.AddAgent(fullName.First(), fullName.Last(), e.SourceID);
                    }
                    // If RLV is enabled, process RLV and terminate.
                    if (corradeConfiguration.EnableRLV && e.Message.StartsWith(RLV_CONSTANTS.COMMAND_OPERATOR))
                    {
                        // Send RLV message notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.RLVMessage, e),
                            corradeConfiguration.MaximumNotificationThreads);
                        CorradeThreadPool[CorradeThreadType.RLV].Spawn(
                            () => HandleRLVBehaviour(e.Message.Substring(1, e.Message.Length - 1), e.SourceID),
                            corradeConfiguration.MaximumRLVThreads);
                        break;
                    }
                    // Otherwise, send llOwnerSay notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.OwnerSay, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                case ChatType.Debug:
                    // Send debug notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.DebugMessage, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    break;
                case ChatType.Normal:
                case ChatType.Shout:
                case ChatType.Whisper:
                    // If this is a message from an agent, add the agent to the cache.
                    if (e.SourceType.Equals(ChatSourceType.Agent))
                    {
                        Cache.AddAgent(fullName.First(), fullName.Last(), e.SourceID);
                    }
                    // Send chat notifications.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.LocalChat, e),
                        corradeConfiguration.MaximumNotificationThreads);
                    // Log local chat,
                    if (corradeConfiguration.LocalMessageLogEnabled)
                    {
                        CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                        {
                            try
                            {
                                lock (LocalLogFileLock)
                                {
                                    using (
                                        StreamWriter logWriter =
                                            new StreamWriter(
                                                wasPathCombine(corradeConfiguration.LocalMessageLogDirectory,
                                                    Client.Network.CurrentSim.Name) +
                                                "." +
                                                CORRADE_CONSTANTS.LOG_FILE_EXTENSION, true, Encoding.UTF8))
                                    {
                                        logWriter.WriteLine("[{0}] {1} {2} ({3}) : {4}",
                                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                            fullName.First(), fullName.Last(),
                                            Enum.GetName(typeof (ChatType), e.Type),
                                            e.Message);
                                        //logWriter.Flush();
                                        //logWriter.Close();
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                // or fail and append the fail message.
                                Feedback(
                                    wasGetDescriptionFromEnumValue(
                                        ConsoleError.COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE),
                                    ex.Message);
                            }
                        }, corradeConfiguration.MaximumLogThreads);
                    }
                    break;
                case (ChatType) 9:
                    // Send llRegionSayTo notification in case we do not have a command.
                    if (!IsCorradeCommand(e.Message))
                    {
                        // Send chat notifications.
                        CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                            () => SendNotification(Notifications.RegionSayTo, e),
                            corradeConfiguration.MaximumNotificationThreads);
                        break;
                    }
                    // If the group was not set properly, then bail.
                    Group commandGroup = GetCorradeGroupFromMessage(e.Message);
                    switch (!commandGroup.Equals(default(Group)))
                    {
                        case false:
                            return;
                    }
                    // Spawn the command.
                    CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                        () => HandleCorradeCommand(e.Message, e.FromName, e.OwnerID.ToString(), commandGroup),
                        corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                        corradeConfiguration.SchedulerExpiration);
                    break;
            }
        }

        private static void HandleAlertMessage(object sender, AlertMessageEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.AlertMessage, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleInventoryObjectOffered(object sender, InventoryObjectOfferedEventArgs e)
        {
            // Send notification
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Inventory, e),
                corradeConfiguration.MaximumNotificationThreads);

            // Accept anything from master avatars.
            if (
                corradeConfiguration.Masters.AsParallel().Select(
                    o => string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0} {1}", o.FirstName, o.LastName))
                    .Any(p => p.Equals(e.Offer.FromAgentName, StringComparison.OrdinalIgnoreCase)))
            {
                e.Accept = true;
                return;
            }

            // We need to block until we get a reply from a script.
            ManualResetEvent wait = new ManualResetEvent(false);
            // Add the inventory offer to the list of inventory items.
            lock (InventoryOffersLock)
            {
                InventoryOffers.Add(e, wait);
            }

            UpdateInventoryRecursive.Invoke(
                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                    InventoryFolder);

            // Find the item in the inventory.
            InventoryBase inventoryBaseItem;
            lock (ClientInstanceInventoryLock)
            {
                inventoryBaseItem = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, ((Func<string>) (() =>
                {
                    GroupCollection groups =
                        CORRADE_CONSTANTS.InventoryOfferObjectNameRegEx.Match(e.Offer.Message).Groups;
                    return groups.Count > 0 ? groups[1].Value : e.Offer.Message;
                }))()
                    ).FirstOrDefault();
            }

            if (inventoryBaseItem != null)
            {
                // Assume we do not want the item.
                lock (ClientInstanceInventoryLock)
                {
                    Client.Inventory.Move(
                        inventoryBaseItem,
                        Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(AssetType.TrashFolder)].Data as
                            InventoryFolder);
                }
            }

            // Wait for a reply.
            wait.WaitOne(Timeout.Infinite);

            if (!e.Accept) return;

            // If no folder UUID was specified, move it to the default folder for the asset type.
            if (inventoryBaseItem != null)
            {
                switch (!e.FolderID.Equals(UUID.Zero))
                {
                    case true:
                        InventoryBase inventoryBaseFolder;
                        lock (ClientInstanceInventoryLock)
                        {
                            // Locate the folder and move.
                            inventoryBaseFolder =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, e.FolderID
                                    ).FirstOrDefault();
                            if (inventoryBaseFolder != null)
                            {
                                Client.Inventory.Move(inventoryBaseItem, inventoryBaseFolder as InventoryFolder);
                            }
                        }
                        if (inventoryBaseFolder != null)
                        {
                            UpdateInventoryRecursive.Invoke(inventoryBaseFolder as InventoryFolder);
                        }
                        break;
                    default:
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.Move(
                                inventoryBaseItem,
                                Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                                    InventoryFolder);
                        }
                        UpdateInventoryRecursive.Invoke(
                            Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(e.AssetType)].Data as
                                InventoryFolder);
                        break;
                }
            }
        }

        private static void HandleScriptQuestion(object sender, ScriptQuestionEventArgs e)
        {
            List<string> owner = new List<string>(GetAvatarNames(e.ObjectOwnerName));
            UUID ownerUUID = UUID.Zero;
            // Don't add permission requests from unknown agents.
            if (
                !AgentNameToUUID(owner.First(), owner.Last(), corradeConfiguration.ServicesTimeout,
                    corradeConfiguration.DataTimeout,
                    ref ownerUUID))
            {
                return;
            }

            lock (ScriptPermissionRequestLock)
            {
                ScriptPermissionRequests.Add(new ScriptPermissionRequest
                {
                    Name = e.ObjectName,
                    Agent = new Agent
                    {
                        FirstName = owner.First(),
                        LastName = owner.Last(),
                        UUID = ownerUUID
                    },
                    Item = e.ItemID,
                    Task = e.TaskID,
                    Permission = e.Questions,
                    Region = e.Simulator.Name
                });
            }
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.ScriptPermission, e),
                corradeConfiguration.MaximumNotificationThreads);

            // Handle RLV: acceptpermission
            lock (RLVRulesLock)
            {
                if (
                    !RLVRules.AsParallel()
                        .Any(o => o.Behaviour.Equals(wasGetDescriptionFromEnumValue(RLVBehaviour.ACCEPTPERMISSION))))
                    return;
                lock (ClientInstanceSelfLock)
                {
                    Client.Self.ScriptQuestionReply(e.Simulator, e.ItemID, e.TaskID, e.Questions);
                }
            }
        }

        private static void HandleDisconnected(object sender, DisconnectedEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.DISCONNECTED));
            ConnectionSemaphores['l'].Set();
        }

        private static void HandleEventQueueRunning(object sender, EventQueueRunningEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.EVENT_QUEUE_STARTED));
        }

        private static void HandleSimulatorConnected(object sender, SimConnectedEventArgs e)
        {
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.SIMULATOR_CONNECTED));
        }

        private static void HandleSimulatorDisconnected(object sender, SimDisconnectedEventArgs e)
        {
            // if any simulators are still connected, we are not disconnected
            if (Client.Network.Simulators.Any()) return;
            Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ALL_SIMULATORS_DISCONNECTED));
            ConnectionSemaphores['s'].Set();
        }

        private static void HandleLoginProgress(object sender, LoginProgressEventArgs e)
        {
            switch (e.Status)
            {
                case LoginStatus.Success:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGIN_SUCCEEDED));
                    // Start inventory update thread.
                    ManualResetEvent InventoryLoadedEvent = new ManualResetEvent(false);
                    new Thread(() =>
                    {
                        lock (ClientInstanceInventoryLock)
                        {
                            // First load the caches.
                            LoadInventoryCache.Invoke();
                        }
                        // Update the inventory.
                        UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                        lock (ClientInstanceInventoryLock)
                        {
                            // Now save the caches.
                            SaveInventoryCache.Invoke();
                        }
                        // Signal completion.
                        InventoryLoadedEvent.Set();
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Set current group to land group.
                    new Thread(() =>
                    {
                        if (!corradeConfiguration.AutoActivateGroup) return;
                        ActivateCurrentLandGroupTimer.Change(corradeConfiguration.ActivateDelay, 0);
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Retrieve instant messages.
                    new Thread(() =>
                    {
                        // Wait till the inventory has loaded to retrieve messages since 
                        // instant messages may contain commands that must be replayed.
                        InventoryLoadedEvent.WaitOne(Timeout.Infinite, false);
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.RetrieveInstantMessages();
                        }
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Set the camera on the avatar.
                    Client.Self.Movement.Camera.LookAt(
                        Client.Self.SimPosition,
                        Client.Self.SimPosition
                        );
                    break;
                case LoginStatus.Failed:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.LOGIN_FAILED), e.FailReason);
                    ConnectionSemaphores['l'].Set();
                    break;
            }
        }

        private static void HandleFriendOnlineStatus(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendRightsUpdate(object sender, FriendInfoEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendShipResponse(object sender, FriendshipResponseEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleFriendshipOffered(object sender, FriendshipOfferedEventArgs e)
        {
            // Send friendship notifications
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Friendship, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleTeleportProgress(object sender, TeleportEventArgs e)
        {
            switch (e.Status)
            {
                case TeleportStatus.Finished:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_SUCCEEDED));
                    // Set current group to land group.
                    new Thread(() =>
                    {
                        if (!corradeConfiguration.AutoActivateGroup) return;
                        ActivateCurrentLandGroupTimer.Change(corradeConfiguration.ActivateDelay, 0);
                    })
                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                    // Set the camera on the avatar.
                    Client.Self.Movement.Camera.LookAt(
                        Client.Self.SimPosition,
                        Client.Self.SimPosition
                        );
                    break;
                case TeleportStatus.Failed:
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_FAILED));
                    break;
            }
        }

        private static void HandleSelfIM(object sender, InstantMessageEventArgs args)
        {
            // ignore stuff from muted entities
            IEnumerable<MuteEntry> mutes = Enumerable.Empty<MuteEntry>();
            if (!GetMutes(corradeConfiguration.ServicesTimeout, ref mutes))
                return;
            if (
                mutes.ToList()
                    .AsParallel()
                    .Any(
                        o =>
                            args.IM.FromAgentID.Equals(o.ID) && args.IM.FromAgentName.Equals(o.Name) &&
                            (o.Flags.Equals(MuteFlags.Default) || o.Flags.Equals(MuteFlags.TextChat))))
                return;
            List<string> fullName =
                new List<string>(
                    GetAvatarNames(args.IM.FromAgentName));
            // Process dialog messages.
            switch (args.IM.Dialog)
            {
                // Send typing notification.
                case InstantMessageDialog.StartTyping:
                case InstantMessageDialog.StopTyping:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.Typing, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.FriendshipOffered:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    // Accept friendships only from masters (for the time being)
                    if (
                        !corradeConfiguration.Masters.AsParallel().Any(
                            o =>
                                o.FirstName.Equals(fullName.First(), StringComparison.OrdinalIgnoreCase) &&
                                o.LastName.Equals(fullName.Last(), StringComparison.OrdinalIgnoreCase)))
                        return;
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ACCEPTED_FRIENDSHIP), args.IM.FromAgentName);
                    Client.Friends.AcceptFriendship(args.IM.FromAgentID, args.IM.IMSessionID);
                    break;
                case InstantMessageDialog.InventoryAccepted:
                case InstantMessageDialog.InventoryDeclined:
                case InstantMessageDialog.TaskInventoryOffered:
                case InstantMessageDialog.InventoryOffered:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.Inventory, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.MessageBox:
                    // Not used.
                    return;
                case InstantMessageDialog.RequestTeleport:
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    // Handle RLV: acccepttp
                    lock (RLVRulesLock)
                    {
                        if (
                            RLVRules.AsParallel()
                                .Any(o => o.Behaviour.Equals(wasGetDescriptionFromEnumValue(RLVBehaviour.ACCEPTTP))))
                        {
                            if (IsSecondLife() && !TimedTeleportThrottle.IsSafe)
                            {
                                // or fail and append the fail message.
                                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_THROTTLED));
                                return;
                            }
                            lock (ClientInstanceSelfLock)
                            {
                                Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                            }
                            return;
                        }
                    }
                    // Store teleport lure.
                    lock (TeleportLureLock)
                    {
                        TeleportLures.Add(new TeleportLure
                        {
                            Agent = new Agent
                            {
                                FirstName = fullName.First(),
                                LastName = fullName.Last(),
                                UUID = args.IM.FromAgentID
                            },
                            Session = args.IM.IMSessionID
                        });
                    }
                    // Send teleport lure notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.TeleportLure, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    // If we got a teleport request from a master, then accept it (for the moment).
                    lock (ClientInstanceConfigurationLock)
                    {
                        if (
                            !corradeConfiguration.Masters.AsParallel()
                                .Any(
                                    o =>
                                        o.FirstName.Equals(fullName.First(), StringComparison.OrdinalIgnoreCase) &&
                                        o.LastName.Equals(fullName.Last(), StringComparison.OrdinalIgnoreCase)))
                            return;
                    }
                    if (IsSecondLife() && !TimedTeleportThrottle.IsSafe)
                    {
                        // or fail and append the fail message.
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.TELEPORT_THROTTLED));
                        return;
                    }
                    lock (ClientInstanceSelfLock)
                    {
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        Client.Self.TeleportLureRespond(args.IM.FromAgentID, args.IM.IMSessionID, true);
                    }
                    return;
                // Group invitations received
                case InstantMessageDialog.GroupInvitation:
                    OpenMetaverse.Group inviteGroup = new OpenMetaverse.Group();
                    if (!RequestGroup(args.IM.FromAgentID, corradeConfiguration.ServicesTimeout, ref inviteGroup))
                        return;
                    // Add the group to the cache.
                    Cache.AddGroup(inviteGroup.Name, inviteGroup.ID);
                    UUID inviteGroupAgent = UUID.Zero;
                    if (
                        !AgentNameToUUID(fullName.First(), fullName.Last(),
                            corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout,
                            ref inviteGroupAgent))
                        return;
                    // Add the agent to the cache.
                    Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                    // Add the group invite - have to track them manually.
                    lock (GroupInviteLock)
                    {
                        GroupInvites.Add(new GroupInvite
                        {
                            Agent = new Agent
                            {
                                FirstName = fullName.First(),
                                LastName = fullName.Last(),
                                UUID = inviteGroupAgent
                            },
                            Group = inviteGroup.Name,
                            Session = args.IM.IMSessionID,
                            Fee = inviteGroup.MembershipFee
                        });
                    }
                    // Send group invitation notification.
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.GroupInvite, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    // If a master sends it, then accept.
                    lock (ClientInstanceConfigurationLock)
                    {
                        if (
                            !corradeConfiguration.Masters.AsParallel()
                                .Any(
                                    o =>
                                        o.FirstName.Equals(fullName.First(), StringComparison.OrdinalIgnoreCase) &&
                                        o.LastName.Equals(fullName.Last(), StringComparison.OrdinalIgnoreCase)))
                            return;
                    }
                    Client.Self.GroupInviteRespond(inviteGroup.ID, args.IM.IMSessionID, true);
                    return;
                // Group notice inventory accepted, declined or notice received.
                case InstantMessageDialog.GroupNoticeInventoryAccepted:
                case InstantMessageDialog.GroupNoticeInventoryDeclined:
                case InstantMessageDialog.GroupNotice:
                    CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                        () => SendNotification(Notifications.GroupNotice, args),
                        corradeConfiguration.MaximumNotificationThreads);
                    return;
                case InstantMessageDialog.SessionSend:
                case InstantMessageDialog.MessageFromAgent:
                    // Check if this is a group message.
                    // Note that this is a lousy way of doing it but libomv does not properly set the GroupIM field
                    // such that the only way to determine if we have a group message is to check that the UUID
                    // of the session is actually the UUID of a current group. Furthermore, what's worse is that 
                    // group mesages can appear both through SessionSend and from MessageFromAgent. Hence the problem.
                    IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                    if (
                        !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                            ref currentGroups))
                        return;

                    if (currentGroups.AsParallel().Any(o => o.Equals(args.IM.IMSessionID)))
                    {
                        Group messageGroup =
                            corradeConfiguration.Groups.AsParallel()
                                .FirstOrDefault(p => p.UUID.Equals(args.IM.IMSessionID));
                        if (!messageGroup.Equals(default(Group)))
                        {
                            // Add the group to the cache.
                            Cache.AddGroup(messageGroup.Name, messageGroup.UUID);
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            // Send group notice notifications.
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () =>
                                    SendNotification(Notifications.GroupMessage, new GroupMessageEventArgs
                                    {
                                        AgentUUID = args.IM.FromAgentID,
                                        FirstName = fullName.First(),
                                        LastName = fullName.Last(),
                                        GroupName = messageGroup.Name,
                                        GroupUUID = messageGroup.UUID,
                                        Message = args.IM.Message
                                    }),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Log group messages
                            Parallel.ForEach(
                                corradeConfiguration.Groups.AsParallel().Where(
                                    o =>
                                        o.Name.Equals(messageGroup.Name, StringComparison.OrdinalIgnoreCase) &&
                                        o.ChatLogEnabled),
                                o =>
                                {
                                    // Attempt to write to log file,
                                    CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                    {
                                        try
                                        {
                                            lock (GroupLogFileLock)
                                            {
                                                using (
                                                    StreamWriter logWriter = new StreamWriter(o.ChatLog, true,
                                                        Encoding.UTF8)
                                                    )
                                                {
                                                    logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                        fullName.First(),
                                                        fullName.Last(),
                                                        args.IM.Message);
                                                    //logWriter.Flush();
                                                    //logWriter.Close();
                                                }
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            // or fail and append the fail message.
                                            Feedback(
                                                wasGetDescriptionFromEnumValue(
                                                    ConsoleError.COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE),
                                                ex.Message);
                                        }
                                    }, corradeConfiguration.MaximumLogThreads);
                                });
                        }
                        return;
                    }
                    // Check if this is an instant message.
                    switch (!args.IM.ToAgentID.Equals(Client.Self.AgentID))
                    {
                        case false:
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Notifications.InstantMessage, args),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Check if we were ejected.
                            UUID groupUUID = UUID.Zero;
                            if (
                                GroupNameToUUID(
                                    CORRADE_CONSTANTS.EjectedFromGroupRegEx.Match(args.IM.Message).Groups[1].Value,
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref groupUUID))
                            {
                                // Remove the group from the cache.
                                lock (Cache.Locks.CurrentGroupsCacheLock)
                                {
                                    Cache.CurrentGroupsCache.Remove(groupUUID);
                                }
                            }

                            // Log instant messages,
                            if (corradeConfiguration.InstantMessageLogEnabled)
                            {
                                CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                {
                                    try
                                    {
                                        lock (InstantMessageLogFileLock)
                                        {
                                            using (
                                                StreamWriter logWriter =
                                                    new StreamWriter(
                                                        wasPathCombine(corradeConfiguration.InstantMessageLogDirectory,
                                                            args.IM.FromAgentName) +
                                                        "." + CORRADE_CONSTANTS.LOG_FILE_EXTENSION, true, Encoding.UTF8)
                                                )
                                            {
                                                logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                        CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                    fullName.First(),
                                                    fullName.Last(),
                                                    args.IM.Message);
                                                //logWriter.Flush();
                                                //logWriter.Close();
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            wasGetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }, corradeConfiguration.MaximumLogThreads);
                            }
                            return;
                    }
                    // Check if this is a region message.
                    switch (!args.IM.IMSessionID.Equals(UUID.Zero))
                    {
                        case false:
                            // Add the agent to the cache.
                            Cache.AddAgent(fullName.First(), fullName.Last(), args.IM.FromAgentID);
                            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                                () => SendNotification(Notifications.RegionMessage, args),
                                corradeConfiguration.MaximumNotificationThreads);
                            // Log region messages,
                            if (corradeConfiguration.RegionMessageLogEnabled)
                            {
                                CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                {
                                    try
                                    {
                                        lock (RegionLogFileLock)
                                        {
                                            using (
                                                StreamWriter logWriter =
                                                    new StreamWriter(
                                                        wasPathCombine(corradeConfiguration.RegionMessageLogDirectory,
                                                            Client.Network.CurrentSim.Name) + "." +
                                                        CORRADE_CONSTANTS.LOG_FILE_EXTENSION, true, Encoding.UTF8))
                                            {
                                                logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                    DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                        CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                    fullName.First(),
                                                    fullName.Last(),
                                                    args.IM.Message);
                                                //logWriter.Flush();
                                                //logWriter.Close();
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        // or fail and append the fail message.
                                        Feedback(
                                            wasGetDescriptionFromEnumValue(
                                                ConsoleError.COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE),
                                            ex.Message);
                                    }
                                }, corradeConfiguration.MaximumLogThreads);
                            }
                            return;
                    }
                    break;
            }

            // We are now in a region of code where the message is an IM sent by an object.
            // Check if this is not a Corrade command and send an object IM notification.
            if (!IsCorradeCommand(args.IM.Message))
            {
                CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                    () => SendNotification(Notifications.ObjectInstantMessage, args),
                    corradeConfiguration.MaximumNotificationThreads);
                return;
            }

            // If the group was not set properly, then bail.
            Group commandGroup = GetCorradeGroupFromMessage(args.IM.Message);
            switch (!commandGroup.Equals(default(Group)))
            {
                case false:
                    return;
            }
            // Otherwise process the command.
            CorradeThreadPool[CorradeThreadType.COMMAND].Spawn(
                () =>
                    HandleCorradeCommand(args.IM.Message, args.IM.FromAgentName, args.IM.FromAgentID.ToString(),
                        commandGroup),
                corradeConfiguration.MaximumCommandThreads, commandGroup.UUID,
                corradeConfiguration.SchedulerExpiration);
        }

        /// <summary>
        ///     Processes a RLV behaviour.
        /// </summary>
        /// <param name="message">the RLV message to process</param>
        /// <param name="senderUUID">the UUID of the sender</param>
        private static void HandleRLVBehaviour(string message, UUID senderUUID)
        {
            if (string.IsNullOrEmpty(message)) return;

            // Split all commands.
            string[] unpack = message.Split(RLV_CONSTANTS.CSV_DELIMITER[0]);
            // Pop first command to process.
            string first = unpack.First();
            // Remove command.
            unpack = unpack.AsParallel().Where(o => !o.Equals(first)).ToArray();
            // Keep rest of message.
            message = string.Join(RLV_CONSTANTS.CSV_DELIMITER, unpack);

            Match match = RLV_CONSTANTS.RLVRegEx.Match(first);
            if (!match.Success) goto CONTINUE;

            RLVRule RLVrule = new RLVRule
            {
                Behaviour = match.Groups["behaviour"].ToString().ToLowerInvariant(),
                Option = match.Groups["option"].ToString().ToLowerInvariant(),
                Param = match.Groups["param"].ToString().ToLowerInvariant(),
                ObjectUUID = senderUUID
            };

            switch (RLVrule.Param)
            {
                case RLV_CONSTANTS.Y:
                case RLV_CONSTANTS.ADD:
                    if (string.IsNullOrEmpty(RLVrule.Option))
                    {
                        lock (RLVRulesLock)
                        {
                            RLVRules.RemoveWhere(
                                o =>
                                    o.Behaviour.Equals(
                                        RLVrule.Behaviour,
                                        StringComparison.InvariantCultureIgnoreCase) &&
                                    o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        }
                        goto CONTINUE;
                    }
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.InvariantCultureIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID) &&
                                o.Option.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                    }
                    goto CONTINUE;
                case RLV_CONSTANTS.N:
                case RLV_CONSTANTS.REM:
                    lock (RLVRulesLock)
                    {
                        RLVRules.RemoveWhere(
                            o =>
                                o.Behaviour.Equals(
                                    RLVrule.Behaviour,
                                    StringComparison.InvariantCultureIgnoreCase) &&
                                o.Option.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase) &&
                                o.ObjectUUID.Equals(RLVrule.ObjectUUID));
                        RLVRules.Add(RLVrule);
                    }
                    goto CONTINUE;
            }

            System.Action execute;

            switch (wasGetEnumValueFromDescription<RLVBehaviour>(RLVrule.Behaviour))
            {
                case RLVBehaviour.VERSION:
                case RLVBehaviour.VERSIONNEW:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Client.Self.Chat(
                            string.Format("{0} v{1} (Corrade Version: {2} Compiled: {3})", RLV_CONSTANTS.VIEWER,
                                RLV_CONSTANTS.SHORT_VERSION, CORRADE_CONSTANTS.CORRADE_VERSION,
                                CORRADE_CONSTANTS.CORRADE_COMPILE_DATE), channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.VERSIONNUM:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Client.Self.Chat(RLV_CONSTANTS.LONG_VERSION, channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETGROUP:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        UUID groupUUID = Client.Self.ActiveGroup;
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                            return;
                        string groupName = string.Empty;
                        if (
                            !GroupUUIDToName(currentGroups.AsParallel().FirstOrDefault(o => o.Equals(groupUUID)),
                                corradeConfiguration.ServicesTimeout, ref groupName))
                        {
                            return;
                        }
                        Client.Self.Chat(groupName, channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.SETGROUP:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        UUID groupUUID;
                        if (!UUID.TryParse(RLVrule.Option, out groupUUID))
                        {
                            return;
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                            return;
                        UUID currentGroup =
                            currentGroups.ToList().FirstOrDefault(o => o.Equals(groupUUID));
                        if (!currentGroup.Equals(UUID.Zero))
                        {
                            Client.Groups.ActivateGroup(groupUUID);
                        }
                    };
                    break;
                case RLVBehaviour.GETSITID:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        Avatar me;
                        if (Client.Network.CurrentSim.ObjectsAvatars.TryGetValue(Client.Self.LocalID, out me))
                        {
                            if (me.ParentID != 0)
                            {
                                Primitive sit;
                                if (Client.Network.CurrentSim.ObjectsPrimitives.TryGetValue(me.ParentID, out sit))
                                {
                                    Client.Self.Chat(sit.ID.ToString(), channel, ChatType.Normal);
                                    return;
                                }
                            }
                        }
                        UUID zero = UUID.Zero;
                        Client.Self.Chat(zero.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.SIT:
                    execute = () =>
                    {
                        UUID sitTarget;
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) || !UUID.TryParse(RLVrule.Option, out sitTarget) ||
                            sitTarget.Equals(UUID.Zero))
                        {
                            return;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(sitTarget,
                                LINDEN_CONSTANTS.LSL.SENSOR_RANGE,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            return;
                        }
                        ManualResetEvent SitEvent = new ManualResetEvent(false);
                        EventHandler<AvatarSitResponseEventArgs> AvatarSitEventHandler =
                            (sender, args) =>
                                SitEvent.Set();
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) => SitEvent.Set();
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AvatarSitResponse += AvatarSitEventHandler;
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.RequestSit(primitive.ID, Vector3.Zero);
                            SitEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false);
                            Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case RLVBehaviour.UNSIT:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                    };
                    break;
                case RLVBehaviour.SETROT:
                    execute = () =>
                    {
                        double rotation;
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) ||
                            !double.TryParse(RLVrule.Option, NumberStyles.Float, CultureInfo.DefaultThreadCurrentCulture,
                                out rotation))
                        {
                            return;
                        }
                        Client.Self.Movement.UpdateFromHeading(Math.PI/2d - rotation, true);
                    };
                    break;
                case RLVBehaviour.TPTO:
                    execute = () =>
                    {
                        string[] coordinates = RLVrule.Option.Split('/');
                        if (!coordinates.Length.Equals(3))
                        {
                            return;
                        }
                        float globalX;
                        if (!float.TryParse(coordinates[0], out globalX))
                        {
                            return;
                        }
                        float globalY;
                        if (!float.TryParse(coordinates[1], out globalY))
                        {
                            return;
                        }
                        float altitude;
                        if (!float.TryParse(coordinates[2], out altitude))
                        {
                            return;
                        }
                        float localX, localY;
                        ulong handle = Helpers.GlobalPosToRegionHandle(globalX, globalY, out localX, out localY);
                        Client.Self.RequestTeleport(handle, new Vector3(localX, localY, altitude));
                    };
                    break;
                case RLVBehaviour.GETOUTFIT:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        HashSet<KeyValuePair<AppearanceManager.WearableData, WearableType>> wearables =
                            new HashSet<KeyValuePair<AppearanceManager.WearableData, WearableType>>(
                                GetWearables(Client.Inventory.Store.RootNode));
                        StringBuilder response = new StringBuilder();
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVWearable RLVwearable = RLVWearables.AsParallel()
                                    .FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                switch (!RLVwearable.Equals(default(RLVWearable)))
                                {
                                    case true:
                                        if (wearables.AsParallel().Any(o => o.Value.Equals(RLVwearable.WearableType)))
                                        {
                                            response.Append(RLV_CONSTANTS.TRUE_MARKER);
                                            break;
                                        }
                                        goto default;
                                    default:
                                        response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                        break;
                                }
                                break;
                            default:
                                string[] data = new string[RLVWearables.Count];
                                Parallel.ForEach(Enumerable.Range(0, RLVWearables.Count), o =>
                                {
                                    if (!wearables.AsParallel().Any(p => p.Value.Equals(RLVWearables[o].WearableType)))
                                    {
                                        data[o] = RLV_CONSTANTS.FALSE_MARKER;
                                        return;
                                    }
                                    data[o] = RLV_CONSTANTS.TRUE_MARKER;
                                });
                                response.Append(string.Join("", data.ToArray()));
                                break;
                        }
                        Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETATTACH:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        HashSet<Primitive> attachments = new HashSet<Primitive>(
                            GetAttachments(corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                                .AsParallel()
                                .Select(o => o.Key));
                        StringBuilder response = new StringBuilder();
                        if (!attachments.Any())
                        {
                            Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                            return;
                        }
                        HashSet<AttachmentPoint> attachmentPoints =
                            new HashSet<AttachmentPoint>(attachments.AsParallel()
                                .Select(o => o.PrimData.AttachmentPoint));
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVAttachment RLVattachment = RLVAttachments.AsParallel().FirstOrDefault(
                                    o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                switch (!RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    case true:
                                        if (!attachmentPoints.Contains(RLVattachment.AttachmentPoint))
                                            goto default;
                                        response.Append(RLV_CONSTANTS.TRUE_MARKER);
                                        break;
                                    default:
                                        response.Append(RLV_CONSTANTS.FALSE_MARKER);
                                        break;
                                }
                                break;
                            default:
                                string[] data = new string[RLVAttachments.Count];
                                Parallel.ForEach(Enumerable.Range(0, RLVAttachments.Count), o =>
                                {
                                    if (!attachmentPoints.Contains(RLVAttachments[o].AttachmentPoint))
                                    {
                                        data[o] = RLV_CONSTANTS.FALSE_MARKER;
                                        return;
                                    }
                                    data[o] = RLV_CONSTANTS.TRUE_MARKER;
                                });
                                response.Append(string.Join("", data.ToArray()));
                                break;
                        }
                        Client.Self.Chat(response.ToString(), channel, ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.DETACHME:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        KeyValuePair<Primitive, AttachmentPoint> attachment =
                            GetAttachments(corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                                .AsParallel().FirstOrDefault(o => o.Key.ID.Equals(senderUUID));
                        switch (!attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                        {
                            case true:
                                InventoryBase inventoryBase =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                        attachment.Key.Properties.ItemID
                                        )
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                (p is InventoryItem) &&
                                                ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                if (inventoryBase is InventoryAttachment || inventoryBase is InventoryObject)
                                {
                                    Detach(inventoryBase as InventoryItem);
                                }
                                RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                                break;
                            default:
                                return;
                        }
                    };
                    break;
                case RLVBehaviour.REMATTACH:
                case RLVBehaviour.DETACH:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            return;
                        }
                        InventoryBase inventoryBase;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                RLVAttachment RLVattachment =
                                    RLVAttachments.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                switch (!RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    case true: // detach by attachment point
                                        Parallel.ForEach(
                                            GetAttachments(corradeConfiguration.ServicesTimeout,
                                                corradeConfiguration.DataTimeout)
                                                .AsParallel().Where(o => o.Value.Equals(RLVattachment.AttachmentPoint)),
                                            o =>
                                            {
                                                inventoryBase =
                                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                                        o.Key.Properties.Name
                                                        )
                                                        .AsParallel().FirstOrDefault(
                                                            p =>
                                                                (p is InventoryItem) &&
                                                                ((InventoryItem) p).AssetType.Equals(
                                                                    AssetType.Object));
                                                if (inventoryBase is InventoryAttachment ||
                                                    inventoryBase is InventoryObject)
                                                {
                                                    Detach(inventoryBase as InventoryItem);
                                                }
                                            });
                                        break;
                                    default: // detach by folder(s) name
                                        Parallel.ForEach(
                                            RLVrule.Option.Split(RLV_CONSTANTS.PATH_SEPARATOR[0])
                                                .AsParallel().Select(
                                                    folder =>
                                                        FindInventory<InventoryBase>(RLVFolder,
                                                            new Regex(Regex.Escape(folder),
                                                                RegexOptions.Compiled | RegexOptions.IgnoreCase)
                                                            ).AsParallel().FirstOrDefault(o => (o is InventoryFolder))),
                                            o =>
                                            {
                                                if (o != null)
                                                {
                                                    Client.Inventory.Store.GetContents(
                                                        o as InventoryFolder).FindAll(CanBeWorn)
                                                        .ForEach(
                                                            p =>
                                                            {
                                                                if (p is InventoryWearable)
                                                                {
                                                                    UnWear(p as InventoryItem);
                                                                    return;
                                                                }
                                                                if (p is InventoryAttachment ||
                                                                    p is InventoryObject)
                                                                {
                                                                    // Multiple attachment points not working in libOpenMetaverse, so just replace.
                                                                    Detach(p as InventoryItem);
                                                                }
                                                            });
                                                }
                                            });
                                        break;
                                }
                                break;
                            default: //detach everything from RLV attachmentpoints
                                Parallel.ForEach(
                                    GetAttachments(corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout)
                                        .AsParallel()
                                        .Where(o => RLVAttachments.Any(p => p.AttachmentPoint.Equals(o.Value))), o =>
                                        {
                                            inventoryBase = FindInventory<InventoryBase>(
                                                Client.Inventory.Store.RootNode, o.Key.Properties.Name
                                                )
                                                .AsParallel().FirstOrDefault(
                                                    p =>
                                                        p is InventoryItem &&
                                                        ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                            if (inventoryBase is InventoryAttachment || inventoryBase is InventoryObject)
                                            {
                                                Detach(inventoryBase as InventoryItem);
                                            }
                                        });
                                break;
                        }
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case RLVBehaviour.ATTACH:
                case RLVBehaviour.ATTACHOVERORREPLACE:
                case RLVBehaviour.ATTACHOVER:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE) || string.IsNullOrEmpty(RLVrule.Option))
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            return;
                        }
                        Parallel.ForEach(
                            RLVrule.Option.Split(RLV_CONSTANTS.PATH_SEPARATOR[0])
                                .AsParallel().Select(
                                    folder =>
                                        FindInventory<InventoryBase>(RLVFolder,
                                            new Regex(Regex.Escape(folder),
                                                RegexOptions.Compiled | RegexOptions.IgnoreCase)
                                            ).AsParallel().FirstOrDefault(o => (o is InventoryFolder))), o =>
                                            {
                                                if (o != null)
                                                {
                                                    Client.Inventory.Store.GetContents(o as InventoryFolder).
                                                        FindAll(CanBeWorn)
                                                        .ForEach(
                                                            p =>
                                                            {
                                                                if (p is InventoryWearable)
                                                                {
                                                                    Wear(p as InventoryItem, true);
                                                                    return;
                                                                }
                                                                if (p is InventoryObject || p is InventoryAttachment)
                                                                {
                                                                    // Multiple attachment points not working in libOpenMetaverse, so just replace.
                                                                    Attach(p as InventoryItem,
                                                                        AttachmentPoint.Default,
                                                                        true);
                                                                }
                                                            });
                                                }
                                            });
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case RLVBehaviour.REMOUTFIT:
                    execute = () =>
                    {
                        if (!RLVrule.Param.Equals(RLV_CONSTANTS.FORCE))
                        {
                            return;
                        }
                        InventoryBase inventoryBase;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true: // A single wearable
                                FieldInfo wearTypeInfo = typeof (WearableType).GetFields(BindingFlags.Public |
                                                                                         BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        p => p.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (wearTypeInfo == null)
                                {
                                    break;
                                }
                                KeyValuePair<AppearanceManager.WearableData, WearableType> wearable = GetWearables(
                                    Client.Inventory.Store.RootNode)
                                    .AsParallel().FirstOrDefault(
                                        o => o.Value.Equals((WearableType) wearTypeInfo.GetValue(null)));
                                switch (
                                    !wearable.Equals(default(KeyValuePair<AppearanceManager.WearableData, WearableType>))
                                    )
                                {
                                    case true:
                                        inventoryBase = FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                            wearable.Value).FirstOrDefault();
                                        if (inventoryBase != null)
                                            UnWear(inventoryBase as InventoryItem);
                                        break;
                                }
                                break;
                            default:
                                Parallel.ForEach(GetWearables(Client.Inventory.Store.RootNode)
                                    .AsParallel().Select(o => new[]
                                    {
                                        o.Key
                                    }).SelectMany(o => o), o =>
                                    {
                                        inventoryBase =
                                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, o.ItemID
                                                )
                                                .FirstOrDefault(p => (p is InventoryWearable));
                                        if (inventoryBase == null)
                                        {
                                            return;
                                        }
                                        UnWear(inventoryBase as InventoryItem);
                                    });
                                break;
                        }
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case RLVBehaviour.GETPATHNEW:
                case RLVBehaviour.GETPATH:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        // General variables
                        InventoryBase inventoryBase = null;
                        KeyValuePair<Primitive, AttachmentPoint> attachment;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                // Try attachments
                                RLVAttachment RLVattachment =
                                    RLVAttachments.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (!RLVattachment.Equals(default(RLVAttachment)))
                                {
                                    attachment =
                                        GetAttachments(corradeConfiguration.ServicesTimeout,
                                            corradeConfiguration.DataTimeout)
                                            .AsParallel()
                                            .FirstOrDefault(o => o.Value.Equals(RLVattachment.AttachmentPoint));
                                    switch (!attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                                    {
                                        case true:
                                            inventoryBase = FindInventory<InventoryBase>(
                                                RLVFolder, attachment.Key.Properties.ItemID
                                                )
                                                .AsParallel().FirstOrDefault(
                                                    p =>
                                                        (p is InventoryItem) &&
                                                        ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                            break;
                                        default:
                                            return;
                                    }
                                    break;
                                }
                                RLVWearable RLVwearable =
                                    RLVWearables.AsParallel().FirstOrDefault(
                                        o => o.Name.Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                if (!RLVwearable.Equals(default(RLVWearable)))
                                {
                                    FieldInfo wearTypeInfo = typeof (WearableType).GetFields(BindingFlags.Public |
                                                                                             BindingFlags.Static)
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                p.Name.Equals(RLVrule.Option,
                                                    StringComparison.InvariantCultureIgnoreCase));
                                    if (wearTypeInfo == null)
                                    {
                                        return;
                                    }
                                    KeyValuePair<AppearanceManager.WearableData, WearableType> wearable = GetWearables(
                                        RLVFolder)
                                        .AsParallel().FirstOrDefault(
                                            o => o.Value.Equals((WearableType) wearTypeInfo.GetValue(null)));
                                    if (
                                        wearable.Equals(
                                            default(KeyValuePair<AppearanceManager.WearableData, WearableType>)))
                                    {
                                        return;
                                    }
                                    inventoryBase =
                                        FindInventory<InventoryBase>(RLVFolder,
                                            wearable
                                                .Key.ItemID)
                                            .AsParallel().FirstOrDefault(o => (o is InventoryWearable));
                                }
                                break;
                            default:
                                attachment =
                                    GetAttachments(corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout)
                                        .AsParallel().FirstOrDefault(o => o.Key.ID.Equals(senderUUID));
                                switch (!attachment.Equals(default(KeyValuePair<Primitive, AttachmentPoint>)))
                                {
                                    case true:
                                        inventoryBase = FindInventory<InventoryBase>(
                                            Client.Inventory.Store.RootNode, attachment.Key.Properties.ItemID
                                            )
                                            .AsParallel().FirstOrDefault(
                                                p =>
                                                    (p is InventoryItem) &&
                                                    ((InventoryItem) p).AssetType.Equals(AssetType.Object));
                                        break;
                                }
                                break;
                        }
                        if (inventoryBase == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        KeyValuePair<InventoryBase, LinkedList<string>> path =
                            FindInventoryPath<InventoryBase>(RLVFolder, inventoryBase.Name,
                                new LinkedList<string>()).FirstOrDefault();
                        switch (!path.Equals(default(KeyValuePair<InventoryBase, LinkedList<string>>)))
                        {
                            case true:
                                Client.Self.Chat(string.Join(RLV_CONSTANTS.PATH_SEPARATOR, path.Value.ToArray()),
                                    channel,
                                    ChatType.Normal);
                                break;
                            default:
                                Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                                return;
                        }
                    };
                    break;
                case RLVBehaviour.FINDFOLDER:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        if (string.IsNullOrEmpty(RLVrule.Option))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        List<string> folders = new List<string>();
                        HashSet<string> parts =
                            new HashSet<string>(RLVrule.Option.Split(RLV_CONSTANTS.AND_OPERATOR.ToCharArray()));
                        object LockObject = new object();
                        Parallel.ForEach(FindInventoryPath<InventoryBase>(RLVFolder,
                            CORRADE_CONSTANTS.OneOrMoRegex,
                            new LinkedList<string>())
                            .AsParallel().Where(
                                o =>
                                    o.Key is InventoryFolder &&
                                    !o.Key.Name.Substring(1).Equals(RLV_CONSTANTS.DOT_MARKER) &&
                                    !o.Key.Name.Substring(1).Equals(RLV_CONSTANTS.TILDE_MARKER)), o =>
                                    {
                                        int count = 0;
                                        Parallel.ForEach(parts, p => Parallel.ForEach(o.Value, q =>
                                        {
                                            if (q.Contains(p))
                                            {
                                                Interlocked.Increment(ref count);
                                            }
                                        }));
                                        if (!count.Equals(parts.Count)) return;
                                        lock (LockObject)
                                        {
                                            folders.Add(o.Key.Name);
                                        }
                                    });
                        if (folders.Any())
                        {
                            Client.Self.Chat(string.Join(RLV_CONSTANTS.PATH_SEPARATOR, folders.ToArray()),
                                channel,
                                ChatType.Normal);
                        }
                    };
                    break;
                case RLVBehaviour.GETINV:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        if (string.IsNullOrEmpty(RLVrule.Option))
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        InventoryNode optionFolderNode;
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                KeyValuePair<InventoryNode, LinkedList<string>> folderPath = FindInventoryPath
                                    <InventoryNode>(
                                        RLVFolder,
                                        CORRADE_CONSTANTS.OneOrMoRegex,
                                        new LinkedList<string>())
                                    .AsParallel().Where(o => o.Key.Data is InventoryFolder)
                                    .FirstOrDefault(
                                        o =>
                                            string.Join(RLV_CONSTANTS.PATH_SEPARATOR, o.Value.Skip(1).ToArray())
                                                .Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                                switch (!folderPath.Equals(default(KeyValuePair<InventoryNode, LinkedList<string>>)))
                                {
                                    case true:
                                        optionFolderNode = folderPath.Key;
                                        break;
                                    default:
                                        Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                                        return;
                                }
                                break;
                            default:
                                optionFolderNode = RLVFolder;
                                break;
                        }
                        HashSet<string> csv = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(
                            FindInventory<InventoryBase>(optionFolderNode, CORRADE_CONSTANTS.OneOrMoRegex),
                            o =>
                            {
                                if (o.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER)) return;
                                lock (LockObject)
                                {
                                    csv.Add(o.Name);
                                }
                            });
                        Client.Self.Chat(string.Join(RLV_CONSTANTS.CSV_DELIMITER, csv.ToArray()), channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETINVWORN:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        InventoryNode RLVFolder =
                            FindInventory<InventoryNode>(Client.Inventory.Store.RootNode,
                                RLV_CONSTANTS.SHARED_FOLDER_NAME)
                                .AsParallel()
                                .FirstOrDefault(o => o.Data is InventoryFolder);
                        if (RLVFolder == null)
                        {
                            Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                            return;
                        }
                        KeyValuePair<InventoryNode, LinkedList<string>> folderPath = FindInventoryPath<InventoryNode>(
                            RLVFolder,
                            CORRADE_CONSTANTS.OneOrMoRegex,
                            new LinkedList<string>())
                            .AsParallel().Where(o => o.Key.Data is InventoryFolder)
                            .FirstOrDefault(
                                o =>
                                    string.Join(RLV_CONSTANTS.PATH_SEPARATOR, o.Value.Skip(1).ToArray())
                                        .Equals(RLVrule.Option, StringComparison.InvariantCultureIgnoreCase));
                        switch (!folderPath.Equals(default(KeyValuePair<InventoryNode, LinkedList<string>>)))
                        {
                            case false:
                                Client.Self.Chat(string.Empty, channel, ChatType.Normal);
                                return;
                        }
                        Func<InventoryNode, string> GetWornIndicator = node =>
                        {
                            Dictionary<AppearanceManager.WearableData, WearableType> currentWearables =
                                GetWearables(Client.Inventory.Store.RootNode).ToDictionary(o => o.Key, o => o.Value);
                            Dictionary<Primitive, AttachmentPoint> currentAttachments =
                                GetAttachments(corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                                    .ToDictionary(o => o.Key, p => p.Value);

                            int myItemsCount = 0;
                            int myItemsWornCount = 0;

                            Parallel.ForEach(
                                node.Nodes.Values.AsParallel().Where(
                                    n =>
                                        !n.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER) &&
                                        n.Data is InventoryItem && CanBeWorn(n.Data)
                                    ), n =>
                                    {
                                        Interlocked.Increment(ref myItemsCount);
                                        if ((n.Data is InventoryWearable &&
                                             currentWearables.Keys.AsParallel().Any(
                                                 o => o.ItemID.Equals(ResolveItemLink(n.Data as InventoryItem).UUID))) ||
                                            currentAttachments.AsParallel().Any(
                                                o =>
                                                    o.Key.Properties.ItemID.Equals(
                                                        ResolveItemLink(n.Data as InventoryItem).UUID)))
                                        {
                                            Interlocked.Increment(ref myItemsWornCount);
                                        }
                                    });


                            int allItemsCount = 0;
                            int allItemsWornCount = 0;

                            Parallel.ForEach(
                                node.Nodes.Values.AsParallel().Where(
                                    n =>
                                        !n.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER) &&
                                        n.Data is InventoryFolder
                                    ),
                                n => Parallel.ForEach(n.Nodes.Values
                                    .AsParallel().Where(o => !o.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER))
                                    .Where(
                                        o =>
                                            o.Data is InventoryItem && CanBeWorn(o.Data) &&
                                            !o.Data.Name.StartsWith(RLV_CONSTANTS.DOT_MARKER)), p =>
                                            {
                                                Interlocked.Increment(ref allItemsCount);
                                                if ((p.Data is InventoryWearable &&
                                                     currentWearables.Keys.AsParallel().Any(
                                                         o =>
                                                             o.ItemID.Equals(
                                                                 ResolveItemLink(p.Data as InventoryItem).UUID))) ||
                                                    currentAttachments.AsParallel().Any(
                                                        o =>
                                                            o.Key.Properties.ItemID.Equals(
                                                                ResolveItemLink(p.Data as InventoryItem).UUID)))
                                                {
                                                    Interlocked.Increment(ref allItemsWornCount);
                                                }
                                            }));


                            Func<int, int, string> WornIndicator =
                                (all, one) => all > 0 ? (all.Equals(one) ? "3" : (one > 0 ? "2" : "1")) : "0";

                            return WornIndicator(myItemsCount, myItemsWornCount) +
                                   WornIndicator(allItemsCount, allItemsWornCount);
                        };
                        List<string> response = new List<string>
                        {
                            string.Format("{0}{1}", RLV_CONSTANTS.PROPORTION_SEPARATOR,
                                GetWornIndicator(folderPath.Key))
                        };
                        response.AddRange(
                            folderPath.Key.Nodes.Values.AsParallel().Where(node => node.Data is InventoryFolder)
                                .Select(
                                    node =>
                                        string.Format("{0}{1}{2}", node.Data.Name,
                                            RLV_CONSTANTS.PROPORTION_SEPARATOR, GetWornIndicator(node))));

                        Client.Self.Chat(string.Join(RLV_CONSTANTS.CSV_DELIMITER, response.ToArray()),
                            channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.GETSTATUSALL:
                case RLVBehaviour.GETSTATUS:
                    execute = () =>
                    {
                        int channel;
                        if (!int.TryParse(RLVrule.Param, out channel) || channel < 1)
                        {
                            return;
                        }
                        string separator = RLV_CONSTANTS.PATH_SEPARATOR;
                        string filter = string.Empty;
                        if (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            string[] parts = RLVrule.Option.Split(RLV_CONSTANTS.STATUS_SEPARATOR[0]);
                            if (parts.Length > 1 && parts[1].Length > 0)
                            {
                                separator = parts[1].Substring(0, 1);
                            }
                            if (parts.Length > 0 && parts[0].Length > 0)
                            {
                                filter = parts[0].ToLowerInvariant();
                            }
                        }
                        StringBuilder response = new StringBuilder();
                        lock (RLVRulesLock)
                        {
                            object LockObject = new object();
                            Parallel.ForEach(RLVRules.AsParallel().Where(o =>
                                o.ObjectUUID.Equals(senderUUID) && o.Behaviour.Contains(filter)
                                ), o =>
                                {
                                    lock (LockObject)
                                    {
                                        response.AppendFormat("{0}{1}", separator, o.Behaviour);
                                    }
                                    if (!string.IsNullOrEmpty(o.Option))
                                    {
                                        lock (LockObject)
                                        {
                                            response.AppendFormat("{0}{1}", RLV_CONSTANTS.PATH_SEPARATOR, o.Option);
                                        }
                                    }
                                });
                        }
                        Client.Self.Chat(response.ToString(),
                            channel,
                            ChatType.Normal);
                    };
                    break;
                case RLVBehaviour.CLEAR:
                    execute = () =>
                    {
                        switch (!string.IsNullOrEmpty(RLVrule.Option))
                        {
                            case true:
                                lock (RLVRulesLock)
                                {
                                    RLVRules.RemoveWhere(o => o.Behaviour.Contains(RLVrule.Behaviour));
                                }
                                break;
                            case false:
                                lock (RLVRulesLock)
                                {
                                    RLVRules.RemoveWhere(o => o.ObjectUUID.Equals(senderUUID));
                                }
                                break;
                        }
                    };
                    break;
                default:
                    execute =
                        () =>
                        {
                            throw new Exception(string.Join(CORRADE_CONSTANTS.ERROR_SEPARATOR,
                                wasGetDescriptionFromEnumValue(ConsoleError.BEHAVIOUR_NOT_IMPLEMENTED),
                                RLVrule.Behaviour));
                        };
                    break;
            }

            try
            {
                execute.Invoke();
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.FAILED_TO_MANIFEST_RLV_BEHAVIOUR), ex.Message);
            }

            CONTINUE:
            HandleRLVBehaviour(message, senderUUID);
        }

        private static Dictionary<string, string> HandleCorradeCommand(string message, string sender, string identifier,
            Group commandGroup)
        {
            // Get password.
            string password =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.Password)), message));
            // Bail if no password set.
            if (string.IsNullOrEmpty(password)) return null;
            // Authenticate the request against the group password.
            if (!Authenticate(commandGroup.Name, password))
            {
                Feedback(commandGroup.Name, wasGetDescriptionFromEnumValue(ConsoleError.ACCESS_DENIED));
                return null;
            }
            // Censor password.
            message = wasKeyValueSet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.Password)),
                CORRADE_CONSTANTS.PASSWORD_CENSOR, message);
            /*
             * OpenSim sends the primitive UUID through args.IM.FromAgentID while Second Life properly sends 
             * the agent UUID - which just shows how crap and non-compliant OpenSim really is. This tries to 
             * resolve args.IM.FromAgentID to a name, which is what Second Life does, otherwise it just sets
             * the name to the name of the primitive sending the message.
             */
            if (IsSecondLife())
            {
                UUID fromAgentID;
                if (UUID.TryParse(identifier, out fromAgentID))
                {
                    if (
                        !AgentUUIDToName(fromAgentID, corradeConfiguration.ServicesTimeout,
                            ref sender))
                    {
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.AGENT_NOT_FOUND),
                            fromAgentID.ToString());
                        return null;
                    }
                }
            }

            // Log the command.
            Feedback(string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0} ({1}) : {2}", sender,
                identifier,
                message));

            // Initialize workers for the group if they are not set.
            lock (GroupWorkersLock)
            {
                if (!GroupWorkers.Contains(commandGroup.Name))
                {
                    GroupWorkers.Add(commandGroup.Name, 0u);
                }
            }

            // Check if the workers have not been exceeded.
            lock (GroupWorkersLock)
            {
                if ((uint) GroupWorkers[commandGroup.Name] >
                    corradeConfiguration.Groups.AsParallel().FirstOrDefault(
                        o => o.Name.Equals(commandGroup.Name, StringComparison.InvariantCultureIgnoreCase)).Workers)
                {
                    // And refuse to proceed if they have.
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.WORKERS_EXCEEDED),
                        commandGroup.Name);
                    return null;
                }
            }

            // Increment the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[commandGroup.Name] = ((uint) GroupWorkers[commandGroup.Name]) + 1;
            }
            // Perform the command.
            Dictionary<string, string> result = ProcessCommand(message, commandGroup);
            // Decrement the group workers.
            lock (GroupWorkersLock)
            {
                GroupWorkers[commandGroup.Name] = ((uint) GroupWorkers[commandGroup.Name]) - 1;
            }
            // do not send a callback if the callback queue is saturated
            if (CallbackQueue.Count >= corradeConfiguration.CallbackQueueLength)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.CallbackThrottleD));
                return result;
            }
            // send callback if registered
            string url =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CALLBACK)), message));
            // if no url was provided, do not send the callback
            if (string.IsNullOrEmpty(url)) return result;
            CallbackQueue.Enqueue(new CallbackQueueElement
            {
                URL = url,
                message = wasKeyValueEscape(result)
            });
            return result;
        }

        /// <summary>
        ///     This function is responsible for processing commands.
        /// </summary>
        /// <param name="message">the message</param>
        /// <param name="commandGroup">the group for the Corrade command</param>
        /// <returns>a dictionary of key-value pairs representing the results of the command</returns>
        private static Dictionary<string, string> ProcessCommand(string message, Group commandGroup)
        {
            Dictionary<string, string> result = new Dictionary<string, string>
            {
                // add the command group to the response.
                {wasGetDescriptionFromEnumValue(ScriptKeys.GROUP), commandGroup.Name}
            };

            // retrieve the command from the message.
            string command =
                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND)), message));
            if (!string.IsNullOrEmpty(command))
            {
                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.COMMAND), command);
            }

            // switch on the command and execute.
            System.Action execute;
            switch (wasGetEnumValueFromDescription<ScriptKeys>(command))
            {
                case ScriptKeys.JOIN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.ALREADY_IN_GROUP);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        if (!targetGroup.OpenEnrollment)
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_OPEN);
                        }
                        if (!Client.Network.MaxAgentGroups.Equals(-1))
                        {
                            if (currentGroups.ToList().Count >= Client.Network.MaxAgentGroups)
                            {
                                throw new ScriptException(ScriptError.MAXIMUM_NUMBER_OF_GROUPS_REACHED);
                            }
                        }
                        ManualResetEvent GroupJoinedReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler =
                            (sender, args) => GroupJoinedReplyEvent.Set();
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupJoinedReply += GroupOperationEventHandler;
                            Client.Groups.RequestJoinGroup(commandGroup.UUID);
                            if (!GroupJoinedReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupJoinedReply -= GroupOperationEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_JOINING_GROUP);
                            }
                            Client.Groups.GroupJoinedReply -= GroupOperationEventHandler;
                        }
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_JOIN_GROUP);
                        }
                    };
                    break;
                case ScriptKeys.CREATEGROUP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        // if the grid is SecondLife and the group name length exceeds the allowed length...
                        if (IsSecondLife() &&
                            commandGroup.Name.Length > LINDEN_CONSTANTS.GROUPS.MAXIMUM_GROUP_NAME_LENGTH)
                        {
                            throw new ScriptException(ScriptError.TOO_MANY_CHARACTERS_FOR_GROUP_NAME);
                        }
                        if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                        }
                        if (Client.Self.Balance < corradeConfiguration.GroupCreateFee)
                        {
                            throw new ScriptException(ScriptError.INSUFFICIENT_FUNDS);
                        }
                        if (!corradeConfiguration.GroupCreateFee.Equals(0) &&
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group
                        {
                            Name = commandGroup.Name
                        };
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)),
                            ref targetGroup);
                        bool succeeded = false;
                        ManualResetEvent GroupCreatedReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupCreatedReplyEventArgs> GroupCreatedEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupCreatedReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupCreatedReply += GroupCreatedEventHandler;
                            Client.Groups.RequestCreateGroup(targetGroup);
                            if (!GroupCreatedReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupCreatedReply -= GroupCreatedEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_CREATING_GROUP);
                            }
                            Client.Groups.GroupCreatedReply -= GroupCreatedEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_CREATE_GROUP);
                        }
                    };
                    break;
                case ScriptKeys.INVITE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.Invite,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        if (AgentInGroup(agentUUID, commandGroup.UUID, corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.ALREADY_IN_GROUP);
                        }
                        HashSet<UUID> roleUUIDs = new HashSet<UUID>();
                        foreach (
                            string role in
                                wasCSVToEnumerable(
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                        message)))
                                    .AsParallel().Where(o => !string.IsNullOrEmpty(o)))
                        {
                            UUID roleUUID;
                            if (!UUID.TryParse(role, out roleUUID) &&
                                !RoleNameToUUID(role, commandGroup.UUID,
                                    corradeConfiguration.ServicesTimeout, ref roleUUID))
                            {
                                throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                            }
                            if (!roleUUIDs.Contains(roleUUID))
                            {
                                roleUUIDs.Add(roleUUID);
                            }
                        }
                        // No roles specified, so assume everyone role.
                        if (!roleUUIDs.Any())
                        {
                            roleUUIDs.Add(UUID.Zero);
                        }
                        if (!roleUUIDs.All(o => o.Equals(UUID.Zero)) &&
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.AssignMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        Client.Groups.Invite(commandGroup.UUID, roleUUIDs.ToList(), agentUUID);
                    };
                    break;
                case ScriptKeys.BATCHINVITE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.Invite,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        // Get the roles to invite to.
                        HashSet<UUID> roleUUIDs = new HashSet<UUID>();
                        foreach (
                            string role in
                                wasCSVToEnumerable(
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                        message)))
                                    .AsParallel().Where(o => !string.IsNullOrEmpty(o)))
                        {
                            UUID roleUUID;
                            if (!UUID.TryParse(role, out roleUUID) &&
                                !RoleNameToUUID(role, commandGroup.UUID,
                                    corradeConfiguration.ServicesTimeout, ref roleUUID))
                            {
                                throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                            }
                            if (!roleUUIDs.Contains(roleUUID))
                            {
                                roleUUIDs.Add(roleUUID);
                            }
                        }
                        // No roles specified, so assume everyone role.
                        if (!roleUUIDs.Any())
                        {
                            roleUUIDs.Add(UUID.Zero);
                        }
                        if (!roleUUIDs.All(o => o.Equals(UUID.Zero)) &&
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.AssignMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        // Get the group members.
                        Dictionary<UUID, GroupMember> groupMembers = null;
                        ManualResetEvent groupMembersReceivedEvent = new ManualResetEvent(false);
                        EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
                        {
                            groupMembers = args.Members;
                            groupMembersReceivedEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                            Client.Groups.RequestGroupMembers(commandGroup.UUID);
                            if (!groupMembersReceivedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_MEMBERS);
                            }
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                        }
                        HashSet<string> data = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(
                            wasCSVToEnumerable(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AVATARS)),
                                    message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                                    {
                                        UUID agentUUID;
                                        if (!UUID.TryParse(o, out agentUUID))
                                        {
                                            List<string> fullName = new List<string>(GetAvatarNames(o));
                                            if (
                                                !AgentNameToUUID(fullName.First(), fullName.Last(),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout, ref agentUUID))
                                            {
                                                // Add all the unrecognized agents to the returned list.
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                return;
                                            }
                                        }
                                        // Check if they are in the group already.
                                        switch (groupMembers.AsParallel().Any(p => p.Value.ID.Equals(agentUUID)))
                                        {
                                            case true: // if they are add to the returned list
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                break;
                                            default:
                                                Client.Groups.Invite(commandGroup.UUID, roleUUIDs.ToList(),
                                                    agentUUID);
                                                break;
                                        }
                                    });
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOGROUPINVITE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        uint action =
                            (uint) wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.ALREADY_IN_GROUP);
                        }
                        UUID sessionUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out sessionUUID))
                        {
                            throw new ScriptException(ScriptError.NO_SESSION_SPECIFIED);
                        }
                        lock (GroupInviteLock)
                        {
                            if (!GroupInvites.AsParallel().Any(o => o.Session.Equals(sessionUUID)))
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_GROUP_INVITE_SESSION);
                            }
                        }
                        int amount;
                        lock (GroupInviteLock)
                        {
                            GroupInvite groupInvite =
                                GroupInvites.AsParallel().FirstOrDefault(o => o.Session.Equals(sessionUUID));
                            switch (!groupInvite.Equals(default(GroupInvite)))
                            {
                                case true:
                                    amount = groupInvite.Fee;
                                    break;
                                default:
                                    throw new ScriptException(ScriptError.UNKNOWN_GROUP_INVITE_SESSION);
                            }
                        }
                        if (!amount.Equals(0) && action.Equals((uint) Action.ACCEPT))
                        {
                            if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                            {
                                throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                            }
                            if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                            {
                                throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                            }
                            if (Client.Self.Balance < amount)
                            {
                                throw new ScriptException(ScriptError.INSUFFICIENT_FUNDS);
                            }
                        }
                        Client.Self.GroupInviteRespond(commandGroup.UUID, sessionUUID,
                            action.Equals((uint) Action.ACCEPT));
                    };
                    break;
                case ScriptKeys.GETGROUPINVITES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (GroupInviteLock)
                        {
                            Parallel.ForEach(GroupInvites, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Group), o.Group});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o, o.Session), o.Session.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(o, o.Fee),
                                        o.Fee.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                    });
                                }
                            });
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.EJECT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.Eject,
                                corradeConfiguration.ServicesTimeout) ||
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.RemoveMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        if (
                            !AgentInGroup(agentUUID, commandGroup.UUID, corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRoleMembersEventHandler = (sender, args) =>
                        {
                            switch (
                                !args.RolesMembers.AsParallel()
                                    .Any(o => o.Key.Equals(targetGroup.OwnerRole) && o.Value.Equals(agentUUID)))
                            {
                                case false:
                                    throw new ScriptException(ScriptError.CANNOT_EJECT_OWNERS);
                            }
                            Parallel.ForEach(
                                args.RolesMembers.AsParallel().Where(
                                    o => o.Value.Equals(agentUUID)),
                                o => Client.Groups.RemoveFromRole(commandGroup.UUID, o.Key, agentUUID));
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRoleMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ROLE_MEMBERS);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                        }
                        ManualResetEvent GroupEjectEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupEjectEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMemberEjected += GroupOperationEventHandler;
                            Client.Groups.EjectUser(commandGroup.UUID, agentUUID);
                            if (!GroupEjectEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_EJECTING_AGENT);
                            }
                            Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_EJECT_AGENT);
                        }
                    };
                    break;
                case ScriptKeys.BATCHEJECT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.Eject,
                                corradeConfiguration.ServicesTimeout) ||
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.RemoveMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        // Get the group members.
                        Dictionary<UUID, GroupMember> groupMembers = null;
                        ManualResetEvent groupMembersReceivedEvent = new ManualResetEvent(false);
                        EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
                        {
                            groupMembers = args.Members;
                            groupMembersReceivedEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                            Client.Groups.RequestGroupMembers(commandGroup.UUID);
                            if (!groupMembersReceivedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_MEMBERS);
                            }
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        // Get roles members.
                        List<KeyValuePair<UUID, UUID>> groupRolesMembers = null;
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRoleMembersEventHandler = (sender, args) =>
                        {
                            groupRolesMembers = args.RolesMembers;
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRoleMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ROLE_MEMBERS);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                        }
                        HashSet<string> data = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(
                            wasCSVToEnumerable(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AVATARS)),
                                    message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                                    {
                                        UUID agentUUID;
                                        if (!UUID.TryParse(o, out agentUUID))
                                        {
                                            List<string> fullName = new List<string>(GetAvatarNames(o));
                                            if (
                                                !AgentNameToUUID(fullName.First(), fullName.Last(),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout, ref agentUUID))
                                            {
                                                // Add all the unrecognized agents to the returned list.
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                return;
                                            }
                                        }
                                        // Check if they are in the group.
                                        switch (!groupMembers.AsParallel().Any(p => p.Value.ID.Equals(agentUUID)))
                                        {
                                            case true: // if they are not, add them to the returned list
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                return;
                                        }
                                        // The agent could be resolved and they are in the group.
                                        // Check their status.
                                        switch (
                                            !groupRolesMembers.AsParallel()
                                                .Any(
                                                    p =>
                                                        p.Key.Equals(targetGroup.OwnerRole) && p.Value.Equals(agentUUID))
                                            )
                                        {
                                            case false: // cannot demote owners
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                return;
                                        }
                                        // Demote them.
                                        Parallel.ForEach(
                                            groupRolesMembers.AsParallel().Where(
                                                p => p.Value.Equals(agentUUID)),
                                            p => Client.Groups.RemoveFromRole(commandGroup.UUID, p.Key, agentUUID));
                                        // And eject them.
                                        ManualResetEvent GroupEjectEvent = new ManualResetEvent(false);
                                        bool succeeded = false;
                                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler =
                                            (sender, args) =>
                                            {
                                                succeeded = args.Success;
                                                GroupEjectEvent.Set();
                                            };
                                        lock (ClientInstanceGroupsLock)
                                        {
                                            Client.Groups.GroupMemberEjected += GroupOperationEventHandler;
                                            Client.Groups.EjectUser(commandGroup.UUID, agentUUID);
                                            GroupEjectEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false);
                                            Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                                        }
                                        // If the eject was not successful, add them to the output.
                                        switch (succeeded)
                                        {
                                            case false:
                                                lock (LockObject)
                                                {
                                                    data.Add(o);
                                                }
                                                break;
                                        }
                                    });
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.BAN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.GroupBanAccess,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        object LockObject = new object();
                        bool succeeded = false;
                        switch (action)
                        {
                            case Action.BAN:
                            case Action.UNBAN:
                                object AvatarsLock = new object();
                                Dictionary<UUID, string> avatars = new Dictionary<UUID, string>();
                                HashSet<string> data = new HashSet<string>();
                                Parallel.ForEach(
                                    wasCSVToEnumerable(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AVATARS)),
                                                message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                                                {
                                                    UUID agentUUID;
                                                    if (!UUID.TryParse(o, out agentUUID))
                                                    {
                                                        List<string> fullName = new List<string>(GetAvatarNames(o));
                                                        if (
                                                            !AgentNameToUUID(fullName.First(), fullName.Last(),
                                                                corradeConfiguration.ServicesTimeout,
                                                                corradeConfiguration.DataTimeout, ref agentUUID))
                                                        {
                                                            // Add all the unrecognized agents to the returned list.
                                                            lock (LockObject)
                                                            {
                                                                data.Add(o);
                                                            }
                                                            return;
                                                        }
                                                    }
                                                    lock (AvatarsLock)
                                                    {
                                                        avatars.Add(agentUUID, o);
                                                    }
                                                });
                                if (!avatars.Any())
                                    throw new ScriptException(ScriptError.NO_AVATARS_TO_BAN_OR_UNBAN);
                                // ban or unban the avatars
                                lock (ClientInstanceGroupsLock)
                                {
                                    ManualResetEvent GroupBanEvent = new ManualResetEvent(false);
                                    switch (action)
                                    {
                                        case Action.BAN:
                                            Client.Groups.RequestBanAction(commandGroup.UUID, GroupBanAction.Ban,
                                                avatars.Keys.ToArray(), (sender, args) => { GroupBanEvent.Set(); });
                                            break;
                                        case Action.UNBAN:
                                            Client.Groups.RequestBanAction(commandGroup.UUID, GroupBanAction.Unban,
                                                avatars.Keys.ToArray(), (sender, args) => { GroupBanEvent.Set(); });
                                            break;
                                    }
                                    if (!GroupBanEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        throw new ScriptException(ScriptError.TIMEOUT_MODIFYING_GROUP_BAN_LIST);
                                    }
                                }
                                // if this is a ban request and eject was requested as well, then eject the agents.
                                switch (action)
                                {
                                    case Action.BAN:
                                        bool alsoeject;
                                        if (bool.TryParse(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EJECT)),
                                                    message)),
                                            out alsoeject) && alsoeject)
                                        {
                                            // Get the group members.
                                            Dictionary<UUID, GroupMember> groupMembers = null;
                                            ManualResetEvent groupMembersReceivedEvent = new ManualResetEvent(false);
                                            EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate =
                                                (sender, args) =>
                                                {
                                                    groupMembers = args.Members;
                                                    groupMembersReceivedEvent.Set();
                                                };
                                            lock (ClientInstanceGroupsLock)
                                            {
                                                Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                                                Client.Groups.RequestGroupMembers(commandGroup.UUID);
                                                if (
                                                    !groupMembersReceivedEvent.WaitOne(
                                                        (int) corradeConfiguration.ServicesTimeout, false))
                                                {
                                                    Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                                    throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_MEMBERS);
                                                }
                                                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                            }
                                            OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                                            if (
                                                !RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout,
                                                    ref targetGroup))
                                            {
                                                throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                                            }
                                            // Get roles members.
                                            List<KeyValuePair<UUID, UUID>> groupRolesMembers = null;
                                            ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                                            EventHandler<GroupRolesMembersReplyEventArgs> GroupRoleMembersEventHandler =
                                                (sender, args) =>
                                                {
                                                    groupRolesMembers = args.RolesMembers;
                                                    GroupRoleMembersReplyEvent.Set();
                                                };
                                            lock (ClientInstanceGroupsLock)
                                            {
                                                Client.Groups.GroupRoleMembersReply += GroupRoleMembersEventHandler;
                                                Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                                                if (
                                                    !GroupRoleMembersReplyEvent.WaitOne(
                                                        (int) corradeConfiguration.ServicesTimeout, false))
                                                {
                                                    Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                                                    throw new ScriptException(
                                                        ScriptError.TIMEOUT_GETTING_GROUP_ROLE_MEMBERS);
                                                }
                                                Client.Groups.GroupRoleMembersReply -= GroupRoleMembersEventHandler;
                                            }
                                            Parallel.ForEach(
                                                groupMembers.AsParallel().Where(o => avatars.ContainsKey(o.Value.ID)),
                                                o =>
                                                {
                                                    // Check their status.
                                                    switch (
                                                        !groupRolesMembers.AsParallel()
                                                            .Any(
                                                                p =>
                                                                    p.Key.Equals(targetGroup.OwnerRole) &&
                                                                    p.Value.Equals(o.Value.ID))
                                                        )
                                                    {
                                                        case false: // cannot demote owners
                                                            lock (LockObject)
                                                            {
                                                                data.Add(avatars[o.Value.ID]);
                                                            }
                                                            return;
                                                    }
                                                    // Demote them.
                                                    Parallel.ForEach(
                                                        groupRolesMembers.AsParallel().Where(
                                                            p => p.Value.Equals(o.Value.ID)),
                                                        p =>
                                                            Client.Groups.RemoveFromRole(commandGroup.UUID, p.Key,
                                                                o.Value.ID));
                                                    ManualResetEvent GroupEjectEvent = new ManualResetEvent(false);
                                                    EventHandler<GroupOperationEventArgs> GroupOperationEventHandler =
                                                        (sender, args) =>
                                                        {
                                                            succeeded = args.Success;
                                                            GroupEjectEvent.Set();
                                                        };
                                                    lock (ClientInstanceGroupsLock)
                                                    {
                                                        Client.Groups.GroupMemberEjected += GroupOperationEventHandler;
                                                        Client.Groups.EjectUser(commandGroup.UUID, o.Value.ID);
                                                        GroupEjectEvent.WaitOne(
                                                            (int) corradeConfiguration.ServicesTimeout,
                                                            false);
                                                        Client.Groups.GroupMemberEjected -= GroupOperationEventHandler;
                                                    }
                                                    // If the eject was not successful, add them to the output.
                                                    switch (succeeded)
                                                    {
                                                        case false:
                                                            lock (LockObject)
                                                            {
                                                                data.Add(avatars[o.Value.ID]);
                                                            }
                                                            break;
                                                    }
                                                });
                                        }
                                        break;
                                }
                                if (data.Any())
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                        wasEnumerableToCSV(data));
                                }
                                break;
                            case Action.LIST:
                                ManualResetEvent BannedAgentsEvent = new ManualResetEvent(false);
                                Dictionary<UUID, DateTime> bannedAgents = null;
                                EventHandler<BannedAgentsEventArgs> BannedAgentsEventHandler = (sender, args) =>
                                {
                                    succeeded = args.Success;
                                    bannedAgents = args.BannedAgents;
                                    BannedAgentsEvent.Set();
                                };
                                lock (ClientInstanceGroupsLock)
                                {
                                    Client.Groups.BannedAgents += BannedAgentsEventHandler;
                                    Client.Groups.RequestBannedAgents(commandGroup.UUID);
                                    if (!BannedAgentsEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Groups.BannedAgents -= BannedAgentsEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_GROUP_BAN_LIST);
                                    }
                                    Client.Groups.BannedAgents -= BannedAgentsEventHandler;
                                }
                                List<string> csv = new List<string>();
                                switch (succeeded && bannedAgents != null)
                                {
                                    case true:
                                        Parallel.ForEach(bannedAgents, o =>
                                        {
                                            string agentName = string.Empty;
                                            switch (
                                                !AgentUUIDToName(o.Key, corradeConfiguration.ServicesTimeout,
                                                    ref agentName))
                                            {
                                                case false:
                                                    lock (LockObject)
                                                    {
                                                        csv.Add(agentName);
                                                        csv.Add(o.Key.ToString());
                                                        csv.Add(
                                                            o.Value.ToString(CultureInfo.DefaultThreadCurrentCulture));
                                                    }
                                                    break;
                                            }
                                        });
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_GROUP_BAN_LIST);
                                }
                                if (csv.Any())
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                        wasEnumerableToCSV(csv));
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETGROUPACCOUNTSUMMARYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        int days;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DAYS)), message)),
                                out days))
                        {
                            throw new ScriptException(ScriptError.INVALID_DAYS);
                        }
                        int interval;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INTERVAL)),
                                        message)),
                                out interval))
                        {
                            throw new ScriptException(ScriptError.INVALID_INTERVAL);
                        }
                        ManualResetEvent RequestGroupAccountSummaryEvent = new ManualResetEvent(false);
                        GroupAccountSummary summary = new GroupAccountSummary();
                        EventHandler<GroupAccountSummaryReplyEventArgs> RequestGroupAccountSummaryEventHandler =
                            (sender, args) =>
                            {
                                summary = args.Summary;
                                RequestGroupAccountSummaryEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupAccountSummaryReply += RequestGroupAccountSummaryEventHandler;
                            Client.Groups.RequestGroupAccountSummary(commandGroup.UUID, days, interval);
                            if (
                                !RequestGroupAccountSummaryEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                    false))
                            {
                                Client.Groups.GroupAccountSummaryReply -= RequestGroupAccountSummaryEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ACCOUNT_SUMMARY);
                            }
                            Client.Groups.GroupAccountSummaryReply -= RequestGroupAccountSummaryEventHandler;
                        }
                        List<string> data = new List<string>(GetStructuredData(summary,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)))
                            );
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.UPDATEGROUPDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.ChangeIdentity,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)),
                            ref targetGroup);
                        Client.Groups.UpdateGroup(commandGroup.UUID, targetGroup);
                    };
                    break;
                case ScriptKeys.LEAVE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        ManualResetEvent GroupLeaveReplyEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<GroupOperationEventArgs> GroupOperationEventHandler = (sender, args) =>
                        {
                            succeeded = args.Success;
                            GroupLeaveReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupLeaveReply += GroupOperationEventHandler;
                            Client.Groups.LeaveGroup(commandGroup.UUID);
                            if (!GroupLeaveReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupLeaveReply -= GroupOperationEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_LEAVING_GROUP);
                            }
                            Client.Groups.GroupLeaveReply -= GroupOperationEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_LEAVE_GROUP);
                        }
                    };
                    break;
                case ScriptKeys.CREATEROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.CreateRole,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        int roleCount = 0;
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRolesDataEventHandler = (sender, args) =>
                        {
                            roleCount = args.Roles.Count;
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRolesDataEventHandler;
                            Client.Groups.RequestGroupRoles(commandGroup.UUID);
                            if (!GroupRoleDataReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ROLES);
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                        }
                        if (IsSecondLife() && roleCount >= LINDEN_CONSTANTS.GROUPS.MAXIMUM_NUMBER_OF_ROLES)
                        {
                            throw new ScriptException(ScriptError.MAXIMUM_NUMBER_OF_ROLES_EXCEEDED);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        if (string.IsNullOrEmpty(role))
                        {
                            throw new ScriptException(ScriptError.NO_ROLE_NAME_SPECIFIED);
                        }
                        ulong powers = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POWERS)),
                                message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                                Parallel.ForEach(
                                    typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { powers |= ((ulong) q.GetValue(null)); }));
                        if (!HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.ChangeActions,
                            corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        string title = wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TITLE)), message));
                        if (IsSecondLife() && title.Length > LINDEN_CONSTANTS.GROUPS.MAXIMUM_GROUP_TITLE_LENGTH)
                        {
                            throw new ScriptException(ScriptError.TOO_MANY_CHARACTERS_FOR_GROUP_TITLE);
                        }
                        Client.Groups.CreateRole(commandGroup.UUID, new GroupRole
                        {
                            Name = role,
                            Description =
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                        message)),
                            GroupID = commandGroup.UUID,
                            ID = UUID.Random(),
                            Powers = (GroupPowers) powers,
                            Title = title
                        });
                        UUID roleUUID = UUID.Zero;
                        if (
                            !RoleNameToUUID(role, commandGroup.UUID,
                                corradeConfiguration.ServicesTimeout, ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_CREATE_ROLE);
                        }
                    };
                    break;
                case ScriptKeys.GETROLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        List<string> csv = new List<string>();
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRolesDataEventHandler = (sender, args) =>
                        {
                            csv.AddRange(args.Roles.AsParallel().Select(o => new[]
                            {
                                o.Value.Name,
                                o.Value.ID.ToString(),
                                o.Value.Title,
                                o.Value.Description
                            }).SelectMany(o => o));
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRolesDataEventHandler;
                            Client.Groups.RequestGroupRoles(commandGroup.UUID);
                            if (!GroupRoleDataReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ROLES);
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRolesDataEventHandler;
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        ManualResetEvent agentInGroupEvent = new ManualResetEvent(false);
                        List<string> csv = new List<string>();
                        Dictionary<UUID, GroupMember> groupMembers = new Dictionary<UUID, GroupMember>();
                        EventHandler<GroupMembersReplyEventArgs> HandleGroupMembersReplyDelegate = (sender, args) =>
                        {
                            groupMembers = args.Members;
                            agentInGroupEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupMembersReply += HandleGroupMembersReplyDelegate;
                            Client.Groups.RequestGroupMembers(commandGroup.UUID);
                            if (!agentInGroupEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_MEMBERS);
                            }
                            Client.Groups.GroupMembersReply -= HandleGroupMembersReplyDelegate;
                        }
                        foreach (KeyValuePair<UUID, GroupMember> pair in groupMembers)
                        {
                            string agentName = string.Empty;
                            switch (
                                !AgentUUIDToName(pair.Value.ID, corradeConfiguration.ServicesTimeout, ref agentName))
                            {
                                case true:
                                    continue;
                                default:
                                    csv.Add(agentName);
                                    csv.Add(pair.Key.ToString());
                                    break;
                            }
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMEMBERROLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        if (
                            !AgentInGroup(agentUUID, commandGroup.UUID, corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_IN_GROUP);
                        }
                        HashSet<string> csv = new HashSet<string>();
                        // get roles for a member
                        HashSet<KeyValuePair<UUID, UUID>> groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>();
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler = (sender, args) =>
                        {
                            groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>(args.RolesMembers);
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        // now resolve the roles
                        foreach (
                            KeyValuePair<UUID, UUID> pair in
                                groupRolesMembers.AsParallel().Where(o => o.Value.Equals(agentUUID)))
                        {
                            string roleName = string.Empty;
                            switch (!RoleUUIDToName(pair.Key, commandGroup.UUID, corradeConfiguration.ServicesTimeout,
                                corradeConfiguration.DataTimeout,
                                ref roleName))
                            {
                                case true:
                                    continue;
                                default:
                                    csv.Add(roleName);
                                    break;
                            }
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLEMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        if (string.IsNullOrEmpty(role))
                        {
                            throw new ScriptException(ScriptError.NO_ROLE_NAME_SPECIFIED);
                        }
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToUUID(role, commandGroup.UUID,
                            corradeConfiguration.ServicesTimeout,
                            ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                        }
                        List<string> csv = new List<string>();
                        // get all roles and members
                        HashSet<KeyValuePair<UUID, UUID>> groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>();
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler =
                            (sender, args) =>
                            {
                                groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>(args.RolesMembers);
                                GroupRoleMembersReplyEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        foreach (
                            KeyValuePair<UUID, UUID> pair in
                                groupRolesMembers.AsParallel().Where(o => o.Key.Equals(roleUUID)))
                        {
                            string agentName = string.Empty;
                            switch (!AgentUUIDToName(pair.Value, corradeConfiguration.ServicesTimeout, ref agentName))
                            {
                                case true:
                                    continue;
                                default:
                                    csv.Add(agentName);
                                    csv.Add(pair.Value.ToString());
                                    break;
                            }
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLESMEMBERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        List<string> csv = new List<string>();
                        HashSet<KeyValuePair<UUID, UUID>> groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>();
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler =
                            (sender, args) =>
                            {
                                groupRolesMembers = new HashSet<KeyValuePair<UUID, UUID>>(args.RolesMembers);
                                GroupRoleMembersReplyEvent.Set();
                            };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETING_GROUP_ROLES_MEMBERS);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        // First resolve the all the role names to role UUIDs
                        Hashtable roleUUIDNames = new Hashtable(groupRolesMembers.Count);
                        foreach (
                            UUID roleUUID in
                                groupRolesMembers.AsParallel().GroupBy(o => o.Key).Select(o => o.First().Key))
                        {
                            string roleName = string.Empty;
                            switch (
                                !RoleUUIDToName(roleUUID, commandGroup.UUID, corradeConfiguration.ServicesTimeout,
                                    corradeConfiguration.DataTimeout,
                                    ref roleName))
                            {
                                case true:
                                    continue;
                                default:
                                    roleUUIDNames.Add(roleUUID, roleName);
                                    break;
                            }
                        }
                        // Next, associate role names with agent names and UUIDs.
                        foreach (KeyValuePair<UUID, UUID> pair in groupRolesMembers)
                        {
                            if (!roleUUIDNames.ContainsKey(pair.Key)) continue;
                            string agentName = string.Empty;
                            switch (
                                !AgentUUIDToName(pair.Value, corradeConfiguration.ServicesTimeout, ref agentName))
                            {
                                case true:
                                    continue;
                                default:
                                    csv.Add(roleUUIDNames[pair.Key] as string);
                                    csv.Add(agentName);
                                    csv.Add(pair.Value.ToString());
                                    break;
                            }
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETROLEPOWERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.RoleProperties,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToUUID(role, commandGroup.UUID,
                            corradeConfiguration.ServicesTimeout,
                            ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                        }
                        HashSet<string> csv = new HashSet<string>();
                        ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataEventHandler = (sender, args) =>
                        {
                            GroupRole queryRole =
                                args.Roles.Values.AsParallel().FirstOrDefault(o => o.ID.Equals(roleUUID));
                            csv.UnionWith(typeof (GroupPowers).GetFields(BindingFlags.Public | BindingFlags.Static)
                                .AsParallel().Where(
                                    o =>
                                        !(((ulong) o.GetValue(null) &
                                           (ulong) queryRole.Powers)).Equals(0))
                                .Select(o => o.Name));
                            GroupRoleDataReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleDataReply += GroupRoleDataEventHandler;
                            Client.Groups.RequestGroupRoles(commandGroup.UUID);
                            if (!GroupRoleDataReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleDataReply -= GroupRoleDataEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_ROLE_POWERS);
                            }
                            Client.Groups.GroupRoleDataReply -= GroupRoleDataEventHandler;
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.DELETEROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.DeleteRole,
                                corradeConfiguration.ServicesTimeout) ||
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.RemoveMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToUUID(role, commandGroup.UUID,
                            corradeConfiguration.ServicesTimeout,
                            ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new ScriptException(ScriptError.CANNOT_DELETE_THE_EVERYONE_ROLE);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        if (targetGroup.OwnerRole.Equals(roleUUID))
                        {
                            throw new ScriptException(ScriptError.CANNOT_REMOVE_OWNER_ROLE);
                        }
                        // remove members from role
                        ManualResetEvent GroupRoleMembersReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupRolesMembersReplyEventArgs> GroupRolesMembersEventHandler = (sender, args) =>
                        {
                            Parallel.ForEach(args.RolesMembers.AsParallel().Where(o => o.Key.Equals(roleUUID)),
                                o => Client.Groups.RemoveFromRole(commandGroup.UUID, roleUUID, o.Value));
                            GroupRoleMembersReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupRoleMembersReply += GroupRolesMembersEventHandler;
                            Client.Groups.RequestGroupRolesMembers(commandGroup.UUID);
                            if (!GroupRoleMembersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_EJECTING_AGENT);
                            }
                            Client.Groups.GroupRoleMembersReply -= GroupRolesMembersEventHandler;
                        }
                        Client.Groups.DeleteRole(commandGroup.UUID, roleUUID);
                    };
                    break;
                case ScriptKeys.ADDTOROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.AssignMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToUUID(role, commandGroup.UUID,
                            corradeConfiguration.ServicesTimeout,
                            ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new ScriptException(ScriptError.GROUP_MEMBERS_ARE_BY_DEFAULT_IN_THE_EVERYONE_ROLE);
                        }
                        Client.Groups.AddToRole(commandGroup.UUID, roleUUID, agentUUID);
                    };
                    break;
                case ScriptKeys.DELETEFROMROLE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.RemoveMember,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        string role =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROLE)),
                                message));
                        UUID roleUUID;
                        if (!UUID.TryParse(role, out roleUUID) && !RoleNameToUUID(role, commandGroup.UUID,
                            corradeConfiguration.ServicesTimeout,
                            ref roleUUID))
                        {
                            throw new ScriptException(ScriptError.ROLE_NOT_FOUND);
                        }
                        if (roleUUID.Equals(UUID.Zero))
                        {
                            throw new ScriptException(ScriptError.CANNOT_DELETE_A_GROUP_MEMBER_FROM_THE_EVERYONE_ROLE);
                        }
                        OpenMetaverse.Group targetGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref targetGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        if (targetGroup.OwnerRole.Equals(roleUUID))
                        {
                            throw new ScriptException(ScriptError.CANNOT_REMOVE_USER_FROM_OWNER_ROLE);
                        }
                        Client.Groups.RemoveFromRole(commandGroup.UUID, roleUUID,
                            agentUUID);
                    };
                    break;
                case ScriptKeys.TELL:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Talk))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string data = wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message));
                        List<string> myName =
                            new List<string>(
                                GetAvatarNames(string.Join(" ", Client.Self.FirstName, Client.Self.LastName)));
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.AVATAR:
                                UUID agentUUID;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref agentUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                if (string.IsNullOrEmpty(data) ||
                                    (IsSecondLife() &&
                                     Encoding.UTF8.GetByteCount(data) >
                                     LINDEN_CONSTANTS.CHAT.MAXIMUM_MESSAGE_LENGTH))
                                {
                                    throw new ScriptException(ScriptError.TOO_MANY_OR_TOO_FEW_CHARACTERS_IN_MESSAGE);
                                }
                                Client.Self.InstantMessage(agentUUID, data);
                                // Log instant messages,
                                if (corradeConfiguration.InstantMessageLogEnabled)
                                {
                                    string agentName = string.Empty;
                                    if (!AgentUUIDToName(
                                        agentUUID,
                                        corradeConfiguration.ServicesTimeout,
                                        ref agentName))
                                    {
                                        throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                    }
                                    List<string> fullName =
                                        new List<string>(
                                            GetAvatarNames(agentName));
                                    CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                    {
                                        try
                                        {
                                            lock (InstantMessageLogFileLock)
                                            {
                                                using (
                                                    StreamWriter logWriter =
                                                        new StreamWriter(
                                                            wasPathCombine(
                                                                corradeConfiguration.InstantMessageLogDirectory,
                                                                string.Join(" ", fullName.First(), fullName.Last())) +
                                                            "." +
                                                            CORRADE_CONSTANTS.LOG_FILE_EXTENSION, true, Encoding.UTF8))
                                                {
                                                    logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                        myName.First(),
                                                        myName.Last(),
                                                        data);
                                                    //logWriter.Flush();
                                                    //logWriter.Close();
                                                }
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            // or fail and append the fail message.
                                            Feedback(
                                                wasGetDescriptionFromEnumValue(
                                                    ConsoleError.COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE),
                                                ex.Message);
                                        }
                                    }, corradeConfiguration.MaximumLogThreads);
                                }
                                break;
                            case Entity.GROUP:
                                IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                                if (
                                    !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                        ref currentGroups))
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                                }
                                if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                                {
                                    throw new ScriptException(ScriptError.NOT_IN_GROUP);
                                }
                                if (string.IsNullOrEmpty(data) || (IsSecondLife() &&
                                                                   Encoding.UTF8.GetByteCount(data) >
                                                                   LINDEN_CONSTANTS.CHAT.MAXIMUM_MESSAGE_LENGTH))
                                {
                                    throw new ScriptException(ScriptError.TOO_MANY_OR_TOO_FEW_CHARACTERS_IN_MESSAGE);
                                }
                                if (!Client.Self.GroupChatSessions.ContainsKey(commandGroup.UUID))
                                {
                                    if (
                                        !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.JoinChat,
                                            corradeConfiguration.ServicesTimeout))
                                    {
                                        throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                    }

                                    if (!JoinGroupChat(commandGroup.UUID, corradeConfiguration.ServicesTimeout))
                                    {
                                        throw new ScriptException(ScriptError.UNABLE_TO_JOIN_GROUP_CHAT);
                                    }
                                }
                                Client.Self.InstantMessageGroup(commandGroup.UUID, data);
                                Parallel.ForEach(
                                    corradeConfiguration.Groups.AsParallel().Where(
                                        o => o.UUID.Equals(commandGroup.UUID) && o.ChatLogEnabled),
                                    o =>
                                    {
                                        CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                        {
                                            // Attempt to write to log file,
                                            try
                                            {
                                                lock (GroupLogFileLock)
                                                {
                                                    using (
                                                        StreamWriter logWriter = new StreamWriter(o.ChatLog, true,
                                                            Encoding.UTF8))
                                                    {
                                                        logWriter.WriteLine("[{0}] {1} {2} : {3}",
                                                            DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                                CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                            myName.First(),
                                                            myName.Last(),
                                                            data);
                                                        //logWriter.Flush();
                                                        //logWriter.Close();
                                                    }
                                                }
                                            }
                                            catch (Exception ex)
                                            {
                                                // or fail and append the fail message.
                                                Feedback(
                                                    wasGetDescriptionFromEnumValue(
                                                        ConsoleError.COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE),
                                                    ex.Message);
                                            }
                                        }, corradeConfiguration.MaximumLogThreads);
                                    });
                                break;
                            case Entity.LOCAL:
                                if (string.IsNullOrEmpty(data) || (IsSecondLife() &&
                                                                   Encoding.UTF8.GetByteCount(data) >
                                                                   LINDEN_CONSTANTS.CHAT.MAXIMUM_MESSAGE_LENGTH))
                                {
                                    throw new ScriptException(ScriptError.TOO_MANY_OR_TOO_FEW_CHARACTERS_IN_MESSAGE);
                                }
                                int chatChannel;
                                if (
                                    !int.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL)),
                                                message)),
                                        out chatChannel))
                                {
                                    chatChannel = 0;
                                }
                                FieldInfo chatTypeInfo = typeof (ChatType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                        message)),
                                                StringComparison.Ordinal));
                                ChatType chatType = chatTypeInfo != null
                                    ? (ChatType)
                                        chatTypeInfo
                                            .GetValue(null)
                                    : ChatType.Normal;
                                Client.Self.Chat(
                                    data,
                                    chatChannel,
                                    chatType);
                                // Log local chat,
                                if (corradeConfiguration.LocalMessageLogEnabled)
                                {
                                    List<string> fullName =
                                        new List<string>(
                                            GetAvatarNames(string.Join(" ", Client.Self.FirstName, Client.Self.LastName)));
                                    CorradeThreadPool[CorradeThreadType.LOG].SpawnSequential(() =>
                                    {
                                        try
                                        {
                                            lock (LocalLogFileLock)
                                            {
                                                using (
                                                    StreamWriter logWriter =
                                                        new StreamWriter(
                                                            wasPathCombine(
                                                                corradeConfiguration.LocalMessageLogDirectory,
                                                                Client.Network.CurrentSim.Name) + "." +
                                                            CORRADE_CONSTANTS.LOG_FILE_EXTENSION, true, Encoding.UTF8))
                                                {
                                                    logWriter.WriteLine("[{0}] {1} {2} ({3}) : {4}",
                                                        DateTime.Now.ToString(CORRADE_CONSTANTS.DATE_TIME_STAMP,
                                                            CultureInfo.DefaultThreadCurrentCulture.DateTimeFormat),
                                                        fullName.First(),
                                                        fullName.Last(), Enum.GetName(typeof (ChatType), chatType),
                                                        data);
                                                    //logWriter.Flush();
                                                    //logWriter.Close();
                                                }
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            // or fail and append the fail message.
                                            Feedback(
                                                wasGetDescriptionFromEnumValue(
                                                    ConsoleError.COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE),
                                                ex.Message);
                                        }
                                    }, corradeConfiguration.MaximumLogThreads);
                                }
                                break;
                            case Entity.ESTATE:
                                Client.Estate.EstateMessage(data);
                                break;
                            case Entity.REGION:
                                Client.Estate.SimulatorMessage(data);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.AI:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Talk))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.PROCESS:
                                string request =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                            message));
                                if (string.IsNullOrEmpty(request))
                                {
                                    throw new ScriptException(ScriptError.NO_MESSAGE_PROVIDED);
                                }
                                if (AIMLBot.isAcceptingUserInput)
                                {
                                    lock (AIMLBotLock)
                                    {
                                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                            AIMLBot.Chat(new Request(request, AIMLBotUser, AIMLBot)).Output);
                                    }
                                }
                                break;
                            case Action.ENABLE:
                                lock (AIMLBotLock)
                                {
                                    switch (!AIMLBotBrainCompiled)
                                    {
                                        case true:
                                            new Thread(
                                                () =>
                                                {
                                                    lock (AIMLBotLock)
                                                    {
                                                        LoadChatBotFiles.Invoke();
                                                        AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                                    }
                                                })
                                            {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                                            break;
                                        default:
                                            AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                            AIMLBot.isAcceptingUserInput = true;
                                            break;
                                    }
                                }
                                break;
                            case Action.DISABLE:
                                lock (AIMLBotLock)
                                {
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                                    AIMLBot.isAcceptingUserInput = false;
                                }
                                break;
                            case Action.REBUILD:
                                lock (AIMLBotLock)
                                {
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                                    string AIMLBotBrain =
                                        wasPathCombine(
                                            Directory.GetCurrentDirectory(), AIML_BOT_CONSTANTS.DIRECTORY,
                                            AIML_BOT_CONSTANTS.BRAIN.DIRECTORY, AIML_BOT_CONSTANTS.BRAIN_FILE);
                                    if (File.Exists(AIMLBotBrain))
                                    {
                                        try
                                        {
                                            File.Delete(AIMLBotBrain);
                                        }
                                        catch (Exception)
                                        {
                                            throw new ScriptException(ScriptError.COULD_NOT_REMOVE_BRAIN_FILE);
                                        }
                                    }
                                    LoadChatBotFiles.Invoke();
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.NOTICE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.SendNotices,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        string body =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                    message));
                        if (IsSecondLife() && body.Length > LINDEN_CONSTANTS.NOTICES.MAXIMUM_NOTICE_MESSAGE_LENGTH)
                        {
                            throw new ScriptException(ScriptError.TOO_MANY_CHARACTERS_FOR_NOTICE_MESSAGE);
                        }
                        GroupNotice notice = new GroupNotice
                        {
                            Message = body,
                            Subject =
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SUBJECT)),
                                        message)),
                            OwnerID = Client.Self.AgentID
                        };
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        if (item != null)
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                            }
                            notice.AttachmentID = inventoryBaseItem.UUID;
                        }
                        Client.Groups.SendGroupNotice(commandGroup.UUID, notice);
                    };
                    break;
                case ScriptKeys.PAY:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        int amount;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT)), message)),
                                out amount))
                        {
                            throw new ScriptException(ScriptError.INVALID_PAY_AMOUNT);
                        }
                        if (amount.Equals(0))
                        {
                            throw new ScriptException(ScriptError.INVALID_PAY_AMOUNT);
                        }
                        if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                        }
                        if (Client.Self.Balance < amount)
                        {
                            throw new ScriptException(ScriptError.INSUFFICIENT_FUNDS);
                        }
                        UUID targetUUID;
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.GROUP:
                                Client.Self.GiveGroupMoney(commandGroup.UUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            case Entity.AVATAR:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref targetUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                Client.Self.GiveAvatarMoney(targetUUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            case Entity.OBJECT:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message)),
                                        out targetUUID))
                                {
                                    throw new ScriptException(ScriptError.INVALID_PAY_TARGET);
                                }
                                Client.Self.GiveObjectMoney(targetUUID, amount,
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REASON)),
                                            message)));
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.GETBALANCE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            Client.Self.Balance.ToString(CultureInfo.DefaultThreadCurrentCulture));
                    };
                    break;
                case ScriptKeys.TELEPORT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        // We override the default teleport since region names are unique and case insensitive.
                        ulong regionHandle = 0;
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler =
                            (sender, args) =>
                            {
                                if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                    return;
                                regionHandle = args.Region.RegionHandle;
                                GridRegionEvent.Set();
                            };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne(Client.Settings.MAP_REQUEST_TIMEOUT, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_REGION);
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        if (regionHandle.Equals(0))
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        if (regionHandle.Equals(Client.Network.CurrentSim.Handle) &&
                            Vector3.Distance(Client.Self.SimPosition, position) <
                            LINDEN_CONSTANTS.REGION.TELEPORT_MINIMUM_DISTANCE)
                        {
                            throw new ScriptException(ScriptError.DESTINATION_TOO_CLOSE);
                        }
                        ManualResetEvent TeleportEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<TeleportEventArgs> TeleportEventHandler = (sender, args) =>
                        {
                            switch (args.Status)
                            {
                                case TeleportStatus.Cancelled:
                                case TeleportStatus.Failed:
                                case TeleportStatus.Finished:
                                    succeeded = args.Status.Equals(TeleportStatus.Finished);
                                    TeleportEvent.Set();
                                    break;
                            }
                        };
                        if (IsSecondLife() && !TimedTeleportThrottle.IsSafe)
                        {
                            throw new ScriptException(ScriptError.TELEPORT_THROTTLED);
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.TeleportProgress += TeleportEventHandler;
                            Client.Self.Teleport(regionHandle, position);
                            if (!TeleportEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Self.TeleportProgress -= TeleportEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_DURING_TELEPORT);
                            }
                            Client.Self.TeleportProgress -= TeleportEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.TELEPORT_FAILED);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.LURE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        Client.Self.SendTeleportLure(agentUUID,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message)));
                    };
                    break;
                case ScriptKeys.SETHOME:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        bool succeeded = true;
                        ManualResetEvent AlertMessageEvent = new ManualResetEvent(false);
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) =>
                        {
                            switch (args.Message)
                            {
                                case LINDEN_CONSTANTS.ALERTS.UNABLE_TO_SET_HOME:
                                    succeeded = false;
                                    AlertMessageEvent.Set();
                                    break;
                                case LINDEN_CONSTANTS.ALERTS.HOME_SET:
                                    succeeded = true;
                                    AlertMessageEvent.Set();
                                    break;
                            }
                        };
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.SetHome();
                            if (!AlertMessageEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Self.AlertMessage -= AlertMessageEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_REQUESTING_TO_SET_HOME);
                            }
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_SET_HOME);
                        }
                    };
                    break;
                case ScriptKeys.GOHOME:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        bool succeeded = Client.Self.GoHome();
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_GO_HOME);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.GETREGIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(simulator,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)))
                            );
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETGRIDREGIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        GridRegion gridRegion = new GridRegion();
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler = (sender, args) =>
                        {
                            if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                return;
                            gridRegion = args.Region;
                            GridRegionEvent.Set();
                        };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_REGION);
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        switch (!gridRegion.Equals(default(GridRegion)))
                        {
                            case false:
                                throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(gridRegion,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETNETWORKDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> data = new List<string>(GetStructuredData(Client.Network,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETCONNECTEDREGIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasEnumerableToCSV(Client.Network.Simulators.Select(o => o.Name)));
                    };
                    break;
                case ScriptKeys.LISTCOMMANDS:
                    execute = () =>
                    {
                        HashSet<string> data = new HashSet<string>();
                        object LockObject = new object();
                        Parallel.ForEach(wasGetEnumDescriptions<ScriptKeys>(), o =>
                        {
                            ScriptKeys scriptKey = wasGetEnumValueFromDescription<ScriptKeys>(o);
                            IsCommandAttribute isCommandAttribute =
                                wasGetAttributeFromEnumValue<IsCommandAttribute>(scriptKey);
                            if (isCommandAttribute == null || !isCommandAttribute.IsCommand)
                                return;
                            CommandPermissionMaskAttribute commandPermissionMaskAttribute =
                                wasGetAttributeFromEnumValue<CommandPermissionMaskAttribute>(scriptKey);
                            if (commandPermissionMaskAttribute == null) return;
                            if (!commandGroup.Equals(default(Group)) &&
                                !(commandGroup.PermissionMask & commandPermissionMaskAttribute.PermissionMask).Equals(0))
                            {
                                lock (LockObject)
                                {
                                    data.Add(o);
                                }
                            }
                        });
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETCOMMAND:
                    execute = () =>
                    {
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                        }
                        IsCommandAttribute isCommandAttribute =
                            wasGetAttributeFromEnumValue<IsCommandAttribute>(
                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                        if (isCommandAttribute == null || isCommandAttribute.IsCommand.Equals(false))
                        {
                            throw new ScriptException(ScriptError.COMMAND_NOT_FOUND);
                        }
                        CommandPermissionMaskAttribute commandPermissionMaskAttribute =
                            wasGetAttributeFromEnumValue<CommandPermissionMaskAttribute>(
                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                        if (commandPermissionMaskAttribute == null)
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (!commandGroup.Equals(default(Group)))
                        {
                            case false:
                                throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.SYNTAX:
                                switch (
                                    wasGetEnumValueFromDescription<Type>(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)).ToLowerInvariant()))
                                {
                                    case Type.INPUT:
                                        CommandInputSyntaxAttribute commandInputSyntaxAttribute = wasGetAttributeFromEnumValue
                                            <CommandInputSyntaxAttribute>(
                                                wasGetEnumValueFromDescription<ScriptKeys>(name));
                                        if (commandInputSyntaxAttribute != null &&
                                            !string.IsNullOrEmpty(commandInputSyntaxAttribute.Syntax))
                                        {
                                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                commandInputSyntaxAttribute.Syntax);
                                        }
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_SYNTAX_TYPE);
                                }
                                break;
                            case Entity.PERMISSION:
                                HashSet<string> data = new HashSet<string>();
                                object LockObject = new object();
                                Parallel.ForEach(wasGetEnumDescriptions<Permissions>(), o =>
                                {
                                    Permissions permission = wasGetEnumValueFromDescription<Permissions>(o);
                                    if ((commandPermissionMaskAttribute.PermissionMask & (uint) permission).Equals(0))
                                        return;
                                    lock (LockObject)
                                    {
                                        data.Add(o);
                                    }
                                });
                                if (data.Any())
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), wasEnumerableToCSV(data));
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.SIT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        ManualResetEvent SitEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<AvatarSitResponseEventArgs> AvatarSitEventHandler = (sender, args) =>
                        {
                            succeeded = !args.ObjectID.Equals(UUID.Zero);
                            SitEvent.Set();
                        };
                        EventHandler<AlertMessageEventArgs> AlertMessageEventHandler = (sender, args) =>
                        {
                            if (args.Message.Equals(LINDEN_CONSTANTS.ALERTS.NO_ROOM_TO_SIT_HERE))
                            {
                                succeeded = false;
                            }
                            SitEvent.Set();
                        };
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        lock (ClientInstanceSelfLock)
                        {
                            Client.Self.AvatarSitResponse += AvatarSitEventHandler;
                            Client.Self.AlertMessage += AlertMessageEventHandler;
                            Client.Self.RequestSit(primitive.ID, Vector3.Zero);
                            if (!SitEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                                Client.Self.AlertMessage -= AlertMessageEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_REQUESTING_SIT);
                            }
                            Client.Self.AvatarSitResponse -= AvatarSitEventHandler;
                            Client.Self.AlertMessage -= AlertMessageEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_SIT);
                        }
                        Client.Self.Sit();
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.RELAX:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        Client.Self.SitOnGround();
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.AWAY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.AWAY, true);
                                Client.Self.Movement.Away = true;
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.DISABLE:
                                Client.Self.Movement.Away = false;
                                Client.Self.AnimationStop(Animations.AWAY, true);
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.Movement.Away.ToString());
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.BUSY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.BUSY, true);
                                break;
                            case Action.DISABLE:
                                Client.Self.AnimationStop(Animations.BUSY, true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.SignaledAnimations.ContainsKey(Animations.BUSY).ToString());
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.TYPING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                Client.Self.AnimationStart(Animations.TYPE, true);
                                break;
                            case Action.DISABLE:
                                Client.Self.AnimationStop(Animations.TYPE, true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.SignaledAnimations.ContainsKey(Animations.TYPE).ToString());
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.RUN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.ENABLE:
                            case Action.DISABLE:
                                Client.Self.Movement.AlwaysRun = !action.Equals(Action.DISABLE);
                                Client.Self.Movement.SendUpdate(true);
                                break;
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ScriptKeys.DATA),
                                    Client.Self.Movement.AlwaysRun.ToString());
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.STAND:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                        {
                            Client.Self.Stand();
                        }
                        // stop all non-built-in animations
                        List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                            BindingFlags.Public |
                            BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                        Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                        {
                            if (!lindenAnimations.Contains(o))
                                Client.Self.AnimationStop(o, true);
                        });
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.GETPARCELLIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        FieldInfo accessField = typeof (AccessList).GetFields(
                            BindingFlags.Public | BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.Ordinal));
                        if (accessField == null)
                        {
                            throw new ScriptException(ScriptError.UNKNOWN_ACCESS_LIST_TYPE);
                        }
                        AccessList accessType = (AccessList) accessField.GetValue(null);
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                                switch (accessType)
                                {
                                    case AccessList.Access:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                                GroupPowers.LandManageAllowed, corradeConfiguration.ServicesTimeout))
                                        {
                                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                        }
                                        break;
                                    case AccessList.Ban:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                                GroupPowers.LandManageBanned,
                                                corradeConfiguration.ServicesTimeout))
                                        {
                                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                        }
                                        break;
                                    case AccessList.Both:
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                                GroupPowers.LandManageAllowed, corradeConfiguration.ServicesTimeout))
                                        {
                                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                        }
                                        if (
                                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                                GroupPowers.LandManageBanned,
                                                corradeConfiguration.ServicesTimeout))
                                        {
                                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                        }
                                        break;
                                }
                            }
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent ParcelAccessListEvent = new ManualResetEvent(false);
                        EventHandler<ParcelAccessListReplyEventArgs> ParcelAccessListHandler = (sender, args) =>
                        {
                            foreach (ParcelManager.ParcelAccessEntry parcelAccess in args.AccessList)
                            {
                                string agent = string.Empty;
                                if (
                                    !AgentUUIDToName(parcelAccess.AgentID, corradeConfiguration.ServicesTimeout,
                                        ref agent))
                                    continue;
                                csv.Add(agent);
                                csv.Add(parcelAccess.AgentID.ToString());
                                csv.Add(parcelAccess.Flags.ToString());
                                csv.Add(parcelAccess.Time.ToString(CultureInfo.DefaultThreadCurrentCulture));
                            }
                            ParcelAccessListEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelAccessListReply += ParcelAccessListHandler;
                            Client.Parcels.RequestParcelAccessList(simulator, parcel.LocalID, accessType, 0);
                            if (!ParcelAccessListEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Parcels.ParcelAccessListReply -= ParcelAccessListHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                            }
                            Client.Parcels.ParcelAccessListReply -= ParcelAccessListHandler;
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.PARCELRECLAIM:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!simulator.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        Client.Parcels.Reclaim(simulator, parcel.LocalID);
                    };
                    break;
                case ScriptKeys.PARCELRELEASE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                                if (
                                    !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.LandRelease,
                                        corradeConfiguration.ServicesTimeout))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                            }
                        }
                        Client.Parcels.ReleaseParcel(simulator, parcel.LocalID);
                    };
                    break;
                case ScriptKeys.PARCELDEED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                            }
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.LandDeed,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        Client.Parcels.DeedToGroup(simulator, parcel.LocalID, commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.PARCELBUY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        bool forGroup;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORGROUP)),
                                        message)),
                                out forGroup))
                        {
                            if (
                                !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.LandDeed,
                                    corradeConfiguration.ServicesTimeout))
                            {
                                throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                            }
                            forGroup = true;
                        }
                        bool removeContribution;
                        if (!bool.TryParse(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REMOVECONTRIBUTION)),
                                    message)),
                            out removeContribution))
                        {
                            removeContribution = true;
                        }
                        ManualResetEvent ParcelInfoEvent = new ManualResetEvent(false);
                        UUID parcelUUID = UUID.Zero;
                        EventHandler<ParcelInfoReplyEventArgs> ParcelInfoEventHandler = (sender, args) =>
                        {
                            parcelUUID = args.Parcel.ID;
                            ParcelInfoEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelInfoReply += ParcelInfoEventHandler;
                            Client.Parcels.RequestParcelInfo(parcelUUID);
                            if (!ParcelInfoEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                            }
                            Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                        }
                        bool forSale = false;
                        int handledEvents = 0;
                        int counter = 1;
                        ManualResetEvent DirLandReplyEvent = new ManualResetEvent(false);
                        EventHandler<DirLandReplyEventArgs> DirLandReplyEventArgs =
                            (sender, args) =>
                            {
                                handledEvents += args.DirParcels.Count;
                                Parallel.ForEach(args.DirParcels, o =>
                                {
                                    if (o.ID.Equals(parcelUUID))
                                    {
                                        forSale = o.ForSale;
                                        DirLandReplyEvent.Set();
                                    }
                                });
                                if (((handledEvents - counter)%
                                     LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT).Equals(0))
                                {
                                    ++counter;
                                    Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                        DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue,
                                        handledEvents);
                                }
                                DirLandReplyEvent.Set();
                            };
                        lock (ClientInstanceDirectoryLock)
                        {
                            Client.Directory.DirLandReply += DirLandReplyEventArgs;
                            Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue, handledEvents);
                            if (!DirLandReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                            }
                            Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                        }
                        if (!forSale)
                        {
                            throw new ScriptException(ScriptError.PARCEL_NOT_FOR_SALE);
                        }
                        if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                        }
                        if (Client.Self.Balance < parcel.SalePrice)
                        {
                            throw new ScriptException(ScriptError.INSUFFICIENT_FUNDS);
                        }
                        if (!parcel.SalePrice.Equals(0) &&
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Client.Parcels.Buy(simulator, parcel.LocalID, forGroup, commandGroup.UUID,
                            removeContribution, parcel.Area, parcel.SalePrice);
                    };
                    break;
                case ScriptKeys.PARCELEJECT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                                if (
                                    !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                        GroupPowers.LandEjectAndFreeze,
                                        corradeConfiguration.ServicesTimeout))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                            }
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        bool alsoban;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.BAN)),
                                    message)),
                                out alsoban))
                        {
                            alsoban = false;
                        }
                        Client.Parcels.EjectUser(agentUUID, alsoban);
                    };
                    break;
                case ScriptKeys.PARCELFREEZE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!simulator.IsEstateManager)
                        {
                            if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                            {
                                if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                                if (
                                    !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID,
                                        GroupPowers.LandEjectAndFreeze,
                                        corradeConfiguration.ServicesTimeout))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                            }
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        bool freeze;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FREEZE)), message)),
                                out freeze))
                        {
                            freeze = false;
                        }
                        Client.Parcels.FreezeUser(agentUUID, freeze);
                    };
                    break;
                case ScriptKeys.SETPROFILEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        ManualResetEvent[] AvatarProfileDataEvent =
                        {
                            new ManualResetEvent(false),
                            new ManualResetEvent(false)
                        };
                        Avatar.AvatarProperties properties = new Avatar.AvatarProperties();
                        Avatar.Interests interests = new Avatar.Interests();
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesEventHandler = (sender, args) =>
                        {
                            properties = args.Properties;
                            AvatarProfileDataEvent[0].Set();
                        };
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsEventHandler = (sender, args) =>
                        {
                            interests = args.Interests;
                            AvatarProfileDataEvent[1].Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesEventHandler;
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsEventHandler;
                            Client.Avatars.RequestAvatarProperties(Client.Self.AgentID);
                            if (
                                !WaitHandle.WaitAll(AvatarProfileDataEvent.Select(o => (WaitHandle) o).ToArray(),
                                    (int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesEventHandler;
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PROFILE);
                            }
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesEventHandler;
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsEventHandler;
                        }
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        wasCSVToStructure(fields, ref properties);
                        if (IsSecondLife())
                        {
                            if (Encoding.UTF8.GetByteCount(properties.AboutText) >
                                LINDEN_CONSTANTS.AVATARS.PROFILE.SECOND_LIFE_TEXT_SIZE)
                            {
                                throw new ScriptException(ScriptError.SECOND_LIFE_TEXT_TOO_LARGE);
                            }
                            if (Encoding.UTF8.GetByteCount(properties.FirstLifeText) >
                                LINDEN_CONSTANTS.AVATARS.PROFILE.FIRST_LIFE_TEXT_SIZE)
                            {
                                throw new ScriptException(ScriptError.FIRST_LIFE_TEXT_TOO_LARGE);
                            }
                        }
                        wasCSVToStructure(fields, ref interests);
                        Client.Self.UpdateProfile(properties);
                        Client.Self.UpdateInterests(interests);
                    };
                    break;
                case ScriptKeys.GETPROFILEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        wasAdaptiveAlarm ProfileDataReceivedAlarm =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        Avatar.AvatarProperties properties = new Avatar.AvatarProperties();
                        Avatar.Interests interests = new Avatar.Interests();
                        List<AvatarGroup> groups = new List<AvatarGroup>();
                        AvatarPicksReplyEventArgs picks = null;
                        AvatarClassifiedReplyEventArgs classifieds = null;
                        object LockObject = new object();
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                            interests = args.Interests;
                        };
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                properties = args.Properties;
                            };
                        EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                            lock (LockObject)
                            {
                                groups.AddRange(args.Groups);
                            }
                        };
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                picks = args;
                            };
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                classifieds = args;
                            };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                            Client.Avatars.RequestAvatarProperties(agentUUID);
                            Client.Avatars.RequestAvatarPicks(agentUUID);
                            Client.Avatars.RequestAvatarClassified(agentUUID);
                            if (
                                !ProfileDataReceivedAlarm.Signal.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                    false))
                            {
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                                Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_AVATAR_DATA);
                            }
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                        }
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        List<string> csv = new List<string>();
                        csv.AddRange(GetStructuredData(properties, fields));
                        csv.AddRange(GetStructuredData(interests, fields));
                        csv.AddRange(GetStructuredData(groups, fields));
                        if (picks != null)
                        {
                            csv.AddRange(GetStructuredData(picks, fields));
                        }
                        if (classifieds != null)
                        {
                            csv.AddRange(GetStructuredData(classifieds, fields));
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GIVE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        InventoryItem inventoryItem;
                        switch (item != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.AVATAR:
                                UUID agentUUID;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref agentUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                Client.Inventory.GiveItem(inventoryItem.UUID, inventoryItem.Name,
                                    inventoryItem.AssetType, agentUUID, true);
                                break;
                            case Entity.OBJECT:
                                float range;
                                if (
                                    !float.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)),
                                                message)),
                                        out range))
                                {
                                    range = corradeConfiguration.Range;
                                }
                                Primitive primitive = null;
                                if (
                                    !FindPrimitive(
                                        StringOrUUID(wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message))),
                                        range,
                                        ref primitive, corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout))
                                {
                                    throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                                }
                                Client.Inventory.UpdateTaskInventory(primitive.LocalID, inventoryItem);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.DELETEITEM:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        HashSet<InventoryItem> items =
                            new HashSet<InventoryItem>(FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)))
                                ).Cast<InventoryItem>());
                        if (!items.Any())
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        Parallel.ForEach(items, o =>
                        {
                            switch (o.AssetType)
                            {
                                case AssetType.Folder:
                                    Client.Inventory.MoveFolder(o.UUID,
                                        Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                    break;
                                default:
                                    Client.Inventory.MoveItem(o.UUID,
                                        Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                    break;
                            }
                        });
                    };
                    break;
                case ScriptKeys.EMPTYTRASH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Client.Inventory.EmptyTrash();
                    };
                    break;
                case ScriptKeys.FLY:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Fly(action.Equals(Action.START));
                                break;
                            default:
                                throw new ScriptException(ScriptError.FLY_ACTION_START_OR_STOP);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.ADDPICK:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        UUID textureUUID = UUID.Zero;
                        if (item != null)
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                            }
                            textureUUID = inventoryBaseItem.UUID;
                        }
                        ManualResetEvent AvatarPicksReplyEvent = new ManualResetEvent(false);
                        UUID pickUUID = UUID.Zero;
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.EMPTY_PICK_NAME);
                        }
                        int pickCount = 0;
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksEventHandler = (sender, args) =>
                        {
                            pickCount = args.Picks.Count;
                            KeyValuePair<UUID, string> pick =
                                args.Picks.AsParallel()
                                    .FirstOrDefault(o => o.Value.Equals(name, StringComparison.Ordinal));
                            if (!pick.Equals(default(KeyValuePair<UUID, string>)))
                                pickUUID = pick.Key;
                            AvatarPicksReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPicksReply += AvatarPicksEventHandler;
                            Client.Avatars.RequestAvatarPicks(Client.Self.AgentID);
                            if (!AvatarPicksReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PICKS);
                            }
                            Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                        }
                        string description =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message));
                        if (IsSecondLife())
                        {
                            if (pickUUID.Equals(UUID.Zero) &&
                                pickCount >= LINDEN_CONSTANTS.AVATARS.PICKS.MAXIMUM_PICKS)
                            {
                                throw new ScriptException(ScriptError.MAXIMUM_AMOUNT_OF_PICKS_REACHED);
                            }
                            if (Encoding.UTF8.GetByteCount(description) >
                                LINDEN_CONSTANTS.AVATARS.PICKS.MAXIMUM_PICK_DESCRIPTION_SIZE)
                            {
                                throw new ScriptException(ScriptError.DESCRIPTION_WOULD_EXCEED_MAXIMUM_SIZE);
                            }
                        }
                        if (pickUUID.Equals(UUID.Zero))
                        {
                            pickUUID = UUID.Random();
                        }
                        Client.Self.PickInfoUpdate(pickUUID, false, UUID.Zero, name,
                            Client.Self.GlobalPosition, textureUUID, description);
                    };
                    break;
                case ScriptKeys.DELETEPICK:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        ManualResetEvent AvatarPicksReplyEvent = new ManualResetEvent(false);
                        string input =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(input))
                        {
                            throw new ScriptException(ScriptError.EMPTY_PICK_NAME);
                        }
                        UUID pickUUID = UUID.Zero;
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> pick = args.Picks.AsParallel().FirstOrDefault(
                                o => o.Value.Equals(input, StringComparison.Ordinal));
                            if (!pick.Equals(default(KeyValuePair<UUID, string>)))
                                pickUUID = pick.Key;
                            AvatarPicksReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarPicksReply += AvatarPicksEventHandler;
                            Client.Avatars.RequestAvatarPicks(Client.Self.AgentID);
                            if (!AvatarPicksReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PICKS);
                            }
                            Client.Avatars.AvatarPicksReply -= AvatarPicksEventHandler;
                        }
                        if (pickUUID.Equals(UUID.Zero))
                        {
                            pickUUID = UUID.Random();
                        }
                        Client.Self.PickDelete(pickUUID);
                    };
                    break;
                case ScriptKeys.ADDCLASSIFIED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming) ||
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        UUID textureUUID = UUID.Zero;
                        if (item != null)
                        {
                            InventoryBase inventoryBaseItem =
                                FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                    ).FirstOrDefault();
                            if (inventoryBaseItem == null)
                            {
                                throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                            }
                            textureUUID = inventoryBaseItem.UUID;
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.EMPTY_CLASSIFIED_NAME);
                        }
                        string classifiedDescription =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message));
                        ManualResetEvent AvatarClassifiedReplyEvent = new ManualResetEvent(false);
                        UUID classifiedUUID = UUID.Zero;
                        int classifiedCount = 0;
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedEventHandler = (sender, args) =>
                        {
                            classifiedCount = args.Classifieds.Count;
                            KeyValuePair<UUID, string> classified = args.Classifieds.AsParallel().FirstOrDefault(
                                o =>
                                    o.Value.Equals(name, StringComparison.Ordinal));
                            if (!classified.Equals(default(KeyValuePair<UUID, string>)))
                                classifiedUUID = classified.Key;
                            AvatarClassifiedReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedEventHandler;
                            Client.Avatars.RequestAvatarClassified(Client.Self.AgentID);
                            if (!AvatarClassifiedReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_CLASSIFIEDS);
                            }
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                        }
                        if (IsSecondLife() &&
                            classifiedUUID.Equals(UUID.Zero) &&
                            classifiedCount >= LINDEN_CONSTANTS.AVATARS.CLASSIFIEDS.MAXIMUM_CLASSIFIEDS)
                        {
                            throw new ScriptException(ScriptError.MAXIMUM_AMOUNT_OF_CLASSIFIEDS_REACHED);
                        }
                        if (classifiedUUID.Equals(UUID.Zero))
                        {
                            classifiedUUID = UUID.Random();
                        }
                        int price;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PRICE)), message)),
                                out price))
                        {
                            throw new ScriptException(ScriptError.INVALID_PRICE);
                        }
                        if (price < 0)
                        {
                            throw new ScriptException(ScriptError.INVALID_PRICE);
                        }
                        bool renew;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RENEW)), message)),
                                out renew))
                        {
                            renew = false;
                        }
                        FieldInfo classifiedCategoriesField = typeof (DirectoryManager.ClassifiedCategories).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)),
                                    StringComparison.Ordinal));
                        Client.Self.UpdateClassifiedInfo(classifiedUUID, classifiedCategoriesField != null
                            ? (DirectoryManager.ClassifiedCategories)
                                classifiedCategoriesField.GetValue(null)
                            : DirectoryManager.ClassifiedCategories.Any, textureUUID, price,
                            name, classifiedDescription, renew);
                    };
                    break;
                case ScriptKeys.DELETECLASSIFIED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.EMPTY_CLASSIFIED_NAME);
                        }
                        ManualResetEvent AvatarClassifiedReplyEvent = new ManualResetEvent(false);
                        UUID classifiedUUID = UUID.Zero;
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedEventHandler = (sender, args) =>
                        {
                            KeyValuePair<UUID, string> classified = args.Classifieds.AsParallel().FirstOrDefault(
                                o =>
                                    o.Value.Equals(name, StringComparison.Ordinal));
                            if (!classified.Equals(default(KeyValuePair<UUID, string>)))
                                classifiedUUID = classified.Key;
                            AvatarClassifiedReplyEvent.Set();
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedEventHandler;
                            Client.Avatars.RequestAvatarClassified(Client.Self.AgentID);
                            if (!AvatarClassifiedReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_CLASSIFIEDS);
                            }
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedEventHandler;
                        }
                        if (classifiedUUID.Equals(UUID.Zero))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_CLASSIFIED);
                        }
                        Client.Self.DeleteClassfied(classifiedUUID);
                    };
                    break;
                case ScriptKeys.TOUCH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Client.Self.Touch(primitive.LocalID);
                    };
                    break;
                case ScriptKeys.GRAB:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Vector3 uvCoord;
                        if (!Vector3.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEXTURE)), message)), out uvCoord))
                        {
                            throw new ScriptException(ScriptError.INVALID_TEXTURE_COORDINATES);
                        }
                        Vector3 stCoord;
                        if (!Vector3.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SURFACE)), message)), out stCoord))
                        {
                            throw new ScriptException(ScriptError.INVALID_SURFACE_COORDINATES);
                        }
                        int faceIndex;
                        if (!int.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FACE)), message)), out faceIndex))
                        {
                            throw new ScriptException(ScriptError.INVALID_FACE_SPECIFIED);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                    message)), out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        Vector3 normal;
                        if (
                            !Vector3.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NORMAL)),
                                    message)), out normal))
                        {
                            throw new ScriptException(ScriptError.INVALID_NORMAL_VECTOR);
                        }
                        Vector3 binormal;
                        if (
                            !Vector3.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.BINORMAL)),
                                    message)), out binormal))
                        {
                            throw new ScriptException(ScriptError.INVALID_BINORMAL_VECTOR);
                        }
                        Client.Objects.ClickObject(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, uvCoord, stCoord, faceIndex, position,
                            normal, binormal);
                    };
                    break;
                case ScriptKeys.MODERATE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.ModerateChat,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        bool silence;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SILENCE)),
                                        message)),
                                out silence))
                        {
                            silence = false;
                        }
                        Type type =
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant());
                        switch (type)
                        {
                            case Type.TEXT:
                            case Type.VOICE:
                                Client.Self.ModerateChatSessions(commandGroup.UUID, agentUUID,
                                    wasGetDescriptionFromEnumValue(type),
                                    silence);
                                break;
                            default:
                                throw new ScriptException(ScriptError.TYPE_CAN_BE_VOICE_OR_TEXT);
                        }
                    };
                    break;
                case ScriptKeys.REBAKE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.GETWEARABLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv =
                            new List<string>(GetWearables(Client.Inventory.Store.RootNode)
                                .Select(o => new[]
                                {
                                    o.Value.ToString(),
                                    Client.Inventory.Store[o.Key.ItemID].Name
                                }).SelectMany(o => o));
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.WEAR:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string wearables =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEARABLES)), message));
                        if (string.IsNullOrEmpty(wearables))
                        {
                            throw new ScriptException(ScriptError.EMPTY_WEARABLES);
                        }
                        bool replace;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REPLACE)),
                                        message)),
                                out replace))
                        {
                            replace = true;
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            wearables).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, StringOrUUID(o)
                                        ).AsParallel().FirstOrDefault(p => p is InventoryWearable);
                                if (inventoryBaseItem == null)
                                    return;
                                Wear(inventoryBaseItem as InventoryItem, replace);
                            });
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.UNWEAR:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string wearables =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEARABLES)), message));
                        if (string.IsNullOrEmpty(wearables))
                        {
                            throw new ScriptException(ScriptError.EMPTY_WEARABLES);
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            wearables).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, StringOrUUID(o)
                                        ).AsParallel().FirstOrDefault(p => p is InventoryWearable);
                                if (inventoryBaseItem == null)
                                    return;
                                UnWear(inventoryBaseItem as InventoryItem);
                            });
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.GETATTACHMENTS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> attachments = GetAttachments(
                            corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                            .AsParallel()
                            .Select(o => new[]
                            {
                                o.Value.ToString(),
                                o.Key.Properties.Name
                            }).SelectMany(o => o).ToList();
                        if (attachments.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(attachments));
                        }
                    };
                    break;
                case ScriptKeys.ATTACH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string attachments =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ATTACHMENTS)),
                                    message));
                        if (string.IsNullOrEmpty(attachments))
                        {
                            throw new ScriptException(ScriptError.EMPTY_ATTACHMENTS);
                        }
                        bool replace;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REPLACE)),
                                        message)),
                                out replace))
                        {
                            replace = true;
                        }
                        Dictionary<string, string> items =
                            new Dictionary<string, string>(wasCSVToEnumerable(attachments)
                                .AsParallel()
                                .Select((o, p) => new {o, p})
                                .GroupBy(q => q.p/2, q => q.o)
                                .Select(o => o.ToList())
                                .TakeWhile(o => o.Count%2 == 0)
                                .Where(o => !string.IsNullOrEmpty(o.First()) || !string.IsNullOrEmpty(o.Last()))
                                .ToDictionary(o => o.First(), p => p.Last()));
                        // if this is SecondLife, check that the additional attachments would not exceed the maximum attachment limit
                        if (IsSecondLife())
                        {
                            switch (replace)
                            {
                                case true:
                                    if (
                                        GetAttachments(corradeConfiguration.ServicesTimeout,
                                            corradeConfiguration.DataTimeout)
                                            .Count() + items.Count() -
                                        typeof (AttachmentPoint).GetFields(
                                            BindingFlags.Public | BindingFlags.Static)
                                            .AsParallel().Count(p => !items.ContainsKey(p.Name)) >
                                        LINDEN_CONSTANTS.AVATARS.MAXIMUM_NUMBER_OF_ATTACHMENTS)
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.ATTACHMENTS_WOULD_EXCEED_MAXIMUM_ATTACHMENT_LIMIT));
                                    }
                                    break;
                                default:
                                    if (items.Count +
                                        GetAttachments(corradeConfiguration.ServicesTimeout,
                                            corradeConfiguration.DataTimeout)
                                            .Count() >
                                        LINDEN_CONSTANTS.AVATARS.MAXIMUM_NUMBER_OF_ATTACHMENTS)
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.ATTACHMENTS_WOULD_EXCEED_MAXIMUM_ATTACHMENT_LIMIT));
                                    }
                                    break;
                            }
                        }
                        Parallel.ForEach(items, o =>
                            Parallel.ForEach(
                                typeof (AttachmentPoint).GetFields(BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().Where(
                                        p =>
                                            p.Name.Equals(o.Key, StringComparison.Ordinal)),
                                q =>
                                {
                                    InventoryBase inventoryBaseItem =
                                        FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                            StringOrUUID(o.Value)
                                            )
                                            .AsParallel().FirstOrDefault(
                                                r => r is InventoryObject || r is InventoryAttachment);
                                    if (inventoryBaseItem == null)
                                        return;
                                    Attach(inventoryBaseItem as InventoryItem, (AttachmentPoint) q.GetValue(null),
                                        replace);
                                }));
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.DETACH:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string attachments =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ATTACHMENTS)),
                                    message));
                        if (string.IsNullOrEmpty(attachments))
                        {
                            throw new ScriptException(ScriptError.EMPTY_ATTACHMENTS);
                        }
                        Parallel.ForEach(wasCSVToEnumerable(
                            attachments).AsParallel().Where(o => !string.IsNullOrEmpty(o)), o =>
                            {
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, StringOrUUID(o)
                                        )
                                        .AsParallel().FirstOrDefault(
                                            p =>
                                                p is InventoryObject || p is InventoryAttachment);
                                if (inventoryBaseItem == null)
                                    return;
                                Detach(inventoryBaseItem as InventoryItem);
                            });
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.RETURNPRIMITIVES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        string type =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message));
                        switch (
                            wasGetEnumValueFromDescription<Entity>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                        message)).ToLowerInvariant()))
                        {
                            case Entity.PARCEL:
                                Vector3 position;
                                HashSet<Parcel> parcels = new HashSet<Parcel>();
                                switch (Vector3.TryParse(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                            message)),
                                    out position))
                                {
                                    case false:
                                        // Get all sim parcels
                                        ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                        EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                            (sender, args) => SimParcelsDownloadedEvent.Set();
                                        lock (ClientInstanceParcelsLock)
                                        {
                                            Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                            Client.Parcels.RequestAllSimParcels(simulator);
                                            if (simulator.IsParcelMapFull())
                                            {
                                                SimParcelsDownloadedEvent.Set();
                                            }
                                            if (
                                                !SimParcelsDownloadedEvent.WaitOne(
                                                    (int) corradeConfiguration.ServicesTimeout, false))
                                            {
                                                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                                            }
                                            Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        }
                                        simulator.Parcels.ForEach(o => parcels.Add(o));
                                        break;
                                    case true:
                                        Parcel parcel = null;
                                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                                        {
                                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                                        }
                                        parcels.Add(parcel);
                                        break;
                                }
                                FieldInfo objectReturnTypeField = typeof (ObjectReturnType).GetFields(
                                    BindingFlags.Public |
                                    BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(type
                                                .ToLowerInvariant(),
                                                StringComparison.Ordinal));
                                ObjectReturnType returnType = objectReturnTypeField != null
                                    ? (ObjectReturnType)
                                        objectReturnTypeField
                                            .GetValue(null)
                                    : ObjectReturnType.Other;
                                if (!simulator.IsEstateManager)
                                {
                                    Parallel.ForEach(
                                        parcels.AsParallel().Where(o => !o.OwnerID.Equals(Client.Self.AgentID)), o =>
                                        {
                                            if (!o.IsGroupOwned || !o.GroupID.Equals(commandGroup.UUID))
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                            }
                                            GroupPowers power = new GroupPowers();
                                            switch (returnType)
                                            {
                                                case ObjectReturnType.Other:
                                                    power = GroupPowers.ReturnNonGroup;
                                                    break;
                                                case ObjectReturnType.Group:
                                                    power = GroupPowers.ReturnGroupSet;
                                                    break;
                                                case ObjectReturnType.Owner:
                                                    power = GroupPowers.ReturnGroupOwned;
                                                    break;
                                            }
                                            if (!HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, power,
                                                corradeConfiguration.ServicesTimeout))
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.NO_GROUP_POWER_FOR_COMMAND));
                                            }
                                        });
                                }
                                Parallel.ForEach(parcels,
                                    o =>
                                        Client.Parcels.ReturnObjects(simulator, o.LocalID,
                                            returnType
                                            , new List<UUID> {agentUUID}));

                                break;
                            case Entity.ESTATE:
                                if (!simulator.IsEstateManager)
                                {
                                    throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                                }
                                bool allEstates;
                                if (
                                    !bool.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALL)),
                                                message)),
                                        out allEstates))
                                {
                                    allEstates = false;
                                }
                                FieldInfo estateReturnFlagsField = typeof (EstateTools.EstateReturnFlags).GetFields(
                                    BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(type,
                                                StringComparison.Ordinal));
                                Client.Estate.SimWideReturn(agentUUID, estateReturnFlagsField != null
                                    ? (EstateTools.EstateReturnFlags)
                                        estateReturnFlagsField
                                            .GetValue(null)
                                    : EstateTools.EstateReturnFlags.ReturnScriptedAndOnOthers, allEstates);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEOWNERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Vector3 position;
                        HashSet<Parcel> parcels = new HashSet<Parcel>();
                        switch (Vector3.TryParse(
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)), message)),
                            out position))
                        {
                            case true:
                                Parcel parcel = null;
                                if (!GetParcelAtPosition(simulator, position, ref parcel))
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                                }
                                parcels.Add(parcel);
                                break;
                            default:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(simulator);
                                    if (simulator.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (
                                        !SimParcelsDownloadedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                simulator.Parcels.ForEach(o => parcels.Add(o));
                                break;
                        }
                        Parallel.ForEach(parcels.AsParallel().Where(o => !o.OwnerID.Equals(Client.Self.AgentID)),
                            o =>
                            {
                                if (!o.IsGroupOwned || !o.GroupID.Equals(commandGroup.UUID))
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                                bool permissions = false;
                                Parallel.ForEach(
                                    new HashSet<GroupPowers>
                                    {
                                        GroupPowers.ReturnGroupSet,
                                        GroupPowers.ReturnGroupOwned,
                                        GroupPowers.ReturnNonGroup
                                    }, p =>
                                    {
                                        if (HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, p,
                                            corradeConfiguration.ServicesTimeout))
                                        {
                                            permissions = true;
                                        }
                                    });
                                if (!permissions)
                                {
                                    throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                }
                            });
                        ManualResetEvent ParcelObjectOwnersReplyEvent = new ManualResetEvent(false);
                        Dictionary<string, int> primitives = new Dictionary<string, int>();
                        EventHandler<ParcelObjectOwnersReplyEventArgs> ParcelObjectOwnersEventHandler =
                            (sender, args) =>
                            {
                                //object LockObject = new object();
                                foreach (ParcelManager.ParcelPrimOwners primowner in args.PrimOwners)
                                {
                                    string owner = string.Empty;
                                    if (
                                        !AgentUUIDToName(primowner.OwnerID, corradeConfiguration.ServicesTimeout,
                                            ref owner))
                                        continue;
                                    if (!primitives.ContainsKey(owner))
                                    {
                                        primitives.Add(owner, primowner.Count);
                                        continue;
                                    }
                                    primitives[owner] += primowner.Count;
                                }
                                ParcelObjectOwnersReplyEvent.Set();
                            };
                        foreach (Parcel parcel in parcels)
                        {
                            lock (ClientInstanceParcelsLock)
                            {
                                Client.Parcels.ParcelObjectOwnersReply += ParcelObjectOwnersEventHandler;
                                Client.Parcels.RequestObjectOwners(simulator, parcel.LocalID);
                                if (
                                    !ParcelObjectOwnersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                        false))
                                {
                                    Client.Parcels.ParcelObjectOwnersReply -= ParcelObjectOwnersEventHandler;
                                    throw new ScriptException(ScriptError.TIMEOUT_GETTING_LAND_USERS);
                                }
                                Client.Parcels.ParcelObjectOwnersReply -= ParcelObjectOwnersEventHandler;
                            }
                        }
                        if (!primitives.Any())
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_LAND_USERS);
                        }
                        List<string> data = new List<string>(primitives.AsParallel().Select(
                            p =>
                                wasEnumerableToCSV(new[]
                                {p.Key, p.Value.ToString(CultureInfo.DefaultThreadCurrentCulture)})));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETGROUPDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        OpenMetaverse.Group dataGroup = new OpenMetaverse.Group();
                        if (!RequestGroup(commandGroup.UUID, corradeConfiguration.ServicesTimeout, ref dataGroup))
                        {
                            throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(dataGroup,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETGROUPMEMBERDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        AvatarGroup avatarGroup = new AvatarGroup();
                        wasAdaptiveAlarm AvatarGroupsReceivedEvent =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
                        {
                            AvatarGroupsReceivedEvent.Alarm(corradeConfiguration.DataTimeout);
                            avatarGroup = args.Groups.FirstOrDefault(o => o.GroupID.Equals(commandGroup.UUID));
                        };
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                            Client.Avatars.RequestAvatarProperties(agentUUID);
                            if (
                                !AvatarGroupsReceivedEvent.Signal.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                    false))
                            {
                                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_AVATAR_DATA);
                            }
                            Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                        }
                        List<string> data = new List<string>(GetStructuredData(avatarGroup,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEBODYTYPES:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        CORRADE_CONSTANTS.PRIMTIVE_BODIES primitiveBodies = new CORRADE_CONSTANTS.PRIMTIVE_BODIES();
                        List<string> data = new List<string>(typeof (AssetType).GetFields(BindingFlags.Public |
                                                                                          BindingFlags.Static)
                            .AsParallel().Select(
                                o =>
                                    wasGetStructureMemberDescription(primitiveBodies, o)));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVESHAPEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.PrimData,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVESCULPTDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.Sculpt,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVELIGHTDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.Light,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEFLEXIBLEDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.Flexible,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEPHYSICSDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.PhysicsProps,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEPROPERTIESDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.Properties,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVETEXTUREDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = new Primitive();
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(primitive.Textures,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPARCELDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        List<string> data = new List<string>(GetStructuredData(parcel,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SETPARCELDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                        {
                            if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                            {
                                throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                            }
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message)), ref parcel);
                        if (IsSecondLife())
                        {
                            if (parcel.OtherCleanTime > LINDEN_CONSTANTS.PARCELS.MAXIMUM_AUTO_RETURN_TIME ||
                                parcel.OtherCleanTime < LINDEN_CONSTANTS.PARCELS.MINIMUM_AUTO_RETURN_TIME)
                            {
                                throw new ScriptException(ScriptError.AUTO_RETURN_TIME_OUTSIDE_LIMIT_RANGE);
                            }
                            if (parcel.Name.Length > LINDEN_CONSTANTS.PARCELS.MAXIMUM_NAME_LENGTH)
                            {
                                throw new ScriptException(ScriptError.NAME_TOO_LARGE);
                            }
                            if (parcel.Desc.Length > LINDEN_CONSTANTS.PARCELS.MAXIMUM_DESCRIPTION_LENGTH)
                            {
                                throw new ScriptException(ScriptError.DESCRIPTION_TOO_LARGE);
                            }
                        }
                        parcel.Update(simulator, true);
                    };
                    break;
                case ScriptKeys.GETREGIONPARCELSBOUNDINGBOX:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        // Get all sim parcels
                        ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                        EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                            (sender, args) => SimParcelsDownloadedEvent.Set();
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                            Client.Parcels.RequestAllSimParcels(simulator);
                            if (simulator.IsParcelMapFull())
                            {
                                SimParcelsDownloadedEvent.Set();
                            }
                            if (!SimParcelsDownloadedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                            }
                            Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                        }
                        List<Vector3> csv = new List<Vector3>();
                        simulator.Parcels.ForEach(o => csv.AddRange(new[] {o.AABBMin, o.AABBMax}));
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv.Select(o => o.ToString())));
                        }
                    };
                    break;
                case ScriptKeys.DOWNLOAD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        if (item == null)
                            throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        FieldInfo assetTypeInfo = typeof (AssetType).GetFields(BindingFlags.Public |
                                                                               BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.Ordinal));
                        switch (assetTypeInfo != null)
                        {
                            case false:
                                throw new ScriptException(ScriptError.UNKNOWN_ASSET_TYPE);
                        }
                        AssetType assetType = (AssetType) assetTypeInfo.GetValue(null);
                        InventoryItem inventoryItem = null;
                        UUID itemUUID;
                        // If the asset is of an asset type that can only be retrieved locally or the item is a string
                        // then attempt to resolve the item to an inventory item or else the item cannot be found.
                        switch (
                            assetType.Equals(AssetType.LSLText) || assetType.Equals(AssetType.Notecard) ||
                            item is string)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                itemUUID = inventoryItem.AssetUUID;
                                break;
                            default: // otherwise, just set the the item UUID to the item
                                itemUUID = (UUID) item;
                                break;
                        }
                        byte[] assetData = null;
                        switch (!Client.Assets.Cache.HasAsset(itemUUID))
                        {
                            case true:
                                ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                bool succeeded = false;
                                switch (assetType)
                                {
                                    case AssetType.Mesh:
                                        Client.Assets.RequestMesh(itemUUID,
                                            delegate(bool completed, AssetMesh asset)
                                            {
                                                if (!asset.AssetID.Equals(itemUUID)) return;
                                                succeeded = completed;
                                                if (succeeded)
                                                {
                                                    assetData = asset.MeshData.AsBinary();
                                                }
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                        break;
                                    // All of these can only be fetched if they exist locally.
                                    case AssetType.LSLText:
                                    case AssetType.Notecard:
                                        if (
                                            !HasCorradePermission(commandGroup.Name,
                                                (int) Permissions.Inventory))
                                        {
                                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                                        }
                                        Client.Assets.RequestInventoryAsset(inventoryItem, true,
                                            delegate(AssetDownload transfer, Asset asset)
                                            {
                                                succeeded = transfer.Success;
                                                if (transfer.Success)
                                                {
                                                    assetData = asset.AssetData;
                                                }
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                        break;
                                    // All images go through RequestImage and can be fetched directly from the asset server.
                                    case AssetType.Texture:
                                        Client.Assets.RequestImage(itemUUID, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(itemUUID)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                succeeded = true;
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                        break;
                                    // All of these can be fetched directly from the asset server.
                                    case AssetType.Landmark:
                                    case AssetType.Gesture:
                                    case AssetType.Animation: // Animatn
                                    case AssetType.Sound: // Ogg Vorbis
                                    case AssetType.Clothing:
                                    case AssetType.Bodypart:
                                        Client.Assets.RequestAsset(itemUUID, assetType, true,
                                            delegate(AssetDownload transfer, Asset asset)
                                            {
                                                if (!transfer.AssetID.Equals(itemUUID)) return;
                                                succeeded = transfer.Success;
                                                if (transfer.Success)
                                                {
                                                    assetData = asset.AssetData;
                                                }
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_ASSET_TYPE);
                                }
                                if (!succeeded)
                                {
                                    throw new ScriptException(ScriptError.FAILED_TO_DOWNLOAD_ASSET);
                                }
                                Client.Assets.Cache.SaveAssetToCache(itemUUID, assetData);
                                break;
                            default:
                                assetData = Client.Assets.Cache.GetCachedAssetBytes(itemUUID);
                                break;
                        }
                        // If the asset type was a texture, convert it to the desired format.
                        switch (assetType.Equals(AssetType.Texture))
                        {
                            case true:
                                string format =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                        message));
                                if (!string.IsNullOrEmpty(format))
                                {
                                    PropertyInfo formatProperty = typeof (ImageFormat).GetProperties(
                                        BindingFlags.Public |
                                        BindingFlags.Static)
                                        .AsParallel().FirstOrDefault(
                                            o =>
                                                string.Equals(o.Name, format, StringComparison.Ordinal));
                                    if (formatProperty == null)
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED));
                                    }
                                    ManagedImage managedImage;
                                    if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                    }
                                    using (MemoryStream imageStream = new MemoryStream())
                                    {
                                        try
                                        {
                                            using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                            {
                                                EncoderParameters encoderParameters = new EncoderParameters(1);
                                                encoderParameters.Param[0] =
                                                    new EncoderParameter(Encoder.Quality, 100L);
                                                bitmapImage.Save(imageStream,
                                                    ImageCodecInfo.GetImageDecoders()
                                                        .AsParallel()
                                                        .FirstOrDefault(
                                                            o =>
                                                                o.FormatID.Equals(
                                                                    ((ImageFormat)
                                                                        formatProperty.GetValue(
                                                                            new ImageFormat(Guid.Empty))).Guid)),
                                                    encoderParameters);
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(
                                                    ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                        }
                                        assetData = imageStream.ToArray();
                                    }
                                }
                                break;
                        }
                        // If no path was specificed, then send the data.
                        string path =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                message));
                        if (string.IsNullOrEmpty(path))
                        {
                            result.Add(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                Convert.ToBase64String(assetData));
                            return;
                        }
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        // Otherwise, save it to the specified file.
                        using (StreamWriter sw = new StreamWriter(path, false, Encoding.UTF8))
                        {
                            using (BinaryWriter bw = new BinaryWriter(sw.BaseStream, Encoding.UTF8))
                            {
                                bw.Write(assetData);
                                bw.Flush();
                            }
                            sw.Flush();
                        }
                    };
                    break;
                case ScriptKeys.UPLOAD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                        }
                        uint permissions = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)),
                                    message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                                Parallel.ForEach(
                                    typeof (PermissionMask).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { permissions |= ((uint) q.GetValue(null)); }));
                        FieldInfo assetTypeInfo = typeof (AssetType).GetFields(BindingFlags.Public |
                                                                               BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptKeys.TYPE),
                                            message)),
                                    StringComparison.Ordinal));
                        if (assetTypeInfo == null)
                        {
                            throw new ScriptException(ScriptError.UNKNOWN_ASSET_TYPE);
                        }
                        AssetType assetType = (AssetType) assetTypeInfo.GetValue(null);
                        byte[] data;
                        try
                        {
                            data = Convert.FromBase64String(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                    message)));
                        }
                        catch (Exception)
                        {
                            throw new ScriptException(ScriptError.INVALID_ASSET_DATA);
                        }
                        bool succeeded = false;
                        switch (assetType)
                        {
                            case AssetType.Texture:
                            case AssetType.Sound:
                            case AssetType.Animation:
                                // the holy asset trinity is charged money
                                if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                                {
                                    throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                                }
                                if (!UpdateBalance(corradeConfiguration.ServicesTimeout))
                                {
                                    throw new ScriptException(ScriptError.UNABLE_TO_OBTAIN_MONEY_BALANCE);
                                }
                                if (Client.Self.Balance < Client.Settings.UPLOAD_COST)
                                {
                                    throw new ScriptException(ScriptError.INSUFFICIENT_FUNDS);
                                }
                                switch (assetType)
                                {
                                    case AssetType.Texture:
                                        // If the user did not send a JPEG-2000 Codestream, attempt to convert the data
                                        // and then encode to JPEG-2000 Codestream since that is what Second Life expects.
                                        ManagedImage managedImage;
                                        if (!OpenJPEG.DecodeToImage(data, out managedImage))
                                        {
                                            try
                                            {
                                                using (Image image = (Image) (new ImageConverter().ConvertFrom(data)))
                                                {
                                                    using (Bitmap bitmap = new Bitmap(image))
                                                    {
                                                        data = OpenJPEG.EncodeFromImage(bitmap, true);
                                                    }
                                                }
                                            }
                                            catch (Exception)
                                            {
                                                throw new Exception(
                                                    wasGetDescriptionFromEnumValue(
                                                        ScriptError.UNKNOWN_IMAGE_FORMAT_PROVIDED));
                                            }
                                        }
                                        break;
                                }
                                // now create and upload the asset
                                ManualResetEvent CreateItemFromAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItemFromAsset(data, name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    (InventoryType)
                                        (typeof (InventoryType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o => o.Name.Equals(Enum.GetName(typeof (AssetType), assetType),
                                                    StringComparison.Ordinal))).GetValue(null),
                                    Client.Inventory.FindFolderForType(assetType),
                                    delegate(bool completed, string status, UUID itemID, UUID assetID)
                                    {
                                        succeeded = completed;
                                        CreateItemFromAssetEvent.Set();
                                    });
                                if (!CreateItemFromAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ASSET);
                                }
                                break;
                            case AssetType.Bodypart:
                            case AssetType.Clothing:
                                FieldInfo wearTypeInfo = typeof (MuteType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.WEAR)),
                                                        message)),
                                                StringComparison.Ordinal));
                                if (wearTypeInfo == null)
                                {
                                    throw new ScriptException(ScriptError.UNKNOWN_WEARABLE_TYPE);
                                }
                                UUID wearableUUID = Client.Assets.RequestUpload(assetType, data, false);
                                if (wearableUUID.Equals(UUID.Zero))
                                {
                                    throw new ScriptException(ScriptError.ASSET_UPLOAD_FAILED);
                                }
                                ManualResetEvent CreateWearableEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    wearableUUID, InventoryType.Wearable, (WearableType) wearTypeInfo.GetValue(null),
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        CreateWearableEvent.Set();
                                    });
                                if (!CreateWearableEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                                }
                                break;
                            case AssetType.Landmark:
                                UUID landmarkUUID = Client.Assets.RequestUpload(assetType, data, false);
                                if (landmarkUUID.Equals(UUID.Zero))
                                {
                                    throw new ScriptException(ScriptError.ASSET_UPLOAD_FAILED);
                                }
                                ManualResetEvent CreateLandmarkEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    landmarkUUID, InventoryType.Landmark, PermissionMask.All,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        CreateLandmarkEvent.Set();
                                    });
                                if (!CreateLandmarkEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                                }
                                break;
                            case AssetType.Gesture:
                                ManualResetEvent CreateGestureEvent = new ManualResetEvent(false);
                                InventoryItem newGesture = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.Gesture,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newGesture = createdItem;
                                        CreateGestureEvent.Set();
                                    });
                                if (!CreateGestureEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                                }
                                if (!succeeded)
                                {
                                    throw new ScriptException(ScriptError.UNABLE_TO_CREATE_ITEM);
                                }
                                ManualResetEvent UploadGestureAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUploadGestureAsset(data, newGesture.UUID,
                                    delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                    {
                                        succeeded = completed;
                                        UploadGestureAssetEvent.Set();
                                    });
                                if (!UploadGestureAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ASSET);
                                }
                                break;
                            case AssetType.Notecard:
                                ManualResetEvent CreateNotecardEvent = new ManualResetEvent(false);
                                InventoryItem newNotecard = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.Notecard,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newNotecard = createdItem;
                                        CreateNotecardEvent.Set();
                                    });
                                if (!CreateNotecardEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                                }
                                if (!succeeded)
                                {
                                    throw new ScriptException(ScriptError.UNABLE_TO_CREATE_ITEM);
                                }
                                ManualResetEvent UploadNotecardAssetEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUploadNotecardAsset(data, newNotecard.UUID,
                                    delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                    {
                                        succeeded = completed;
                                        UploadNotecardAssetEvent.Set();
                                    });
                                if (!UploadNotecardAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ASSET);
                                }
                                break;
                            case AssetType.LSLText:
                                ManualResetEvent CreateScriptEvent = new ManualResetEvent(false);
                                InventoryItem newScript = null;
                                Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(assetType),
                                    name,
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                            message)),
                                    assetType,
                                    UUID.Random(), InventoryType.LSL,
                                    permissions == 0 ? PermissionMask.Transfer : (PermissionMask) permissions,
                                    delegate(bool completed, InventoryItem createdItem)
                                    {
                                        succeeded = completed;
                                        newScript = createdItem;
                                        CreateScriptEvent.Set();
                                    });
                                if (!CreateScriptEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                                }
                                ManualResetEvent UpdateScriptEvent = new ManualResetEvent(false);
                                Client.Inventory.RequestUpdateScriptAgentInventory(data, newScript.UUID, true,
                                    delegate(bool completed, string status, bool compiled, List<string> messages,
                                        UUID itemID, UUID assetID)
                                    {
                                        succeeded = completed;
                                        UpdateScriptEvent.Set();
                                    });
                                if (!UpdateScriptEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                {
                                    throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ASSET);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_INVENTORY_TYPE);
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.ASSET_UPLOAD_FAILED);
                        }
                    };
                    break;
                case ScriptKeys.REZ:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        InventoryBase inventoryBaseItem =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)))
                                ).FirstOrDefault();
                        if (inventoryBaseItem == null)
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        if (IsSecondLife() &&
                            position.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_REZ_HEIGHT)
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            rotation = Quaternion.CreateFromEulers(0, 0, 0);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (((uint) parcel.Flags & (uint) ParcelFlags.CreateObjects).Equals(0))
                        {
                            if (!simulator.IsEstateManager)
                            {
                                if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                                {
                                    if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                    {
                                        throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                    }
                                    if (!HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.AllowRez,
                                        corradeConfiguration.ServicesTimeout))
                                    {
                                        throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                    }
                                }
                            }
                        }
                        Client.Inventory.RequestRezFromInventory(simulator, rotation, position,
                            inventoryBaseItem as InventoryItem,
                            commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.DEREZ:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        object folder =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                    message)));
                        InventoryFolder inventoryFolder;
                        switch (folder != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, folder
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.FOLDER_NOT_FOUND);
                                }
                                inventoryFolder = inventoryBaseItem as InventoryFolder;
                                if (inventoryFolder == null)
                                {
                                    throw new ScriptException(ScriptError.FOLDER_NOT_FOUND);
                                }
                                break;
                            default:
                                inventoryFolder =
                                    Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(AssetType.Object)]
                                        .Data as InventoryFolder;
                                break;
                        }
                        FieldInfo deRezDestionationTypeInfo = typeof (DeRezDestination).GetFields(BindingFlags.Public |
                                                                                                  BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.Ordinal));
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Client.Inventory.RequestDeRezToInventory(primitive.LocalID, deRezDestionationTypeInfo != null
                            ? (DeRezDestination)
                                deRezDestionationTypeInfo
                                    .GetValue(null)
                            : DeRezDestination.AgentInventoryTake, inventoryFolder.UUID, UUID.Random());
                    };
                    break;
                case ScriptKeys.CREATEPRIMITIVE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        if (IsSecondLife() &&
                            position.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_REZ_HEIGHT)
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            rotation = Quaternion.CreateFromEulers(0, 0, 0);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (((uint) parcel.Flags & (uint) ParcelFlags.CreateObjects).Equals(0))
                        {
                            if (!simulator.IsEstateManager)
                            {
                                if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                                {
                                    if (!parcel.IsGroupOwned && !parcel.GroupID.Equals(commandGroup.UUID))
                                    {
                                        throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                    }
                                    if (!HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.AllowRez,
                                        corradeConfiguration.ServicesTimeout))
                                    {
                                        throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                                    }
                                }
                            }
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            scale = new Vector3(0.5f, 0.5f, 0.5f);
                        }
                        if (IsSecondLife() &&
                            ((scale.X < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_X ||
                              scale.Y < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Y ||
                              scale.Z < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Z ||
                              scale.X > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_X ||
                              scale.Y > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Y ||
                              scale.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Z)))
                        {
                            throw new ScriptException(ScriptError.SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS);
                        }
                        // build the primitive shape from presets by supplying "type" (or not)...
                        FieldInfo primitiveShapesFieldInfo = typeof (CORRADE_CONSTANTS.PRIMTIVE_BODIES).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.OrdinalIgnoreCase));
                        Primitive.ConstructionData constructionData;
                        switch (primitiveShapesFieldInfo != null)
                        {
                            case true:
                                constructionData = (Primitive.ConstructionData) primitiveShapesFieldInfo.GetValue(null);
                                break;
                            default:
                                // Build the construction data as a default primitive box.
                                constructionData = CORRADE_CONSTANTS.PRIMTIVE_BODIES.CUBE;
                                break;
                        }
                        // ... and overwrite with manual data settings.
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref constructionData);
                        // Get any primitive flags.
                        uint primFlags = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FLAGS)),
                                    message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                                Parallel.ForEach(
                                    typeof (PrimFlags).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { primFlags |= ((uint) q.GetValue(null)); }));

                        // Finally, add the primitive to the simulator.
                        Client.Objects.AddPrim(simulator, constructionData, commandGroup.UUID, position, scale, rotation,
                            (PrimFlags) primFlags);
                    };
                    break;
                case ScriptKeys.CREATETREE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        if (IsSecondLife() &&
                            position.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_REZ_HEIGHT)
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            rotation = Quaternion.CreateFromEulers(0, 0, 0);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                        {
                            throw new ScriptException(ScriptError.PARCEL_MUST_BE_OWNED);
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            scale = new Vector3(0.5f, 0.5f, 0.5f);
                        }
                        if (IsSecondLife() &&
                            ((scale.X < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_X ||
                              scale.Y < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Y ||
                              scale.Z < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Z ||
                              scale.X > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_X ||
                              scale.Y > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Y ||
                              scale.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Z)))
                        {
                            throw new ScriptException(ScriptError.SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS);
                        }
                        bool newTree;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NEW)),
                                        message)),
                                out newTree))
                        {
                            newTree = true;
                        }
                        FieldInfo treeFieldInfo = typeof (Tree).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.OrdinalIgnoreCase));
                        if (treeFieldInfo == null)
                        {
                            throw new ScriptException(ScriptError.UNKNOWN_TREE_TYPE);
                        }
                        // Finally, add the tree to the simulator.
                        Client.Objects.AddTree(simulator, scale, rotation, position, (Tree) treeFieldInfo.GetValue(null),
                            commandGroup.UUID, newTree);
                    };
                    break;
                case ScriptKeys.CREATEGRASS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        if (IsSecondLife() &&
                            position.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_REZ_HEIGHT)
                        {
                            throw new Exception(
                                wasGetDescriptionFromEnumValue(
                                    ScriptError.POSITION_WOULD_EXCEED_MAXIMUM_REZ_ALTITUDE));
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            rotation = Quaternion.CreateFromEulers(0, 0, 0);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        if (!GetParcelAtPosition(simulator, position, ref parcel))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                        }
                        if (!parcel.OwnerID.Equals(Client.Self.AgentID))
                        {
                            throw new ScriptException(ScriptError.PARCEL_MUST_BE_OWNED);
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            scale = new Vector3(0.5f, 0.5f, 0.5f);
                        }
                        if (IsSecondLife() &&
                            ((scale.X < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_X ||
                              scale.Y < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Y ||
                              scale.Z < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Z ||
                              scale.X > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_X ||
                              scale.Y > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Y ||
                              scale.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Z)))
                        {
                            throw new ScriptException(ScriptError.SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS);
                        }
                        FieldInfo grassFieldInfo = typeof (Grass).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.OrdinalIgnoreCase));
                        if (grassFieldInfo == null)
                        {
                            throw new ScriptException(ScriptError.UNKNOWN_GRASS_TYPE);
                        }
                        // Finally, add the grass to the simulator.
                        Client.Objects.AddGrass(simulator, scale, rotation, position,
                            (Grass) grassFieldInfo.GetValue(null),
                            commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.SETSCRIPTRUNNING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                            }
                            entityUUID = UUID.Zero;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                (int) corradeConfiguration.ServicesTimeout).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        switch (item.AssetType)
                        {
                            case AssetType.LSLBytecode:
                            case AssetType.LSLText:
                                break;
                            default:
                                throw new ScriptException(ScriptError.ITEM_IS_NOT_A_SCRIPT);
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                Client.Inventory.RequestSetScriptRunning(primitive.ID, item.UUID,
                                    action.Equals(Action.START));
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                        ManualResetEvent ScriptRunningReplyEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        EventHandler<ScriptRunningReplyEventArgs> ScriptRunningEventHandler = (sender, args) =>
                        {
                            switch (action)
                            {
                                case Action.START:
                                    succeeded = args.IsRunning;
                                    break;
                                case Action.STOP:
                                    succeeded = !args.IsRunning;
                                    break;
                            }
                            ScriptRunningReplyEvent.Set();
                        };
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.ScriptRunningReply += ScriptRunningEventHandler;
                            Client.Inventory.RequestGetScriptRunning(primitive.ID, item.UUID);
                            if (!ScriptRunningReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_SCRIPT_STATE);
                            }
                            Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_SET_SCRIPT_STATE);
                        }
                    };
                    break;
                case ScriptKeys.GETSCRIPTRUNNING:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                            }
                            entityUUID = UUID.Zero;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                (int) corradeConfiguration.ServicesTimeout).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        switch (item.AssetType)
                        {
                            case AssetType.LSLBytecode:
                            case AssetType.LSLText:
                                break;
                            default:
                                throw new ScriptException(ScriptError.ITEM_IS_NOT_A_SCRIPT);
                        }
                        ManualResetEvent ScriptRunningReplyEvent = new ManualResetEvent(false);
                        bool running = false;
                        EventHandler<ScriptRunningReplyEventArgs> ScriptRunningEventHandler = (sender, args) =>
                        {
                            running = args.IsRunning;
                            ScriptRunningReplyEvent.Set();
                        };
                        lock (ClientInstanceInventoryLock)
                        {
                            Client.Inventory.ScriptRunningReply += ScriptRunningEventHandler;
                            Client.Inventory.RequestGetScriptRunning(primitive.ID, item.UUID);
                            if (!ScriptRunningReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_SCRIPT_STATE);
                            }
                            Client.Inventory.ScriptRunningReply -= ScriptRunningEventHandler;
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), running.ToString());
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        List<string> data =
                            new List<string>(Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                (int) corradeConfiguration.ServicesTimeout).AsParallel().Select(o => new[]
                                {
                                    o.Name,
                                    o.UUID.ToString()
                                }).SelectMany(o => o));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEINVENTORYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                            }
                            entityUUID = UUID.Zero;
                        }
                        List<InventoryBase> inventory =
                            Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                (int) corradeConfiguration.ServicesTimeout).ToList();
                        InventoryItem item = !entityUUID.Equals(UUID.Zero)
                            ? inventory.AsParallel().FirstOrDefault(o => o.UUID.Equals(entityUUID)) as InventoryItem
                            : inventory.AsParallel().FirstOrDefault(o => o.Name.Equals(entity)) as InventoryItem;
                        if (item == null)
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(item,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.UPDATEPRIMITIVEINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        string entity =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                message));
                        UUID entityUUID;
                        if (!UUID.TryParse(entity, out entityUUID))
                        {
                            if (string.IsNullOrEmpty(entity))
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                            }
                            entityUUID = UUID.Zero;
                        }
                        InventoryBase inventoryBaseItem;
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ADD:
                                inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                        !entityUUID.Equals(UUID.Zero) ? entityUUID.ToString() : entity
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                Client.Inventory.UpdateTaskInventory(primitive.LocalID,
                                    inventoryBaseItem as InventoryItem);
                                break;
                            case Action.REMOVE:
                                if (entityUUID.Equals(UUID.Zero))
                                {
                                    inventoryBaseItem = Client.Inventory.GetTaskInventory(primitive.ID,
                                        primitive.LocalID,
                                        (int) corradeConfiguration.ServicesTimeout)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.Name.Equals(entity));
                                    if (inventoryBaseItem == null)
                                    {
                                        throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                    }
                                    entityUUID = inventoryBaseItem.UUID;
                                }
                                Client.Inventory.RemoveTaskInventory(primitive.LocalID, entityUUID,
                                    Client.Network.Simulators.FirstOrDefault(
                                        o => o.Handle.Equals(primitive.RegionHandle)));
                                break;
                            case Action.TAKE:
                                inventoryBaseItem = !entityUUID.Equals(UUID.Zero)
                                    ? Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                        (int) corradeConfiguration.ServicesTimeout)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.UUID.Equals(entityUUID))
                                    : Client.Inventory.GetTaskInventory(primitive.ID, primitive.LocalID,
                                        (int) corradeConfiguration.ServicesTimeout)
                                        .AsParallel()
                                        .FirstOrDefault(o => o.Name.Equals(entity));
                                InventoryItem inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                UUID folderUUID;
                                string folder =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                            message));
                                if (string.IsNullOrEmpty(folder) || !UUID.TryParse(folder, out folderUUID))
                                {
                                    folderUUID =
                                        Client.Inventory.Store.Items[
                                            Client.Inventory.FindFolderForType(inventoryItem.AssetType)].Data
                                            .UUID;
                                }
                                Client.Inventory.MoveTaskInventory(primitive.LocalID, inventoryItem.UUID, folderUUID,
                                    Client.Network.Simulators.FirstOrDefault(
                                        o => o.Handle.Equals(primitive.RegionHandle)));
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        InventoryBase inventoryBaseItem =
                            FindInventory<InventoryBase>(Client.Inventory.Store.RootNode,
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)))
                                ).FirstOrDefault();
                        if (inventoryBaseItem == null)
                        {
                            throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(inventoryBaseItem as InventoryItem,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SEARCHINVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        HashSet<AssetType> assetTypes = new HashSet<AssetType>();
                        object LockObject = new object();
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o => Parallel.ForEach(
                                typeof (AssetType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                q =>
                                {
                                    lock (LockObject)
                                    {
                                        assetTypes.Add((AssetType) q.GetValue(null));
                                    }
                                }));
                        string pattern =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATTERN)),
                                message));
                        if (string.IsNullOrEmpty(pattern))
                        {
                            throw new ScriptException(ScriptError.NO_PATTERN_PROVIDED);
                        }
                        Regex search;
                        try
                        {
                            search = new Regex(pattern, RegexOptions.Compiled);
                        }
                        catch
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_COMPILE_REGULAR_EXPRESSION);
                        }
                        List<string> csv = new List<string>();
                        Parallel.ForEach(FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, search
                            ),
                            o =>
                            {
                                InventoryItem inventoryItem = o as InventoryItem;
                                if (inventoryItem == null) return;
                                if (assetTypes.Any() && !assetTypes.Contains(inventoryItem.AssetType))
                                    return;
                                lock (LockObject)
                                {
                                    csv.Add(Enum.GetName(typeof (AssetType), inventoryItem.AssetType));
                                    csv.Add(inventoryItem.Name);
                                    csv.Add(inventoryItem.AssetUUID.ToString());
                                }
                            });
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYPATH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        HashSet<AssetType> assetTypes = new HashSet<AssetType>();
                        object LockObject = new object();
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o => Parallel.ForEach(
                                typeof (AssetType).GetFields(BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                q =>
                                {
                                    lock (LockObject)
                                    {
                                        assetTypes.Add((AssetType) q.GetValue(null));
                                    }
                                }));
                        string pattern =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATTERN)),
                                message));
                        if (string.IsNullOrEmpty(pattern))
                        {
                            throw new ScriptException(ScriptError.NO_PATTERN_PROVIDED);
                        }
                        Regex search;
                        try
                        {
                            search = new Regex(pattern, RegexOptions.Compiled);
                        }
                        catch
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_COMPILE_REGULAR_EXPRESSION);
                        }
                        List<string> csv = new List<string>();
                        Parallel.ForEach(FindInventoryPath<InventoryBase>(Client.Inventory.Store.RootNode,
                            search, new LinkedList<string>()).AsParallel().Select(o => o.Value),
                            o =>
                            {
                                lock (LockObject)
                                {
                                    csv.Add(string.Join(CORRADE_CONSTANTS.PATH_SEPARATOR, o.ToArray()));
                                }
                            });
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETPARTICLESYSTEM:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        StringBuilder particleSystem = new StringBuilder();
                        particleSystem.Append("PSYS_PART_FLAGS, 0");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.InterpColor).Equals(0))
                            particleSystem.Append(" | PSYS_PART_INTERP_COLOR_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.InterpScale).Equals(0))
                            particleSystem.Append(" | PSYS_PART_INTERP_SCALE_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Bounce).Equals(0))
                            particleSystem.Append(" | PSYS_PART_BOUNCE_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Wind).Equals(0))
                            particleSystem.Append(" | PSYS_PART_WIND_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.FollowSrc).Equals(0))
                            particleSystem.Append(" | PSYS_PART_FOLLOW_SRC_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.FollowVelocity).Equals(0))
                            particleSystem.Append(" | PSYS_PART_FOLLOW_VELOCITY_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.TargetPos).Equals(0))
                            particleSystem.Append(" | PSYS_PART_TARGET_POS_MASK");
                        if (!((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.TargetLinear).Equals(0))
                            particleSystem.Append(" | PSYS_PART_TARGET_LINEAR_MASK");
                        if (
                            !((long) primitive.ParticleSys.PartDataFlags &
                              (long) Primitive.ParticleSystem.ParticleDataFlags.Emissive).Equals(0))
                            particleSystem.Append(" | PSYS_PART_EMISSIVE_MASK");
                        particleSystem.Append(",");
                        particleSystem.Append("PSYS_SRC_PATTERN, 0");
                        if (
                            !((long) primitive.ParticleSys.Pattern & (long) Primitive.ParticleSystem.SourcePattern.Drop)
                                .Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_DROP");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.Explode).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_EXPLODE");
                        if (
                            !((long) primitive.ParticleSys.Pattern & (long) Primitive.ParticleSystem.SourcePattern.Angle)
                                .Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.AngleCone).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE_CONE");
                        if (!((long) primitive.ParticleSys.Pattern &
                              (long) Primitive.ParticleSystem.SourcePattern.AngleConeEmpty).Equals(0))
                            particleSystem.Append(" | PSYS_SRC_PATTERN_ANGLE_CONE_EMPTY");
                        particleSystem.Append(",");
                        particleSystem.Append("PSYS_PART_START_ALPHA, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartColor.A) +
                                              ",");
                        particleSystem.Append("PSYS_PART_END_ALPHA, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndColor.A) +
                                              ",");
                        particleSystem.Append("PSYS_PART_START_COLOR, " +
                                              primitive.ParticleSys.PartStartColor.ToRGBString() +
                                              ",");
                        particleSystem.Append("PSYS_PART_END_COLOR, " + primitive.ParticleSys.PartEndColor.ToRGBString() +
                                              ",");
                        particleSystem.Append("PSYS_PART_START_SCALE, <" +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartScaleX) + ", " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartStartScaleY) +
                                              ", 0>, ");
                        particleSystem.Append("PSYS_PART_END_SCALE, <" +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndScaleX) + ", " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartEndScaleY) +
                                              ", 0>, ");
                        particleSystem.Append("PSYS_PART_MAX_AGE, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.PartMaxAge) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_MAX_AGE, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.MaxAge) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_ACCEL, " + primitive.ParticleSys.PartAcceleration +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_PART_COUNT, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0}",
                                                  primitive.ParticleSys.BurstPartCount) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_RADIUS, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstRadius) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_RATE, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstRate) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_SPEED_MIN, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstSpeedMin) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_BURST_SPEED_MAX, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.BurstSpeedMax) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_INNERANGLE, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.InnerAngle) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_OUTERANGLE, " +
                                              string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0:0.00000}",
                                                  primitive.ParticleSys.OuterAngle) +
                                              ",");
                        particleSystem.Append("PSYS_SRC_OMEGA, " + primitive.ParticleSys.AngularVelocity +
                                              ",");
                        particleSystem.Append("PSYS_SRC_TEXTURE, (key)\"" + primitive.ParticleSys.Texture + "\"" +
                                              ",");
                        particleSystem.Append("PSYS_SRC_TARGET_KEY, (key)\"" + primitive.ParticleSys.Target + "\"");
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), particleSystem.ToString());
                    };
                    break;
                case ScriptKeys.CREATENOTECARD:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string text =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEXT)),
                                message));
                        if (IsSecondLife() &&
                            Encoding.UTF8.GetByteCount(text) >
                            LINDEN_CONSTANTS.ASSETS.NOTECARD.MAXIMUM_BODY_LENTH)
                        {
                            throw new ScriptException(ScriptError.NOTECARD_MESSAGE_BODY_TOO_LARGE);
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                        }
                        ManualResetEvent CreateNotecardEvent = new ManualResetEvent(false);
                        bool succeeded = false;
                        InventoryItem newItem = null;
                        Client.Inventory.RequestCreateItem(Client.Inventory.FindFolderForType(AssetType.Notecard),
                            name,
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message)),
                            AssetType.Notecard,
                            UUID.Random(), InventoryType.Notecard, PermissionMask.All,
                            delegate(bool completed, InventoryItem createdItem)
                            {
                                succeeded = completed;
                                newItem = createdItem;
                                CreateNotecardEvent.Set();
                            });
                        if (!CreateNotecardEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                        {
                            throw new ScriptException(ScriptError.TIMEOUT_CREATING_ITEM);
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_CREATE_ITEM);
                        }
                        AssetNotecard blank = new AssetNotecard
                        {
                            BodyText = LINDEN_CONSTANTS.ASSETS.NOTECARD.NEWLINE
                        };
                        blank.Encode();
                        ManualResetEvent UploadBlankNotecardEvent = new ManualResetEvent(false);
                        succeeded = false;
                        Client.Inventory.RequestUploadNotecardAsset(blank.AssetData, newItem.UUID,
                            delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                            {
                                succeeded = completed;
                                UploadBlankNotecardEvent.Set();
                            });
                        if (!UploadBlankNotecardEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                        {
                            throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ITEM);
                        }
                        if (!succeeded)
                        {
                            throw new ScriptException(ScriptError.UNABLE_TO_UPLOAD_ITEM);
                        }
                        if (!string.IsNullOrEmpty(text))
                        {
                            AssetNotecard notecard = new AssetNotecard
                            {
                                BodyText = text
                            };
                            notecard.Encode();
                            ManualResetEvent UploadNotecardDataEvent = new ManualResetEvent(false);
                            succeeded = false;
                            Client.Inventory.RequestUploadNotecardAsset(notecard.AssetData, newItem.UUID,
                                delegate(bool completed, string status, UUID itemUUID, UUID assetUUID)
                                {
                                    succeeded = completed;
                                    UploadNotecardDataEvent.Set();
                                });
                            if (!UploadNotecardDataEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ITEM_DATA);
                            }
                            if (!succeeded)
                            {
                                throw new ScriptException(ScriptError.UNABLE_TO_UPLOAD_ITEM_DATA);
                            }
                        }
                    };
                    break;
                case ScriptKeys.ACTIVATE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        Client.Groups.ActivateGroup(commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.TAG:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant()))
                        {
                            case Action.SET:
                                ManualResetEvent GroupRoleDataReplyEvent = new ManualResetEvent(false);
                                Dictionary<string, UUID> roleData = new Dictionary<string, UUID>();
                                EventHandler<GroupRolesDataReplyEventArgs> Groups_GroupRoleDataReply = (sender, args) =>
                                {
                                    roleData = args.Roles.ToDictionary(o => o.Value.Title, o => o.Value.ID);
                                    GroupRoleDataReplyEvent.Set();
                                };
                                lock (ClientInstanceGroupsLock)
                                {
                                    Client.Groups.GroupRoleDataReply += Groups_GroupRoleDataReply;
                                    Client.Groups.RequestGroupRoles(commandGroup.UUID);
                                    if (
                                        !GroupRoleDataReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Groups.GroupRoleDataReply -= Groups_GroupRoleDataReply;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_ROLES);
                                    }
                                    Client.Groups.GroupRoleDataReply -= Groups_GroupRoleDataReply;
                                }
                                KeyValuePair<string, UUID> role = roleData.AsParallel().FirstOrDefault(
                                    o =>
                                        o.Key.Equals(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TITLE)),
                                                    message)),
                                            StringComparison.Ordinal));
                                switch (!role.Equals(default(KeyValuePair<string, UUID>)))
                                {
                                    case false:
                                        throw new ScriptException(ScriptError.COULD_NOT_FIND_TITLE);
                                }
                                Client.Groups.ActivateTitle(commandGroup.UUID, role.Value);
                                break;
                            case Action.GET:
                                string title = string.Empty;
                                ManualResetEvent GroupTitlesReplyEvent = new ManualResetEvent(false);
                                EventHandler<GroupTitlesReplyEventArgs> GroupTitlesReplyEventHandler = (sender, args) =>
                                {
                                    KeyValuePair<UUID, GroupTitle> pair =
                                        args.Titles.AsParallel().FirstOrDefault(o => o.Value.Selected);
                                    if (!pair.Equals(default(KeyValuePair<UUID, GroupTitle>)))
                                    {
                                        title = pair.Value.Title;
                                    }
                                    GroupTitlesReplyEvent.Set();
                                };
                                lock (ClientInstanceGroupsLock)
                                {
                                    Client.Groups.GroupTitlesReply += GroupTitlesReplyEventHandler;
                                    Client.Groups.RequestGroupTitles(commandGroup.UUID);
                                    if (
                                        !GroupTitlesReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_TITLES);
                                    }
                                    Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                }
                                if (!title.Equals(string.Empty))
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), title);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETTITLES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        List<string> csv = new List<string>();
                        Dictionary<UUID, GroupTitle> groupTitles = new Dictionary<UUID, GroupTitle>();
                        ManualResetEvent GroupTitlesReplyEvent = new ManualResetEvent(false);
                        EventHandler<GroupTitlesReplyEventArgs> GroupTitlesReplyEventHandler = (sender, args) =>
                        {
                            groupTitles = args.Titles;
                            GroupTitlesReplyEvent.Set();
                        };
                        lock (ClientInstanceGroupsLock)
                        {
                            Client.Groups.GroupTitlesReply += GroupTitlesReplyEventHandler;
                            Client.Groups.RequestGroupTitles(commandGroup.UUID);
                            if (!GroupTitlesReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_GROUP_TITLES);
                            }
                            Client.Groups.GroupTitlesReply -= GroupTitlesReplyEventHandler;
                        }
                        foreach (KeyValuePair<UUID, GroupTitle> title in groupTitles)
                        {
                            string roleName = string.Empty;
                            if (
                                !RoleUUIDToName(title.Value.RoleID, commandGroup.UUID,
                                    corradeConfiguration.ServicesTimeout,
                                    corradeConfiguration.DataTimeout,
                                    ref roleName))
                                continue;
                            csv.Add(title.Value.Title);
                            csv.Add(title.Key.ToString());
                            csv.Add(roleName);
                            csv.Add(title.Value.RoleID.ToString());
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.AUTOPILOT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.START:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)), message)),
                                        out position))
                                {
                                    throw new ScriptException(ScriptError.INVALID_POSITION);
                                }
                                uint moveRegionX, moveRegionY;
                                Utils.LongToUInts(Client.Network.CurrentSim.Handle, out moveRegionX, out moveRegionY);
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.AutoPilotCancel();
                                Client.Self.Movement.TurnToward(position, true);
                                Client.Self.AutoPilot(position.X + moveRegionX, position.Y + moveRegionY, position.Z);
                                break;
                            case Action.STOP:
                                Client.Self.AutoPilotCancel();
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_MOVE_ACTION);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.TURNTO:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        Client.Self.Movement.TurnToward(position, true);
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.NUDGE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Direction>(
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DIRECTION)),
                                message))
                                .ToLowerInvariant()))
                        {
                            case Direction.BACK:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_AT_NEG,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None, AgentState.None, true);
                                break;
                            case Direction.FORWARD:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_AT_POS,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.LEFT:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.
                                    AGENT_CONTROL_LEFT_POS, Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.RIGHT:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.
                                    AGENT_CONTROL_LEFT_NEG, Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.UP:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_UP_POS,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            case Direction.DOWN:
                                Client.Self.Movement.SendManualUpdate(AgentManager.ControlFlags.AGENT_CONTROL_UP_NEG,
                                    Client.Self.Movement.Camera.Position,
                                    Client.Self.Movement.Camera.AtAxis, Client.Self.Movement.Camera.LeftAxis,
                                    Client.Self.Movement.Camera.UpAxis,
                                    Client.Self.Movement.BodyRotation, Client.Self.Movement.HeadRotation,
                                    Client.Self.Movement.Camera.Far, AgentFlags.None,
                                    AgentState.None, true);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_DIRECTION);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.SETVIEWEREFFECT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID effectUUID;
                        if (!UUID.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ID)), message)), out effectUUID))
                        {
                            effectUUID = UUID.Random();
                        }
                        Vector3 offset;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(
                                        wasOutput(
                                            wasGetDescriptionFromEnumValue(ScriptKeys.OFFSET)),
                                        message)),
                                out offset))
                        {
                            offset = Client.Self.SimPosition;
                        }
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.BEAM:
                            case ViewerEffectType.POINT:
                            case ViewerEffectType.LOOK:
                                string item = wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message));
                                UUID targetUUID;
                                switch (!string.IsNullOrEmpty(item))
                                {
                                    case true:
                                        float range;
                                        if (
                                            !float.TryParse(
                                                wasInput(wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                                out range))
                                        {
                                            range = corradeConfiguration.Range;
                                        }
                                        Primitive primitive = null;
                                        if (
                                            !FindPrimitive(
                                                StringOrUUID(item),
                                                range,
                                                ref primitive, corradeConfiguration.ServicesTimeout,
                                                corradeConfiguration.DataTimeout))
                                        {
                                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                                        }
                                        targetUUID = primitive.ID;
                                        break;
                                    default:
                                        if (
                                            !UUID.TryParse(
                                                wasInput(wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                                out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref targetUUID))
                                        {
                                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                        }
                                        break;
                                }
                                switch (viewerEffectType)
                                {
                                    case ViewerEffectType.LOOK:
                                        FieldInfo lookAtTypeInfo = typeof (LookAtType).GetFields(BindingFlags.Public |
                                                                                                 BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o =>
                                                    o.Name.Equals(
                                                        wasInput(
                                                            wasKeyValueGet(
                                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                                message)),
                                                        StringComparison.Ordinal));
                                        LookAtType lookAtType = lookAtTypeInfo != null
                                            ? (LookAtType)
                                                lookAtTypeInfo
                                                    .GetValue(null)
                                            : LookAtType.None;
                                        Client.Self.LookAtEffect(Client.Self.AgentID, targetUUID, offset,
                                            lookAtType, effectUUID);
                                        if (LookAtEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                        {
                                            LookAtEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                        }
                                        if (!lookAtType.Equals(LookAtType.None))
                                        {
                                            LookAtEffects.Add(new LookAtEffect
                                            {
                                                Effect = effectUUID,
                                                Offset = offset,
                                                Source = Client.Self.AgentID,
                                                Target = targetUUID,
                                                Type = lookAtType
                                            });
                                        }
                                        break;
                                    case ViewerEffectType.POINT:
                                        FieldInfo pointAtTypeInfo = typeof (PointAtType).GetFields(BindingFlags.Public |
                                                                                                   BindingFlags.Static)
                                            .AsParallel().FirstOrDefault(
                                                o =>
                                                    o.Name.Equals(
                                                        wasInput(
                                                            wasKeyValueGet(
                                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                                message)),
                                                        StringComparison.Ordinal));
                                        PointAtType pointAtType = pointAtTypeInfo != null
                                            ? (PointAtType)
                                                pointAtTypeInfo
                                                    .GetValue(null)
                                            : PointAtType.None;
                                        Client.Self.PointAtEffect(Client.Self.AgentID, targetUUID, offset,
                                            pointAtType, effectUUID);
                                        if (PointAtEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                        {
                                            PointAtEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                        }
                                        if (!pointAtType.Equals(PointAtType.None))
                                        {
                                            PointAtEffects.Add(new PointAtEffect
                                            {
                                                Effect = effectUUID,
                                                Offset = offset,
                                                Source = Client.Self.AgentID,
                                                Target = targetUUID,
                                                Type = pointAtType
                                            });
                                        }
                                        break;
                                    case ViewerEffectType.BEAM:
                                    case ViewerEffectType.SPHERE:
                                        Vector3 RGB;
                                        if (
                                            !Vector3.TryParse(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COLOR)),
                                                        message)),
                                                out RGB))
                                        {
                                            RGB = new Vector3(Client.Settings.DEFAULT_EFFECT_COLOR.R,
                                                Client.Settings.DEFAULT_EFFECT_COLOR.G,
                                                Client.Settings.DEFAULT_EFFECT_COLOR.B);
                                        }
                                        float alpha;
                                        if (!float.TryParse(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALPHA)),
                                                    message)), out alpha))
                                        {
                                            alpha = Client.Settings.DEFAULT_EFFECT_COLOR.A;
                                        }
                                        float duration;
                                        if (
                                            !float.TryParse(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION)),
                                                        message)),
                                                out duration))
                                        {
                                            duration = 1;
                                        }
                                        Color4 color = new Color4(RGB.X, RGB.Y, RGB.Z, alpha);
                                        switch (viewerEffectType)
                                        {
                                            case ViewerEffectType.BEAM:
                                                Client.Self.BeamEffect(Client.Self.AgentID, targetUUID, offset,
                                                    color, duration, effectUUID);
                                                lock (BeamEffectsLock)
                                                {
                                                    if (BeamEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                                    {
                                                        BeamEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                                    }
                                                    BeamEffects.Add(new BeamEffect
                                                    {
                                                        Effect = effectUUID,
                                                        Source = Client.Self.AgentID,
                                                        Target = targetUUID,
                                                        Color = new Vector3(color.R, color.G, color.B),
                                                        Alpha = color.A,
                                                        Duration = duration,
                                                        Offset = offset,
                                                        Termination = DateTime.Now.AddSeconds(duration)
                                                    });
                                                }
                                                break;
                                            case ViewerEffectType.SPHERE:
                                                Client.Self.SphereEffect(offset, color, duration,
                                                    effectUUID);
                                                lock (SphereEffectsLock)
                                                {
                                                    if (SphereEffects.AsParallel().Any(o => o.Effect.Equals(effectUUID)))
                                                    {
                                                        SphereEffects.RemoveWhere(o => o.Effect.Equals(effectUUID));
                                                    }
                                                    SphereEffects.Add(new SphereEffect
                                                    {
                                                        Color = new Vector3(color.R, color.G, color.B),
                                                        Alpha = color.A,
                                                        Duration = duration,
                                                        Effect = effectUUID,
                                                        Offset = offset,
                                                        Termination = DateTime.Now.AddSeconds(duration)
                                                    });
                                                }
                                                break;
                                        }
                                        break;
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_EFFECT);
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), effectUUID.ToString());
                    };
                    break;
                case ScriptKeys.GETVIEWEREFFECTS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.LOOK:
                                Parallel.ForEach(LookAtEffects, o =>
                                {
                                    lock (LockObject)
                                    {
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(o, o.Type),
                                            Enum.GetName(typeof (LookAtType), o.Type)
                                        });
                                    }
                                });
                                break;
                            case ViewerEffectType.POINT:
                                Parallel.ForEach(PointAtEffects, o =>
                                {
                                    lock (LockObject)
                                    {
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                        csv.AddRange(new[]
                                        {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(o, o.Type),
                                            Enum.GetName(typeof (PointAtType), o.Type)
                                        });
                                    }
                                });
                                break;
                            case ViewerEffectType.SPHERE:
                                lock (SphereEffectsLock)
                                {
                                    Parallel.ForEach(SphereEffects, o =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Color), o.Color.ToString()});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Alpha),
                                                o.Alpha.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Duration),
                                                o.Duration.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Termination),
                                                o.Termination.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                        }
                                    });
                                }
                                break;
                            case ViewerEffectType.BEAM:
                                lock (BeamEffectsLock)
                                {
                                    Parallel.ForEach(BeamEffects, o =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Effect), o.Effect.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Offset), o.Offset.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Source), o.Source.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Target), o.Target.ToString()});
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(o, o.Color), o.Color.ToString()});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Alpha),
                                                o.Alpha.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Duration),
                                                o.Duration.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(o, o.Termination),
                                                o.Termination.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                            });
                                        }
                                    });
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_EFFECT);
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.DELETEVIEWEREFFECT:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID effectUUID;
                        if (!UUID.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ID)), message)), out effectUUID))
                        {
                            throw new ScriptException(ScriptError.NO_EFFECT_UUID_PROVIDED);
                        }
                        ViewerEffectType viewerEffectType = wasGetEnumValueFromDescription<ViewerEffectType>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.EFFECT)), message))
                                .ToLowerInvariant());
                        switch (viewerEffectType)
                        {
                            case ViewerEffectType.LOOK:
                                LookAtEffect lookAtEffect =
                                    LookAtEffects.AsParallel().FirstOrDefault(o => o.Effect.Equals(effectUUID));
                                switch (!lookAtEffect.Equals(default(LookAtEffect)))
                                {
                                    case false:
                                        throw new ScriptException(ScriptError.EFFECT_NOT_FOUND);
                                }
                                Client.Self.LookAtEffect(Client.Self.AgentID, lookAtEffect.Target, Vector3.Zero,
                                    LookAtType.None, effectUUID);
                                LookAtEffects.Remove(lookAtEffect);
                                break;
                            case ViewerEffectType.POINT:
                                PointAtEffect pointAtEffect =
                                    PointAtEffects.AsParallel().FirstOrDefault(o => o.Effect.Equals(effectUUID));
                                switch (!pointAtEffect.Equals(default(PointAtEffect)))
                                {
                                    case false:
                                        throw new ScriptException(ScriptError.EFFECT_NOT_FOUND);
                                }
                                Client.Self.PointAtEffect(Client.Self.AgentID, pointAtEffect.Target,
                                    Vector3.Zero,
                                    PointAtType.None, effectUUID);
                                PointAtEffects.Remove(pointAtEffect);
                                break;
                            default:
                                throw new ScriptException(ScriptError.INVALID_VIEWER_EFFECT);
                        }
                    };
                    break;
                case ScriptKeys.STARTPROPOSAL:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Group))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<UUID> currentGroups = Enumerable.Empty<UUID>();
                        if (
                            !GetCurrentGroups(corradeConfiguration.ServicesTimeout,
                                ref currentGroups))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_GET_CURRENT_GROUPS);
                        }
                        if (!currentGroups.ToList().Any(o => o.Equals(commandGroup.UUID)))
                        {
                            throw new ScriptException(ScriptError.NOT_IN_GROUP);
                        }
                        if (
                            !HasGroupPowers(Client.Self.AgentID, commandGroup.UUID, GroupPowers.StartProposal,
                                corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.NO_GROUP_POWER_FOR_COMMAND);
                        }
                        int duration;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DURATION)),
                                        message)),
                                out duration))
                        {
                            throw new ScriptException(ScriptError.INVALID_PROPOSAL_DURATION);
                        }
                        float majority;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MAJORITY)),
                                        message)),
                                out majority))
                        {
                            throw new ScriptException(ScriptError.INVALID_PROPOSAL_MAJORITY);
                        }
                        int quorum;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.QUORUM)), message)),
                                out quorum))
                        {
                            throw new ScriptException(ScriptError.INVALID_PROPOSAL_QUORUM);
                        }
                        string text =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEXT)),
                                message));
                        if (string.IsNullOrEmpty(text))
                        {
                            throw new ScriptException(ScriptError.INVALID_PROPOSAL_TEXT);
                        }
                        Client.Groups.StartProposal(commandGroup.UUID, new GroupProposal
                        {
                            Duration = duration,
                            Majority = majority,
                            Quorum = quorum,
                            VoteText = text
                        });
                    };
                    break;
                case ScriptKeys.MUTE:
                    /* 
                     * Muting and unmuting is masked by the Corrade cache since, although the entries are created, 
                     * respectively removed, the change is indeed propagated to the grid but it takes an unuseful
                     * amount of time for the grid to register them.
                     */
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Mute))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        ManualResetEvent MuteListUpdatedEvent = new ManualResetEvent(false);
                        EventHandler<EventArgs> MuteListUpdatedEventHandler =
                            (sender, args) => MuteListUpdatedEvent.Set();
                        UUID targetUUID;
                        string name;
                        IEnumerable<MuteEntry> mutes = Enumerable.Empty<MuteEntry>();
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.MUTE:
                                // we need an UUID and a name to create a mute
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)), message)),
                                        out targetUUID))
                                {
                                    throw new ScriptException(ScriptError.INVALID_MUTE_TARGET);
                                }

                                name =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                        message));

                                if (string.IsNullOrEmpty(name))
                                    throw new ScriptException(ScriptError.NO_NAME_PROVIDED);

                                // retrieve the current mute list
                                if (!GetMutes(corradeConfiguration.ServicesTimeout, ref mutes))
                                    throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_MUTE_LIST);

                                // check that the mute list does not already exist
                                if (mutes.ToList().AsParallel().Any(o => o.ID.Equals(targetUUID) && o.Name.Equals(name)))
                                    throw new ScriptException(ScriptError.MUTE_ENTRY_ALREADY_EXISTS);

                                // Get the mute type
                                FieldInfo muteTypeInfo = typeof (MuteType).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                    .AsParallel().FirstOrDefault(
                                        o =>
                                            o.Name.Equals(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                        message)),
                                                StringComparison.Ordinal));
                                // ...or assume "Default" mute type from MuteType
                                MuteType muteType = muteTypeInfo != null
                                    ? (MuteType)
                                        muteTypeInfo
                                            .GetValue(null)
                                    : MuteType.ByName;
                                // Get the mute flags - default is "Default" equivalent to 0
                                int muteFlags = 0;
                                Parallel.ForEach(wasCSVToEnumerable(
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FLAGS)),
                                            message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                                    o =>
                                        Parallel.ForEach(
                                            typeof (MuteFlags).GetFields(BindingFlags.Public |
                                                                         BindingFlags.Static)
                                                .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                            q => { muteFlags |= ((int) q.GetValue(null)); }));
                                lock (ClientInstanceSelfLock)
                                {
                                    Client.Self.MuteListUpdated += MuteListUpdatedEventHandler;
                                    Client.Self.UpdateMuteListEntry(muteType, targetUUID, name);
                                    if (!MuteListUpdatedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_UPDATING_MUTE_LIST);
                                    }
                                    Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                }
                                // purge the cache
                                lock (Cache.Locks.MutesCacheLock)
                                {
                                    Cache.MutesCache.Add(new MuteEntry
                                    {
                                        Flags = (MuteFlags) muteFlags,
                                        ID = targetUUID,
                                        Name = name,
                                        Type = muteType
                                    });
                                }
                                break;
                            case Action.UNMUTE:
                                UUID.TryParse(
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)), message)),
                                    out targetUUID);
                                name = wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                        message));

                                if (string.IsNullOrEmpty(name) && targetUUID.Equals(UUID.Zero))
                                    throw new ScriptException(ScriptError.NO_NAME_OR_UUID_PROVIDED);

                                // retrieve the current mute list
                                if (!GetMutes(corradeConfiguration.ServicesTimeout, ref mutes))
                                    throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_MUTE_LIST);

                                // find the mute either by name or by target
                                MuteEntry mute =
                                    mutes.ToList().AsParallel()
                                        .FirstOrDefault(
                                            o =>
                                                (!string.IsNullOrEmpty(name) && o.Name.Equals(name)) ||
                                                (!targetUUID.Equals(UUID.Zero) && o.ID.Equals(targetUUID)));

                                if (mute == null || mute.Equals(default(MuteEntry)))
                                    throw new ScriptException(ScriptError.MUTE_ENTRY_NOT_FOUND);

                                lock (ClientInstanceSelfLock)
                                {
                                    // remove the mute list
                                    Client.Self.MuteListUpdated += MuteListUpdatedEventHandler;
                                    Client.Self.RemoveMuteListEntry(mute.ID, mute.Name);
                                    if (!MuteListUpdatedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_UPDATING_MUTE_LIST);
                                    }
                                    Client.Self.MuteListUpdated -= MuteListUpdatedEventHandler;
                                }
                                // remove the mute from the cache
                                lock (Cache.Locks.MutesCacheLock)
                                {
                                    Cache.MutesCache.Remove(mute);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETMUTES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Mute))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        IEnumerable<MuteEntry> mutes = Enumerable.Empty<MuteEntry>();
                        if (!GetMutes(corradeConfiguration.ServicesTimeout, ref mutes))
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_MUTE_LIST);
                        }
                        List<string> data = mutes.ToList().AsParallel().Select(o => new[]
                        {
                            o.Name,
                            o.ID.ToString(),
                            o.Flags.ToString(),
                            o.Type.ToString()
                        }).SelectMany(o => o).ToList();
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.DATABASE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Database))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        if (string.IsNullOrEmpty(commandGroup.DatabaseFile))
                        {
                            throw new ScriptException(ScriptError.NO_DATABASE_FILE_CONFIGURED);
                        }
                        if (!File.Exists(commandGroup.DatabaseFile))
                        {
                            // create the file and close it
                            File.Create(commandGroup.DatabaseFile).Close();
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.GET:
                                string databaseGetkey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseGetkey))
                                {
                                    throw new ScriptException(ScriptError.NO_DATABASE_KEY_SPECIFIED);
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Add(commandGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[commandGroup.Name])
                                {
                                    string databaseGetValue = wasKeyValueGet(databaseGetkey,
                                        File.ReadAllText(commandGroup.DatabaseFile, Encoding.UTF8));
                                    if (!string.IsNullOrEmpty(databaseGetValue))
                                    {
                                        result.Add(databaseGetkey,
                                            wasInput(databaseGetValue));
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Remove(commandGroup.Name);
                                    }
                                }
                                break;
                            case Action.SET:
                                string databaseSetKey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseSetKey))
                                {
                                    throw new ScriptException(ScriptError.NO_DATABASE_KEY_SPECIFIED);
                                }
                                string databaseSetValue =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.VALUE)),
                                            message));
                                if (string.IsNullOrEmpty(databaseSetValue))
                                {
                                    throw new ScriptException(ScriptError.NO_DATABASE_VALUE_SPECIFIED);
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Add(commandGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[commandGroup.Name])
                                {
                                    string contents = File.ReadAllText(commandGroup.DatabaseFile, Encoding.UTF8);
                                    using (
                                        StreamWriter recreateDatabase = new StreamWriter(commandGroup.DatabaseFile,
                                            false, Encoding.UTF8))
                                    {
                                        recreateDatabase.Write(wasKeyValueSet(databaseSetKey,
                                            databaseSetValue, contents));
                                        recreateDatabase.Flush();
                                        //recreateDatabase.Close();
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Remove(commandGroup.Name);
                                    }
                                }
                                break;
                            case Action.DELETE:
                                string databaseDeleteKey =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.KEY)),
                                            message));
                                if (string.IsNullOrEmpty(databaseDeleteKey))
                                {
                                    throw new ScriptException(ScriptError.NO_DATABASE_KEY_SPECIFIED);
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (!DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Add(commandGroup.Name, new object());
                                    }
                                }
                                lock (DatabaseLocks[commandGroup.Name])
                                {
                                    string contents = File.ReadAllText(commandGroup.DatabaseFile, Encoding.UTF8);
                                    using (
                                        StreamWriter recreateDatabase = new StreamWriter(commandGroup.DatabaseFile,
                                            false, Encoding.UTF8))
                                    {
                                        recreateDatabase.Write(wasKeyValueDelete(databaseDeleteKey, contents));
                                        recreateDatabase.Flush();
                                        //recreateDatabase.Close();
                                    }
                                }
                                lock (DatabaseFileLock)
                                {
                                    if (DatabaseLocks.ContainsKey(commandGroup.Name))
                                    {
                                        DatabaseLocks.Remove(commandGroup.Name);
                                    }
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_DATABASE_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.NOTIFY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Notifications))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string url = wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.URL)),
                                message));
                        string notificationTypes =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                    message))
                                .ToLowerInvariant();
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        object LockObject = new object();
                        HashSet<Notification> groupNotifications = new HashSet<Notification>();
                        switch (action)
                        {
                            case Action.SET:
                            case Action.ADD:
                                if (string.IsNullOrEmpty(url))
                                {
                                    throw new ScriptException(ScriptError.INVALID_URL_PROVIDED);
                                }
                                Uri notifyURL;
                                if (!Uri.TryCreate(url, UriKind.Absolute, out notifyURL))
                                {
                                    throw new ScriptException(ScriptError.INVALID_URL_PROVIDED);
                                }
                                if (string.IsNullOrEmpty(notificationTypes))
                                {
                                    throw new ScriptException(ScriptError.INVALID_NOTIFICATION_TYPES);
                                }
                                Notification notification;
                                lock (GroupNotificationsLock)
                                {
                                    notification =
                                        GroupNotifications.AsParallel().FirstOrDefault(
                                            o =>
                                                o.GroupName.Equals(commandGroup.Name,
                                                    StringComparison.OrdinalIgnoreCase));
                                }
                                // Get any afterburn data.
                                string afterBurnData =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AFTERBURN)),
                                            message));
                                SerializableDictionary<string, string> afterburn =
                                    new SerializableDictionary<string, string>();
                                if (!string.IsNullOrEmpty(afterBurnData))
                                {
                                    HashSet<string> results = new HashSet<string>(wasGetEnumDescriptions<ResultKeys>());
                                    HashSet<string> scripts = new HashSet<string>(wasGetEnumDescriptions<ScriptKeys>());
                                    Parallel.ForEach(wasCSVToEnumerable(afterBurnData)
                                        .AsParallel()
                                        .Select((o, p) => new {o, p})
                                        .GroupBy(q => q.p/2, q => q.o)
                                        .Select(o => o.ToList())
                                        .TakeWhile(o => o.Count%2 == 0)
                                        .Where(o => !string.IsNullOrEmpty(o.First()) || !string.IsNullOrEmpty(o.Last()))
                                        .ToDictionary(o => o.First(), p => p.Last()), o =>
                                        {
                                            // remove keys that are script keys, result keys or invalid key-value pairs
                                            if (string.IsNullOrEmpty(o.Key) || results.Contains(wasInput(o.Key)) ||
                                                scripts.Contains(wasInput(o.Key)) ||
                                                string.IsNullOrEmpty(o.Value))
                                                return;
                                            lock (LockObject)
                                            {
                                                afterburn.Add(o.Key, o.Value);
                                            }
                                        });
                                }
                                // Build any requested data for raw notifications.
                                string fields =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                        message));
                                HashSet<string> data = new HashSet<string>();
                                if (!string.IsNullOrEmpty(fields))
                                {
                                    Parallel.ForEach(
                                        wasCSVToEnumerable(fields).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                                        o =>
                                        {
                                            lock (LockObject)
                                            {
                                                data.Add(o);
                                            }
                                        });
                                }
                                switch (!notification.Equals(default(Notification)))
                                {
                                    case false:
                                        notification = new Notification
                                        {
                                            GroupName = commandGroup.Name,
                                            GroupUUID = commandGroup.UUID,
                                            NotificationDestination =
                                                new SerializableDictionary<Notifications, HashSet<string>>(),
                                            Data = data,
                                            Afterburn = afterburn
                                        };
                                        break;
                                }
                                bool succeeded = true;
                                Parallel.ForEach(wasCSVToEnumerable(
                                    notificationTypes).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                                    (o, state) =>
                                    {
                                        uint notificationValue = (uint) wasGetEnumValueFromDescription<Notifications>(o);
                                        if (!GroupHasNotification(commandGroup.Name, notificationValue))
                                        {
                                            // one of the notification was not allowed, so abort
                                            succeeded = false;
                                            state.Break();
                                        }
                                        notification.Data = data;
                                        notification.Afterburn = afterburn;
                                        switch (
                                            !notification.NotificationDestination.ContainsKey(
                                                (Notifications) notificationValue))
                                        {
                                            case true:
                                                lock (LockObject)
                                                {
                                                    notification.NotificationDestination.Add(
                                                        (Notifications) notificationValue, new HashSet<string> {url});
                                                }
                                                break;
                                            default:
                                                // notification destination is already there
                                                if (notification.NotificationDestination[
                                                    (Notifications) notificationValue].Contains(url))
                                                    break;
                                                switch (action)
                                                {
                                                    case Action.ADD:
                                                        lock (LockObject)
                                                        {
                                                            notification.NotificationDestination[
                                                                (Notifications) notificationValue]
                                                                .Add(url);
                                                        }
                                                        break;
                                                    case Action.SET:
                                                        lock (LockObject)
                                                        {
                                                            notification.NotificationDestination[
                                                                (Notifications) notificationValue] = new HashSet<string>
                                                                {
                                                                    url
                                                                };
                                                        }
                                                        break;
                                                }

                                                break;
                                        }
                                    });
                                switch (succeeded)
                                {
                                    case false:
                                        throw new ScriptException(ScriptError.NOTIFICATION_NOT_ALLOWED);
                                }
                                lock (GroupNotificationsLock)
                                {
                                    // Replace notification.
                                    GroupNotifications.RemoveWhere(
                                        o =>
                                            o.GroupName.Equals(commandGroup.Name, StringComparison.OrdinalIgnoreCase));
                                    GroupNotifications.Add(notification);
                                }
                                break;
                            case Action.REMOVE:
                                lock (GroupNotificationsLock)
                                {
                                    Parallel.ForEach(GroupNotifications, o =>
                                    {
                                        if ((!wasCSVToEnumerable(notificationTypes)
                                            .AsParallel()
                                            .Where(p => !string.IsNullOrEmpty(p))
                                            .Any(p => !(o.NotificationMask &
                                                        (uint) wasGetEnumValueFromDescription<Notifications>(p))
                                                .Equals(0)) &&
                                             !o.NotificationDestination.Values.Any(p => p.Contains(url))) ||
                                            !o.GroupName.Equals(commandGroup.Name, StringComparison.OrdinalIgnoreCase))
                                        {
                                            lock (LockObject)
                                            {
                                                groupNotifications.Add(o);
                                            }
                                            return;
                                        }
                                        SerializableDictionary<Notifications, HashSet<string>>
                                            notificationDestination =
                                                new SerializableDictionary<Notifications, HashSet<string>>();
                                        object NotficatinDestinationLock = new object();
                                        Parallel.ForEach(o.NotificationDestination, p =>
                                        {
                                            switch (!wasCSVToEnumerable(notificationTypes)
                                                .AsParallel()
                                                .Where(q => !string.IsNullOrEmpty(q))
                                                .Any(
                                                    q =>
                                                        wasGetEnumValueFromDescription<Notifications>(q)
                                                            .Equals(p.Key)))
                                            {
                                                case true:
                                                    lock (NotficatinDestinationLock)
                                                    {
                                                        notificationDestination.Add(p.Key, p.Value);
                                                    }
                                                    break;
                                                default:
                                                    HashSet<string> URLs =
                                                        new HashSet<string>(
                                                            p.Value.AsParallel()
                                                                .Where(q => !q.Equals(url, StringComparison.Ordinal)));
                                                    if (!URLs.Any()) return;
                                                    lock (NotficatinDestinationLock)
                                                    {
                                                        notificationDestination.Add(p.Key, URLs);
                                                    }
                                                    break;
                                            }
                                        });
                                        lock (LockObject)
                                        {
                                            groupNotifications.Add(new Notification
                                            {
                                                GroupName = o.GroupName,
                                                GroupUUID = o.GroupUUID,
                                                NotificationDestination = notificationDestination,
                                                Data = o.Data,
                                                Afterburn = o.Afterburn
                                            });
                                        }
                                    });
                                    // Now assign the new notifications.
                                    lock (GroupNotificationsLock)
                                    {
                                        GroupNotifications = groupNotifications;
                                    }
                                }
                                break;
                            case Action.LIST:
                                // If the group has no installed notifications, bail
                                List<string> csv = new List<string>();
                                lock (GroupNotificationsLock)
                                {
                                    Notification groupNotification =
                                        GroupNotifications.AsParallel().FirstOrDefault(
                                            o =>
                                                o.GroupName.Equals(commandGroup.Name,
                                                    StringComparison.OrdinalIgnoreCase));
                                    if (!groupNotification.Equals(default(Notification)))
                                    {
                                        Parallel.ForEach(wasGetEnumDescriptions<Notifications>(), o =>
                                        {
                                            if ((groupNotification.NotificationMask &
                                                 (uint) wasGetEnumValueFromDescription<Notifications>(o)).Equals(0))
                                                return;
                                            lock (LockObject)
                                            {
                                                csv.Add(o);
                                                csv.AddRange(groupNotification.NotificationDestination[
                                                    wasGetEnumValueFromDescription<Notifications>(o)]);
                                            }
                                        });
                                    }
                                }
                                if (csv.Any())
                                {
                                    result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                        wasEnumerableToCSV(csv));
                                }
                                break;
                            case Action.CLEAR:
                                lock (GroupNotificationsLock)
                                {
                                    Parallel.ForEach(GroupNotifications, o =>
                                    {
                                        switch (!o.GroupName.Equals(commandGroup.Name))
                                        {
                                            case false: // this is our group
                                                SerializableDictionary<Notifications, HashSet<string>>
                                                    notificationDestination =
                                                        new SerializableDictionary<Notifications, HashSet<string>>();
                                                Parallel.ForEach(o.NotificationDestination, p =>
                                                {
                                                    switch (!wasCSVToEnumerable(notificationTypes)
                                                        .AsParallel()
                                                        .Where(q => !string.IsNullOrEmpty(q))
                                                        .Any(
                                                            q =>
                                                                wasGetEnumValueFromDescription<Notifications>(q)
                                                                    .Equals(p.Key)))
                                                    {
                                                        case true:
                                                            notificationDestination.Add(p.Key, p.Value);
                                                            break;
                                                    }
                                                });
                                                groupNotifications.Add(new Notification
                                                {
                                                    GroupName = o.GroupName,
                                                    GroupUUID = o.GroupUUID,
                                                    NotificationDestination = notificationDestination,
                                                    Data = o.Data,
                                                    Afterburn = o.Afterburn
                                                });
                                                break;
                                            default: // not our group
                                                groupNotifications.Add(o);
                                                break;
                                        }
                                    });
                                    GroupNotifications = groupNotifications;
                                }
                                break;
                            case Action.PURGE:
                                lock (GroupNotificationsLock)
                                {
                                    Notification groupNotification =
                                        GroupNotifications.AsParallel().FirstOrDefault(
                                            o =>
                                                o.GroupName.Equals(commandGroup.Name,
                                                    StringComparison.OrdinalIgnoreCase));
                                    if (!groupNotification.Equals(default(Notification)))
                                    {
                                        GroupNotifications.Remove(groupNotification);
                                    }
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                        // Now save the state.
                        lock (GroupNotificationsLock)
                        {
                            SaveNotificationState.Invoke();
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOTELEPORTLURE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        UUID sessionUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out sessionUUID))
                        {
                            throw new ScriptException(ScriptError.NO_SESSION_SPECIFIED);
                        }
                        Client.Self.TeleportLureRespond(agentUUID, sessionUUID, wasGetEnumValueFromDescription<Action>(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                message))
                                .ToLowerInvariant()).Equals(Action.ACCEPT));
                    };
                    break;
                case ScriptKeys.GETTELEPORTLURES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (TeleportLureLock)
                        {
                            Parallel.ForEach(TeleportLures, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o, o.Session), o.Session.ToString()});
                                }
                            });
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOSCRIPTPERMISSIONREQUEST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID itemUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)),
                                out itemUUID))
                        {
                            throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        UUID taskUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TASK)), message)),
                                out taskUUID))
                        {
                            throw new ScriptException(ScriptError.NO_TASK_SPECIFIED);
                        }
                        int permissionMask = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)),
                                    message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                                Parallel.ForEach(
                                    typeof (ScriptPermission).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { permissionMask |= ((int) q.GetValue(null)); }));
                        Simulator simulator = Client.Network.Simulators.FirstOrDefault(
                            o => o.Name.Equals(wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                    message)), StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Client.Self.ScriptQuestionReply(simulator, itemUUID, taskUUID,
                            (ScriptPermission) permissionMask);
                    };
                    break;
                case ScriptKeys.GETSCRIPTPERMISSIONREQUESTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (ScriptPermissionRequestLock)
                        {
                            Parallel.ForEach(ScriptPermissionRequests, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Name), o.Name});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Item), o.Item.ToString()});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Task), o.Task.ToString()});
                                    csv.Add(wasGetStructureMemberDescription(o, o.Permission));
                                    csv.AddRange(typeof (ScriptPermission).GetFields(BindingFlags.Public |
                                                                                     BindingFlags.Static)
                                        .AsParallel().Where(
                                            p =>
                                                !(((int) p.GetValue(null) &
                                                   (int) o.Permission)).Equals(0))
                                        .Select(p => p.Name).ToArray());
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Region), o.Region});
                                }
                            });
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOSCRIPTDIALOG:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        int channel;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.CHANNEL)),
                                        message)),
                                out channel))
                        {
                            throw new ScriptException(ScriptError.NO_CHANNEL_SPECIFIED);
                        }
                        int index;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INDEX)), message)),
                                out index))
                        {
                            throw new ScriptException(ScriptError.NO_BUTTON_INDEX_SPECIFIED);
                        }
                        string label =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.BUTTON)),
                                message));
                        if (string.IsNullOrEmpty(label))
                        {
                            throw new ScriptException(ScriptError.NO_BUTTON_SPECIFIED);
                        }
                        UUID itemUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)),
                                out itemUUID))
                        {
                            throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        lock (ScriptDialogLock)
                        {
                            ScriptDialog scriptDialog =
                                ScriptDialogs.FirstOrDefault(
                                    o =>
                                        o.Item.Equals(itemUUID) && o.Channel.Equals(channel) &&
                                        !o.Button.IndexOf(label).Equals(-1));
                            switch (!scriptDialog.Equals(default(ScriptDialog)))
                            {
                                case true:
                                    ScriptDialogs.Remove(scriptDialog);
                                    break;
                                default:
                                    throw new ScriptException(ScriptError.NO_MATCHING_DIALOG_FOUND);
                            }
                        }
                        Client.Self.ReplyToScriptDialog(channel, index, label, itemUUID);
                    };
                    break;
                case ScriptKeys.GETSCRIPTDIALOGS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        object LockObject = new object();
                        lock (ScriptDialogLock)
                        {
                            Parallel.ForEach(ScriptDialogs, o =>
                            {
                                lock (LockObject)
                                {
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Message), o.Message});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.FirstName), o.Agent.FirstName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.LastName), o.Agent.LastName});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(o.Agent, o.Agent.UUID), o.Agent.UUID.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(o, o.Channel),
                                        o.Channel.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                    });
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Name), o.Name});
                                    csv.AddRange(new[] {wasGetStructureMemberDescription(o, o.Item), o.Item.ToString()});
                                    csv.Add(wasGetStructureMemberDescription(o, o.Button));
                                    csv.AddRange(o.Button.ToArray());
                                }
                            });
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.ANIMATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        InventoryItem inventoryItem;
                        switch (item != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.START:
                                Client.Self.AnimationStart(inventoryItem.AssetUUID, true);
                                break;
                            case Action.STOP:
                                Client.Self.AnimationStop(inventoryItem.AssetUUID, true);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ANIMATION_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.PLAYGESTURE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        InventoryItem inventoryItem;
                        switch (item != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        Client.Self.PlayGesture(inventoryItem.UUID);
                    };
                    break;
                case ScriptKeys.GETANIMATIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        Client.Self.SignaledAnimations.ForEach(
                            o =>
                                csv.AddRange(new List<string>
                                {
                                    o.Key.ToString(),
                                    o.Value.ToString(CultureInfo.DefaultThreadCurrentCulture)
                                }));
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.RESTARTREGION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        uint delay;
                        if (
                            !uint.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DELAY)), message))
                                    .ToLowerInvariant(), out delay))
                        {
                            delay = LINDEN_CONSTANTS.ESTATE.REGION_RESTART_DELAY;
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.RESTART:
                                // Manually override Client.Estate.RestartRegion();
                                Client.Estate.EstateOwnerMessage(
                                    LINDEN_CONSTANTS.ESTATE.MESSAGES.REGION_RESTART_MESSAGE,
                                    delay.ToString(CultureInfo.DefaultThreadCurrentCulture));
                                break;
                            case Action.CANCEL:
                                Client.Estate.CancelRestart();
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_RESTART_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.SETREGIONDEBUG:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        bool scripts;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCRIPTS)),
                                        message))
                                    .ToLowerInvariant(), out scripts))
                        {
                            scripts = false;
                        }
                        bool collisions;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.COLLISIONS)),
                                        message))
                                    .ToLowerInvariant(), out collisions))
                        {
                            collisions = false;
                        }
                        bool physics;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PHYSICS)),
                                        message))
                                    .ToLowerInvariant(), out physics))
                        {
                            physics = false;
                        }
                        Client.Estate.SetRegionDebug(!scripts, !collisions, !physics);
                    };
                    break;
                case ScriptKeys.GETREGIONTOP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        Dictionary<UUID, EstateTask> topTasks = new Dictionary<UUID, EstateTask>();
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.SCRIPTS:
                                ManualResetEvent TopScriptsReplyEvent = new ManualResetEvent(false);
                                EventHandler<TopScriptsReplyEventArgs> TopScriptsReplyEventHandler = (sender, args) =>
                                {
                                    topTasks =
                                        args.Tasks.OrderByDescending(o => o.Value.Score)
                                            .ToDictionary(o => o.Key, o => o.Value);
                                    TopScriptsReplyEvent.Set();
                                };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.TopScriptsReply += TopScriptsReplyEventHandler;
                                    Client.Estate.RequestTopScripts();
                                    if (!TopScriptsReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Estate.TopScriptsReply -= TopScriptsReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_TOP_SCRIPTS);
                                    }
                                    Client.Estate.TopScriptsReply -= TopScriptsReplyEventHandler;
                                }
                                break;
                            case Type.COLLIDERS:
                                ManualResetEvent TopCollidersReplyEvent = new ManualResetEvent(false);
                                EventHandler<TopCollidersReplyEventArgs> TopCollidersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        topTasks =
                                            args.Tasks.OrderByDescending(o => o.Value.Score)
                                                .ToDictionary(o => o.Key, o => o.Value);
                                        TopCollidersReplyEvent.Set();
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.TopCollidersReply += TopCollidersReplyEventHandler;
                                    Client.Estate.RequestTopScripts();
                                    if (
                                        !TopCollidersReplyEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Estate.TopCollidersReply -= TopCollidersReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_TOP_SCRIPTS);
                                    }
                                    Client.Estate.TopCollidersReply -= TopCollidersReplyEventHandler;
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_TOP_TYPE);
                        }
                        int amount;
                        if (
                            !int.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AMOUNT)), message)),
                                out amount))
                        {
                            amount = topTasks.Count;
                        }
                        List<string> data = new List<string>(topTasks.Take(amount).Select(o => new[]
                        {
                            o.Value.Score.ToString(CultureInfo.DefaultThreadCurrentCulture),
                            o.Value.TaskName,
                            o.Key.ToString(),
                            o.Value.OwnerName,
                            o.Value.Position.ToString()
                        }).SelectMany(o => o));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SETESTATELIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        bool allEstates;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ALL)),
                                    message)),
                                out allEstates))
                        {
                            allEstates = false;
                        }
                        List<UUID> estateList = new List<UUID>();
                        wasAdaptiveAlarm EstateListReceivedAlarm =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        UUID targetUUID;
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.BAN:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref targetUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        // if this is SecondLife check that we would not exeed the maximum amount of bans
                                        if (IsSecondLife())
                                        {
                                            EventHandler<EstateBansReplyEventArgs> EstateBansReplyEventHandler =
                                                (sender, args) =>
                                                {
                                                    EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                                    switch (args.Banned.Any())
                                                    {
                                                        case true:
                                                            estateList.AddRange(args.Banned);
                                                            break;
                                                        default:
                                                            EstateListReceivedAlarm.Signal.Set();
                                                            break;
                                                    }
                                                };
                                            lock (ClientInstanceEstateLock)
                                            {
                                                Client.Estate.EstateBansReply += EstateBansReplyEventHandler;
                                                Client.Estate.RequestInfo();
                                                if (
                                                    !EstateListReceivedAlarm.Signal.WaitOne((int)
                                                        corradeConfiguration.ServicesTimeout,
                                                        false))
                                                {
                                                    Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                                }
                                                Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                            }
                                            lock (ClientInstanceNetworkLock)
                                            {
                                                if (estateList.Count >= LINDEN_CONSTANTS.ESTATE.MAXIMUM_BAN_LIST_LENGTH)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.MAXIMUM_BAN_LIST_LENGTH_REACHED));
                                                }
                                            }
                                        }
                                        Client.Estate.BanUser(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.UnbanUser(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST_ACTION);
                                }
                                break;
                            case Type.GROUP:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                message)),
                                        out targetUUID) && !GroupNameToUUID(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                                    message)),
                                            corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                            ref targetUUID))
                                {
                                    throw new ScriptException(ScriptError.GROUP_NOT_FOUND);
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        if (IsSecondLife())
                                        {
                                            EventHandler<EstateGroupsReplyEventArgs> EstateGroupsReplyEvenHandler =
                                                (sender, args) =>
                                                {
                                                    EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                                    switch (args.AllowedGroups.Any())
                                                    {
                                                        case true:
                                                            estateList.AddRange(args.AllowedGroups);
                                                            break;
                                                        default:
                                                            EstateListReceivedAlarm.Signal.Set();
                                                            break;
                                                    }
                                                };
                                            lock (ClientInstanceEstateLock)
                                            {
                                                Client.Estate.EstateGroupsReply += EstateGroupsReplyEvenHandler;
                                                Client.Estate.RequestInfo();
                                                if (
                                                    !EstateListReceivedAlarm.Signal.WaitOne((int)
                                                        corradeConfiguration.ServicesTimeout, false))
                                                {
                                                    Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                                }
                                                Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                            }
                                            lock (ClientInstanceNetworkLock)
                                            {
                                                if (estateList.Count >=
                                                    LINDEN_CONSTANTS.ESTATE.MAXIMUM_GROUP_LIST_LENGTH)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.MAXIMUM_GROUP_LIST_LENGTH_REACHED));
                                                }
                                            }
                                        }
                                        Client.Estate.AddAllowedGroup(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveAllowedGroup(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST_ACTION);
                                }
                                break;
                            case Type.USER:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref targetUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        if (IsSecondLife())
                                        {
                                            EventHandler<EstateUsersReplyEventArgs> EstateUsersReplyEventHandler =
                                                (sender, args) =>
                                                {
                                                    EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                                    switch (args.AllowedUsers.Any())
                                                    {
                                                        case true:
                                                            estateList.AddRange(args.AllowedUsers);
                                                            break;
                                                        default:
                                                            EstateListReceivedAlarm.Signal.Set();
                                                            break;
                                                    }
                                                };
                                            lock (ClientInstanceEstateLock)
                                            {
                                                Client.Estate.EstateUsersReply += EstateUsersReplyEventHandler;
                                                Client.Estate.RequestInfo();
                                                if (
                                                    !EstateListReceivedAlarm.Signal.WaitOne((int)
                                                        corradeConfiguration.ServicesTimeout, false))
                                                {
                                                    Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                                }
                                                Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                            }
                                            lock (ClientInstanceNetworkLock)
                                            {
                                                if (estateList.Count >= LINDEN_CONSTANTS.ESTATE.MAXIMUM_USER_LIST_LENGTH)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.MAXIMUM_USER_LIST_LENGTH_REACHED));
                                                }
                                            }
                                        }
                                        Client.Estate.AddAllowedUser(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveAllowedUser(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST_ACTION);
                                }
                                break;
                            case Type.MANAGER:
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out targetUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref targetUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                switch (
                                    wasGetEnumValueFromDescription<Action>(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                            .ToLowerInvariant()))
                                {
                                    case Action.ADD:
                                        if (IsSecondLife())
                                        {
                                            EventHandler<EstateManagersReplyEventArgs> EstateManagersReplyEventHandler =
                                                (sender, args) =>
                                                {
                                                    EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                                    switch (args.Managers.Any())
                                                    {
                                                        case true:
                                                            estateList.AddRange(args.Managers);
                                                            break;
                                                        default:
                                                            EstateListReceivedAlarm.Signal.Set();
                                                            break;
                                                    }
                                                };
                                            lock (ClientInstanceEstateLock)
                                            {
                                                Client.Estate.EstateManagersReply += EstateManagersReplyEventHandler;
                                                Client.Estate.RequestInfo();
                                                if (
                                                    !EstateListReceivedAlarm.Signal.WaitOne((int)
                                                        corradeConfiguration.ServicesTimeout, false))
                                                {
                                                    Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST));
                                                }
                                                Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                            }
                                            lock (ClientInstanceNetworkLock)
                                            {
                                                if (estateList.Count >=
                                                    LINDEN_CONSTANTS.ESTATE.MAXIMUM_MANAGER_LIST_LENGTH)
                                                {
                                                    throw new Exception(
                                                        wasGetDescriptionFromEnumValue(
                                                            ScriptError.MAXIMUM_MANAGER_LIST_LENGTH_REACHED));
                                                }
                                            }
                                        }
                                        Client.Estate.AddEstateManager(targetUUID, allEstates);
                                        break;
                                    case Action.REMOVE:
                                        Client.Estate.RemoveEstateManager(targetUUID, allEstates);
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST_ACTION);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST);
                        }
                    };
                    break;
                case ScriptKeys.GETESTATELIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        if (!Client.Network.CurrentSim.IsEstateManager)
                        {
                            throw new ScriptException(ScriptError.NO_LAND_RIGHTS);
                        }
                        List<UUID> estateList = new List<UUID>();
                        wasAdaptiveAlarm EstateListReceivedAlarm =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.BAN:
                                EventHandler<EstateBansReplyEventArgs> EstateBansReplyEventHandler = (sender, args) =>
                                {
                                    EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                    switch (args.Banned.Any())
                                    {
                                        case true:
                                            estateList.AddRange(args.Banned);
                                            break;
                                        default:
                                            EstateListReceivedAlarm.Signal.Set();
                                            break;
                                    }
                                };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateBansReply += EstateBansReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (
                                        !EstateListReceivedAlarm.Signal.WaitOne(
                                            (int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST);
                                    }
                                    Client.Estate.EstateBansReply -= EstateBansReplyEventHandler;
                                }
                                break;
                            case Type.GROUP:
                                EventHandler<EstateGroupsReplyEventArgs> EstateGroupsReplyEvenHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        switch (args.AllowedGroups.Any())
                                        {
                                            case true:
                                                estateList.AddRange(args.AllowedGroups);
                                                break;
                                            default:
                                                EstateListReceivedAlarm.Signal.Set();
                                                break;
                                        }
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateGroupsReply += EstateGroupsReplyEvenHandler;
                                    Client.Estate.RequestInfo();
                                    if (
                                        !EstateListReceivedAlarm.Signal.WaitOne(
                                            (int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST);
                                    }
                                    Client.Estate.EstateGroupsReply -= EstateGroupsReplyEvenHandler;
                                }
                                break;
                            case Type.MANAGER:
                                EventHandler<EstateManagersReplyEventArgs> EstateManagersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        switch (args.Managers.Any())
                                        {
                                            case true:
                                                estateList.AddRange(args.Managers);
                                                break;
                                            default:
                                                EstateListReceivedAlarm.Signal.Set();
                                                break;
                                        }
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateManagersReply += EstateManagersReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (
                                        !EstateListReceivedAlarm.Signal.WaitOne(
                                            (int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST);
                                    }
                                    Client.Estate.EstateManagersReply -= EstateManagersReplyEventHandler;
                                }
                                break;
                            case Type.USER:
                                EventHandler<EstateUsersReplyEventArgs> EstateUsersReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        EstateListReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        switch (args.AllowedUsers.Any())
                                        {
                                            case true:
                                                estateList.AddRange(args.AllowedUsers);
                                                break;
                                            default:
                                                EstateListReceivedAlarm.Signal.Set();
                                                break;
                                        }
                                    };
                                lock (ClientInstanceEstateLock)
                                {
                                    Client.Estate.EstateUsersReply += EstateUsersReplyEventHandler;
                                    Client.Estate.RequestInfo();
                                    if (
                                        !EstateListReceivedAlarm.Signal.WaitOne(
                                            (int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_ESTATE_LIST);
                                    }
                                    Client.Estate.EstateUsersReply -= EstateUsersReplyEventHandler;
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ESTATE_LIST);
                        }
                        List<string> data = new List<string>(estateList.ConvertAll(o => o.ToString()));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Avatar avatar =
                            GetAvatars(range, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                                .FirstOrDefault(o => o.ID.Equals(agentUUID));
                        if (avatar == null)
                            throw new ScriptException(ScriptError.AVATAR_NOT_IN_RANGE);
                        wasAdaptiveAlarm ProfileDataReceivedAlarm =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        object LockObject = new object();
                        EventHandler<AvatarInterestsReplyEventArgs> AvatarInterestsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                            avatar.ProfileInterests = args.Interests;
                        };
                        EventHandler<AvatarPropertiesReplyEventArgs> AvatarPropertiesReplyEventHandler =
                            (sender, args) =>
                            {
                                ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                                avatar.ProfileProperties = args.Properties;
                            };
                        EventHandler<AvatarGroupsReplyEventArgs> AvatarGroupsReplyEventHandler = (sender, args) =>
                        {
                            ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                            lock (LockObject)
                            {
                                avatar.Groups.AddRange(args.Groups.Select(o => o.GroupID));
                            }
                        };
                        EventHandler<AvatarPicksReplyEventArgs> AvatarPicksReplyEventHandler =
                            (sender, args) => ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                        EventHandler<AvatarClassifiedReplyEventArgs> AvatarClassifiedReplyEventHandler =
                            (sender, args) => ProfileDataReceivedAlarm.Alarm(corradeConfiguration.DataTimeout);
                        lock (ClientInstanceAvatarsLock)
                        {
                            Client.Avatars.AvatarInterestsReply += AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply += AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply += AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply += AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply += AvatarClassifiedReplyEventHandler;
                            Client.Avatars.RequestAvatarProperties(agentUUID);
                            Client.Avatars.RequestAvatarPicks(agentUUID);
                            Client.Avatars.RequestAvatarClassified(agentUUID);
                            if (
                                !ProfileDataReceivedAlarm.Signal.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                    false))
                            {
                                Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                                Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                                Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                                Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                                Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_AVATAR_DATA);
                            }
                            Client.Avatars.AvatarInterestsReply -= AvatarInterestsReplyEventHandler;
                            Client.Avatars.AvatarPropertiesReply -= AvatarPropertiesReplyEventHandler;
                            Client.Avatars.AvatarGroupsReply -= AvatarGroupsReplyEventHandler;
                            Client.Avatars.AvatarPicksReply -= AvatarPicksReplyEventHandler;
                            Client.Avatars.AvatarClassifiedReply -= AvatarClassifiedReplyEventHandler;
                        }
                        List<string> data = new List<string>(GetStructuredData(avatar,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARPOSITIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        Entity entity = wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant());
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Parcel parcel = null;
                        switch (entity)
                        {
                            case Entity.REGION:
                                break;
                            case Entity.PARCEL:
                                if (
                                    !GetParcelAtPosition(simulator, position, ref parcel))
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                        List<string> csv = new List<string>();
                        Dictionary<UUID, Vector3> avatarPositions = new Dictionary<UUID, Vector3>();
                        simulator.AvatarPositions.ForEach(o => avatarPositions.Add(o.Key, o.Value));
                        foreach (KeyValuePair<UUID, Vector3> p in avatarPositions)
                        {
                            string name = string.Empty;
                            if (
                                !AgentUUIDToName(p.Key, corradeConfiguration.ServicesTimeout,
                                    ref name))
                                continue;
                            switch (entity)
                            {
                                case Entity.REGION:
                                    break;
                                case Entity.PARCEL:
                                    if (parcel == null) return;
                                    Parcel avatarParcel = null;
                                    if (!GetParcelAtPosition(simulator, p.Value, ref avatarParcel))
                                        continue;
                                    if (!avatarParcel.LocalID.Equals(parcel.LocalID)) continue;
                                    break;
                            }
                            csv.Add(name);
                            csv.Add(p.Key.ToString());
                            csv.Add(p.Value.ToString());
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETMAPAVATARPOSITIONS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        if (string.IsNullOrEmpty(region))
                        {
                            region = Client.Network.CurrentSim.Name;
                        }
                        ulong regionHandle = 0;
                        ManualResetEvent GridRegionEvent = new ManualResetEvent(false);
                        EventHandler<GridRegionEventArgs> GridRegionEventHandler = (sender, args) =>
                        {
                            if (!args.Region.Name.Equals(region, StringComparison.InvariantCultureIgnoreCase))
                                return;
                            regionHandle = args.Region.RegionHandle;
                            GridRegionEvent.Set();
                        };
                        lock (ClientInstanceGridLock)
                        {
                            Client.Grid.GridRegion += GridRegionEventHandler;
                            Client.Grid.RequestMapRegion(region, GridLayerType.Objects);
                            if (!GridRegionEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Grid.GridRegion -= GridRegionEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_REGION);
                            }
                            Client.Grid.GridRegion -= GridRegionEventHandler;
                        }
                        if (regionHandle.Equals(0))
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        HashSet<MapItem> mapItems =
                            new HashSet<MapItem>(Client.Grid.MapItems(regionHandle, GridItemType.AgentLocations,
                                GridLayerType.Objects, (int) corradeConfiguration.ServicesTimeout));
                        if (!mapItems.Any())
                        {
                            throw new ScriptException(ScriptError.NO_MAP_ITEMS_FOUND);
                        }
                        List<string> data =
                            new List<string>(mapItems.AsParallel()
                                .Where(o => (o as MapAgentLocation) != null)
                                .Select(o => new[]
                                {
                                    ((MapAgentLocation) o).AvatarCount.ToString(CultureInfo.DefaultThreadCurrentCulture),
                                    new Vector3(o.LocalX, o.LocalY, 0).ToString()
                                }).SelectMany(o => o));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETSELFDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> data = new List<string>(GetStructuredData(Client.Self,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.DISPLAYNAME:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string previous = string.Empty;
                        Client.Avatars.GetDisplayNames(new List<UUID> {Client.Self.AgentID},
                            (succeded, names, IDs) =>
                            {
                                if (!succeded || names.Length < 1)
                                {
                                    throw new ScriptException(ScriptError.FAILED_TO_GET_DISPLAY_NAME);
                                }
                                previous = names[0].DisplayName;
                            });
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.GET:
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), previous);
                                break;
                            case Action.SET:
                                string name =
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                            message));
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                                }
                                if (IsSecondLife() &&
                                    (name.Length > LINDEN_CONSTANTS.AVATARS.MAXIMUM_DISPLAY_NAME_CHARACTERS ||
                                     name.Length < LINDEN_CONSTANTS.AVATARS.MINIMUM_DISPLAY_NAME_CHARACTERS))
                                {
                                    throw new Exception(
                                        wasGetDescriptionFromEnumValue(
                                            ScriptError.TOO_MANY_OR_TOO_FEW_CHARACTERS_FOR_DISPLAY_NAME));
                                }
                                bool succeeded = true;
                                ManualResetEvent SetDisplayNameEvent = new ManualResetEvent(false);
                                EventHandler<SetDisplayNameReplyEventArgs> SetDisplayNameEventHandler =
                                    (sender, args) =>
                                    {
                                        succeeded = args.Status.Equals(LINDEN_CONSTANTS.AVATARS.SET_DISPLAY_NAME_SUCCESS);
                                        SetDisplayNameEvent.Set();
                                    };
                                lock (ClientInstanceSelfLock)
                                {
                                    Client.Self.SetDisplayNameReply += SetDisplayNameEventHandler;
                                    Client.Self.SetDisplayName(previous, name);
                                    if (!SetDisplayNameEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Self.SetDisplayNameReply -= SetDisplayNameEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_WAITING_FOR_ESTATE_LIST);
                                    }
                                    Client.Self.SetDisplayNameReply -= SetDisplayNameEventHandler;
                                }
                                if (!succeeded)
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_SET_DISPLAY_NAME);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETINVENTORYOFFERS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        object LockObject = new object();
                        List<string> csv = new List<string>();
                        lock (InventoryOffersLock)
                        {
                            Parallel.ForEach(InventoryOffers, o =>
                            {
                                List<string> name =
                                    new List<string>(
                                        GetAvatarNames(o.Key.Offer.FromAgentName));
                                lock (LockObject)
                                {
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), name.First()});
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME), name.Last()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetDescriptionFromEnumValue(ScriptKeys.TYPE),
                                        o.Key.AssetType.ToString()
                                    });
                                    csv.AddRange(new[]
                                    {wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE), o.Key.Offer.Message});
                                    csv.AddRange(new[]
                                    {
                                        wasGetDescriptionFromEnumValue(ScriptKeys.SESSION),
                                        o.Key.Offer.IMSessionID.ToString()
                                    });
                                }
                            });
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOINVENTORYOFFER:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID session;
                        if (
                            !UUID.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SESSION)),
                                        message)),
                                out session))
                        {
                            throw new ScriptException(ScriptError.NO_SESSION_SPECIFIED);
                        }
                        lock (InventoryOffersLock)
                        {
                            if (!InventoryOffers.AsParallel().Any(o => o.Key.Offer.IMSessionID.Equals(session)))
                            {
                                throw new ScriptException(ScriptError.INVENTORY_OFFER_NOT_FOUND);
                            }
                        }
                        KeyValuePair<InventoryObjectOfferedEventArgs, ManualResetEvent> offer;
                        lock (InventoryOffersLock)
                        {
                            offer =
                                InventoryOffers.AsParallel()
                                    .FirstOrDefault(o => o.Key.Offer.IMSessionID.Equals(session));
                        }
                        object folder =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                    message)));
                        InventoryFolder inventoryFolder;
                        switch (folder != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, folder
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.FOLDER_NOT_FOUND);
                                }
                                inventoryFolder = inventoryBaseItem as InventoryFolder;
                                if (inventoryFolder == null)
                                {
                                    throw new ScriptException(ScriptError.FOLDER_NOT_FOUND);
                                }
                                break;
                            default:
                                inventoryFolder =
                                    Client.Inventory.Store.Items[Client.Inventory.FindFolderForType(offer.Key.AssetType)
                                        ]
                                        .Data as InventoryFolder;
                                break;
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ACCEPT:
                                lock (InventoryOffersLock)
                                {
                                    if (!inventoryFolder.UUID.Equals(UUID.Zero))
                                    {
                                        offer.Key.FolderID = inventoryFolder.UUID;
                                    }
                                    offer.Key.Accept = true;
                                    offer.Value.Set();
                                }
                                break;
                            case Action.DECLINE:
                                lock (InventoryOffersLock)
                                {
                                    offer.Key.Accept = false;
                                    offer.Value.Set();
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDSLIST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        Client.Friends.FriendList.ForEach(o =>
                        {
                            csv.Add(o.Name);
                            csv.Add(o.UUID.ToString());
                        });
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDSHIPREQUESTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> csv = new List<string>();
                        Client.Friends.FriendRequests.ForEach(o =>
                        {
                            string name = string.Empty;
                            if (
                                !AgentUUIDToName(o.Key, corradeConfiguration.ServicesTimeout,
                                    ref name))
                            {
                                return;
                            }
                            csv.Add(name);
                            csv.Add(o.Key.ToString());
                        });
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.REPLYTOFRIENDSHIPREQUEST:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        UUID session = UUID.Zero;
                        Client.Friends.FriendRequests.ForEach(o =>
                        {
                            if (o.Key.Equals(agentUUID))
                            {
                                session = o.Value;
                            }
                        });
                        if (session.Equals(UUID.Zero))
                        {
                            throw new ScriptException(ScriptError.NO_FRIENDSHIP_OFFER_FOUND);
                        }
                        switch (
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                        message)).ToLowerInvariant()))
                        {
                            case Action.ACCEPT:
                                Client.Friends.AcceptFriendship(agentUUID, session);
                                break;
                            case Action.DECLINE:
                                Client.Friends.DeclineFriendship(agentUUID, session);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETFRIENDDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new ScriptException(ScriptError.FRIEND_NOT_FOUND);
                        }
                        List<string> data = new List<string>(GetStructuredData(friend,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message))));
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.OFFERFRIENDSHIP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend != null)
                        {
                            throw new ScriptException(ScriptError.AGENT_ALREADY_FRIEND);
                        }
                        Client.Friends.OfferFriendship(agentUUID,
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MESSAGE)),
                                message)));
                    };
                    break;
                case ScriptKeys.TERMINATEFRIENDSHIP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new ScriptException(ScriptError.FRIEND_NOT_FOUND);
                        }
                        Client.Friends.TerminateFriendship(agentUUID);
                    };
                    break;
                case ScriptKeys.GRANTFRIENDRIGHTS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new ScriptException(ScriptError.FRIEND_NOT_FOUND);
                        }
                        int rights = 0;
                        Parallel.ForEach(wasCSVToEnumerable(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RIGHTS)),
                                message))).AsParallel().Where(o => !string.IsNullOrEmpty(o)),
                            o =>
                                Parallel.ForEach(
                                    typeof (FriendRights).GetFields(BindingFlags.Public | BindingFlags.Static)
                                        .AsParallel().Where(p => p.Name.Equals(o, StringComparison.Ordinal)),
                                    q => { rights |= ((int) q.GetValue(null)); }));
                        Client.Friends.GrantRights(agentUUID, (FriendRights) rights);
                    };
                    break;
                case ScriptKeys.MAPFRIEND:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Friendship))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID agentUUID;
                        if (
                            !UUID.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)), message)),
                                out agentUUID) && !AgentNameToUUID(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                            message)),
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                            message)),
                                    corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout,
                                    ref agentUUID))
                        {
                            throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                        }
                        FriendInfo friend = Client.Friends.FriendList.Find(o => o.UUID.Equals(agentUUID));
                        if (friend == null)
                        {
                            throw new ScriptException(ScriptError.FRIEND_NOT_FOUND);
                        }
                        if (!friend.CanSeeThemOnMap)
                        {
                            throw new ScriptException(ScriptError.FRIEND_DOES_NOT_ALLOW_MAPPING);
                        }
                        ulong regionHandle = 0;
                        Vector3 position = Vector3.Zero;
                        ManualResetEvent FriendFoundEvent = new ManualResetEvent(false);
                        bool offline = false;
                        EventHandler<FriendFoundReplyEventArgs> FriendFoundEventHandler = (sender, args) =>
                        {
                            if (args.RegionHandle.Equals(0))
                            {
                                offline = true;
                                FriendFoundEvent.Set();
                                return;
                            }
                            regionHandle = args.RegionHandle;
                            position = args.Location;
                            FriendFoundEvent.Set();
                        };
                        lock (ClientInstanceFriendsLock)
                        {
                            Client.Friends.FriendFoundReply += FriendFoundEventHandler;
                            Client.Friends.MapFriend(agentUUID);
                            if (!FriendFoundEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Friends.FriendFoundReply -= FriendFoundEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_MAPPING_FRIEND);
                            }
                            Client.Friends.FriendFoundReply -= FriendFoundEventHandler;
                        }
                        if (offline)
                        {
                            throw new ScriptException(ScriptError.FRIEND_OFFLINE);
                        }
                        UUID parcelUUID = Client.Parcels.RequestRemoteParcelID(position, regionHandle, UUID.Zero);
                        ManualResetEvent ParcelInfoEvent = new ManualResetEvent(false);
                        string regionName = string.Empty;
                        EventHandler<ParcelInfoReplyEventArgs> ParcelInfoEventHandler = (sender, args) =>
                        {
                            regionName = args.Parcel.SimName;
                            ParcelInfoEvent.Set();
                        };
                        lock (ClientInstanceParcelsLock)
                        {
                            Client.Parcels.ParcelInfoReply += ParcelInfoEventHandler;
                            Client.Parcels.RequestParcelInfo(parcelUUID);
                            if (!ParcelInfoEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                            }
                            Client.Parcels.ParcelInfoReply -= ParcelInfoEventHandler;
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasEnumerableToCSV(new[] {regionName, position.ToString()}));
                    };
                    break;
                case ScriptKeys.GETOBJECTMEDIADATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        List<string> data = new List<string>();
                        Client.Objects.RequestObjectMedia(primitive.ID,
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            (succeeded, version, faceMedia) =>
                            {
                                switch (succeeded)
                                {
                                    case true:
                                        data.AddRange(GetStructuredData(faceMedia,
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                    message))));
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_OBJECT_MEDIA);
                                }
                            });
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasEnumerableToCSV(data));
                    };
                    break;
                case ScriptKeys.GETOBJECTPERMISSIONS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                            wasPermissionsToString(primitive.Properties.Permissions));
                    };
                    break;
                case ScriptKeys.SETOBJECTMEDIADATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        uint face;
                        if (
                            !uint.TryParse(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FACE)),
                                    message)), out face))
                            throw new ScriptException(ScriptError.INVALID_FACE_SPECIFIED);
                        MediaEntry[] faceMediaEntries = null;
                        Client.Objects.RequestObjectMedia(primitive.ID,
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            (succeeded, version, faceMedia) =>
                            {
                                switch (succeeded)
                                {
                                    case true:
                                        if (face >= faceMedia.Length)
                                            throw new ScriptException(ScriptError.INVALID_FACE_SPECIFIED);
                                        faceMediaEntries = faceMedia;
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.COULD_NOT_RETRIEVE_OBJECT_MEDIA);
                                }
                            });
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref faceMediaEntries[face]);
                        Client.Objects.UpdateObjectMedia(primitive.ID, faceMediaEntries,
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)));
                    };
                    break;
                case ScriptKeys.SETOBJECTPERMISSIONS:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        string itemPermissions =
                            wasInput(
                                wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)), message));
                        if (string.IsNullOrEmpty(itemPermissions))
                        {
                            throw new ScriptException(ScriptError.NO_PERMISSIONS_PROVIDED);
                        }
                        OpenMetaverse.Permissions permissions = wasStringToPermissions(itemPermissions);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Base, permissions.BaseMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Owner, permissions.OwnerMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Group, permissions.GroupMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.Everyone, permissions.EveryoneMask, true);
                        Client.Objects.SetPermissions(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            PermissionWho.NextOwner, permissions.NextOwnerMask, true);
                    };
                    break;
                case ScriptKeys.OBJECTDEED:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        Client.Objects.DeedObject(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.SETOBJECTGROUP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        Client.Objects.SetObjectsGroup(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            new List<uint> {primitive.LocalID},
                            commandGroup.UUID);
                    };
                    break;
                case ScriptKeys.SETOBJECTSALEINFO:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        int price;
                        if (
                            !int.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PRICE)), message)),
                                out price))
                        {
                            throw new ScriptException(ScriptError.INVALID_PRICE);
                        }
                        if (price < 0)
                        {
                            throw new ScriptException(ScriptError.INVALID_PRICE);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        FieldInfo saleTypeInfo = typeof (SaleType).GetFields(BindingFlags.Public |
                                                                             BindingFlags.Static)
                            .AsParallel().FirstOrDefault(o =>
                                o.Name.Equals(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)),
                                    StringComparison.Ordinal));
                        Client.Objects.SetSaleInfo(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, saleTypeInfo != null
                                ? (SaleType)
                                    saleTypeInfo.GetValue(null)
                                : SaleType.Copy, price);
                    };
                    break;
                case ScriptKeys.SETOBJECTPOSITION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        Client.Objects.SetPosition(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, position);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEFLAGS:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        bool physics;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PHYSICS)),
                                        message)),
                                out physics))
                        {
                            physics = !(primitive.Flags & PrimFlags.Physics).Equals(0);
                        }
                        bool temporary;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TEMPORARY)),
                                        message)),
                                out temporary))
                        {
                            temporary = !(primitive.Flags & PrimFlags.Temporary).Equals(0);
                        }
                        bool phantom;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PHANTOM)),
                                        message)),
                                out phantom))
                        {
                            phantom = !(primitive.Flags & PrimFlags.Phantom).Equals(0);
                        }
                        bool shadows;
                        if (
                            !bool.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SHADOWS)),
                                        message)),
                                out shadows))
                        {
                            shadows = !(primitive.Flags & PrimFlags.CastShadows).Equals(0);
                        }
                        FieldInfo physicsShapeFieldInfo = typeof (PhysicsShapeType).GetFields(BindingFlags.Public |
                                                                                              BindingFlags.Static)
                            .AsParallel().FirstOrDefault(p => p.Name.Equals(wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                    message)), StringComparison.Ordinal));
                        PhysicsShapeType physicsShapeType;
                        switch (physicsShapeFieldInfo != null)
                        {
                            case true:
                                physicsShapeType = (PhysicsShapeType) physicsShapeFieldInfo.GetValue(null);
                                break;
                            default:
                                physicsShapeType = primitive.PhysicsProps.PhysicsShapeType;
                                break;
                        }
                        float density;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DENSITY)),
                                        message)),
                                out density))
                        {
                            density = primitive.PhysicsProps.Density;
                        }
                        float friction;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FRICTION)),
                                        message)),
                                out friction))
                        {
                            friction = primitive.PhysicsProps.Friction;
                        }
                        float restitution;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RESTITUTION)),
                                        message)),
                                out restitution))
                        {
                            restitution = primitive.PhysicsProps.Restitution;
                        }
                        float gravity;
                        if (
                            !float.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GRAVITY)),
                                        message)),
                                out gravity))
                        {
                            gravity = primitive.PhysicsProps.GravityMultiplier;
                        }
                        Client.Objects.SetFlags(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID,
                            physics,
                            temporary,
                            phantom,
                            shadows,
                            physicsShapeType, density,
                            friction, restitution,
                            gravity);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEPOSITION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            throw new ScriptException(ScriptError.INVALID_POSITION);
                        }
                        Client.Objects.SetPosition(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, position, true);
                    };
                    break;
                case ScriptKeys.SETOBJECTROTATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            throw new ScriptException(ScriptError.INVALID_ROTATION);
                        }
                        Client.Objects.SetRotation(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, rotation);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEROTATION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Quaternion rotation;
                        if (
                            !Quaternion.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ROTATION)),
                                        message)),
                                out rotation))
                        {
                            throw new ScriptException(ScriptError.INVALID_ROTATION);
                        }
                        Client.Objects.SetRotation(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, rotation, true);
                    };
                    break;
                case ScriptKeys.SETOBJECTSCALE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        bool uniform;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.UNIFORM)), message)),
                                out uniform))
                        {
                            uniform = true;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then bail out
                        if (!primitive.ParentID.Equals(0) && !primitive.ParentID.Equals(Client.Self.LocalID))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            throw new ScriptException(ScriptError.INVALID_SCALE);
                        }
                        if (IsSecondLife() &&
                            ((scale.X < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_X ||
                              scale.Y < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Y ||
                              scale.Z < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Z ||
                              scale.X > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_X ||
                              scale.Y > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Y ||
                              scale.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Z)))
                        {
                            throw new ScriptException(ScriptError.SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS);
                        }
                        Client.Objects.SetScale(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, scale, false, uniform);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVESCALE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        bool uniform;
                        if (
                            !bool.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.UNIFORM)), message)),
                                out uniform))
                        {
                            uniform = true;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        Vector3 scale;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SCALE)),
                                        message)),
                                out scale))
                        {
                            throw new ScriptException(ScriptError.INVALID_SCALE);
                        }
                        if (IsSecondLife() &&
                            ((scale.X < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_X ||
                              scale.Y < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Y ||
                              scale.Z < LINDEN_CONSTANTS.PRIMITIVES.MINIMUM_SIZE_Z ||
                              scale.X > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_X ||
                              scale.Y > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Y ||
                              scale.Z > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_SIZE_Z)))
                        {
                            throw new ScriptException(ScriptError.SCALE_WOULD_EXCEED_BUILDING_CONSTRAINTS);
                        }
                        Client.Objects.SetScale(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, scale, true, uniform);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVENAME:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        if (string.IsNullOrEmpty(name))
                        {
                            throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                        }
                        if (IsSecondLife() &&
                            Encoding.UTF8.GetByteCount(name) > LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_NAME_SIZE)
                        {
                            throw new ScriptException(ScriptError.NAME_TOO_LARGE);
                        }
                        Client.Objects.SetName(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, name);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEDESCRIPTION:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        string description =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DESCRIPTION)),
                                    message));
                        if (string.IsNullOrEmpty(description))
                        {
                            throw new ScriptException(ScriptError.NO_DESCRIPTION_PROVIDED);
                        }
                        if (IsSecondLife() &&
                            Encoding.UTF8.GetByteCount(description) >
                            LINDEN_CONSTANTS.PRIMITIVES.MAXIMUM_DESCRIPTION_SIZE)
                        {
                            throw new ScriptException(ScriptError.DESCRIPTION_TOO_LARGE);
                        }
                        Client.Objects.SetDescription(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, description);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVESHAPEDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        // build the primitive shape from presets by supplying "type" (or not)...
                        FieldInfo primitiveShapesFieldInfo = typeof (CORRADE_CONSTANTS.PRIMTIVE_BODIES).GetFields(
                            BindingFlags.Public |
                            BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                                message)),
                                        StringComparison.OrdinalIgnoreCase));
                        Primitive.ConstructionData constructionData;
                        switch (primitiveShapesFieldInfo != null)
                        {
                            case true:
                                constructionData = (Primitive.ConstructionData) primitiveShapesFieldInfo.GetValue(null);
                                break;
                            default:
                                constructionData = primitive.PrimData;
                                break;
                        }
                        // ... and overwrite with manual data settings.
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref constructionData);
                        Client.Objects.SetShape(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, constructionData);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEFLEXIBLEDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref primitive.Flexible);
                        Client.Objects.SetFlexible(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, primitive.Flexible);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVELIGHTDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref primitive.Light);
                        Client.Objects.SetLight(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, primitive.Light);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVEMATERIAL:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        FieldInfo materialFieldInfo = typeof (Material).GetFields(BindingFlags.Public |
                                                                                  BindingFlags.Static)
                            .AsParallel().FirstOrDefault(
                                o =>
                                    string.Equals(o.Name, wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.MATERIAL)), message)),
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (materialFieldInfo == null)
                            throw new ScriptException(ScriptError.UNKNOWN_MATERIAL_TYPE);
                        Client.Objects.SetMaterial(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, (Material) materialFieldInfo.GetValue(null));
                    };
                    break;
                case ScriptKeys.SETPRIMITIVESCULPTDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        wasCSVToStructure(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)), message)),
                            ref primitive.Sculpt);
                        Client.Objects.SetSculpt(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, primitive.Sculpt);
                    };
                    break;
                case ScriptKeys.SETPRIMITIVETEXTUREDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        string face =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FACE)),
                                message));
                        int i;
                        switch (!int.TryParse(face, out i))
                        {
                            case true:
                                switch (face.ToLowerInvariant())
                                {
                                    case "all":
                                        i = primitive.Textures.FaceTextures.Count() - 1;
                                        do
                                        {
                                            if (primitive.Textures.FaceTextures[i] == null)
                                            {
                                                primitive.Textures.FaceTextures[i] =
                                                    primitive.Textures.CreateFace((uint) i);
                                            }
                                            wasCSVToStructure(
                                                wasInput(
                                                    wasKeyValueGet(
                                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                        message)),
                                                ref primitive.Textures.FaceTextures[i]);
                                        } while (--i > -1);
                                        break;
                                    case "default":
                                        wasCSVToStructure(
                                            wasInput(
                                                wasKeyValueGet(
                                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                    message)),
                                            ref primitive.Textures.DefaultTexture);
                                        break;
                                    default:
                                        throw new ScriptException(ScriptError.INVALID_FACE_SPECIFIED);
                                }
                                break;
                            default:
                                if (i < 0 || i > Primitive.TextureEntry.MAX_FACES)
                                    throw new ScriptException(ScriptError.INVALID_FACE_SPECIFIED);
                                if (primitive.Textures.FaceTextures[i] == null)
                                {
                                    primitive.Textures.FaceTextures[i] = primitive.Textures.CreateFace((uint) i);
                                }
                                wasCSVToStructure(
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                        message)),
                                    ref primitive.Textures.FaceTextures[i]);
                                break;
                        }
                        Client.Objects.SetTextures(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, primitive.Textures);
                    };
                    break;
                case ScriptKeys.CHANGEPRIMITIVELINK:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.LINK:
                            case Action.DELINK:
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                        List<string> items = new List<string>(wasCSVToEnumerable(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message)))
                            .AsParallel()
                            .Where(o => !string.IsNullOrEmpty(o)));
                        if (!items.Any() || (action.Equals(Action.LINK) && items.Count < 2))
                        {
                            throw new ScriptException(ScriptError.INVALID_NUMBER_OF_ITEMS_SPECIFIED);
                        }
                        if (IsSecondLife())
                        {
                            if (items.Count > LINDEN_CONSTANTS.OBJECTS.MAXIMUM_PRIMITIVE_COUNT)
                            {
                                throw new ScriptException(ScriptError.LINK_WOULD_EXCEED_MAXIMUM_LINK_LIMIT);
                            }
                        }
                        List<Primitive> primitives = new List<Primitive>();
                        foreach (string item in items)
                        {
                            Primitive primitive = null;
                            if (
                                !FindPrimitive(
                                    StringOrUUID(item),
                                    range,
                                    ref primitive, corradeConfiguration.ServicesTimeout,
                                    corradeConfiguration.DataTimeout))
                            {
                                throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                            }
                            primitives.Add(primitive);
                        }
                        Primitive rootPrimitive = primitives.First();
                        if (!primitives.AsParallel().All(o => o.RegionHandle.Equals(rootPrimitive.RegionHandle)))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVES_NOT_IN_SAME_REGION);
                        }
                        object LockObject = new object();
                        ManualResetEvent PrimChangeLinkEvent = new ManualResetEvent(false);
                        EventHandler<PrimEventArgs> ObjectUpdateEventHandler = (sender, args) =>
                        {
                            lock (LockObject)
                            {
                                if (!primitives.Any())
                                {
                                    PrimChangeLinkEvent.Set();
                                    return;
                                }
                            }
                            lock (LockObject)
                            {
                                if (primitives.Any(o => o.LocalID.Equals(args.Prim.LocalID)))
                                {
                                    primitives.RemoveAll(o => o.LocalID.Equals(args.Prim.LocalID));
                                }
                            }
                        };
                        lock (ClientInstanceObjectsLock)
                        {
                            Client.Objects.ObjectUpdate += ObjectUpdateEventHandler;
                            switch (action)
                            {
                                case Action.LINK:
                                    Client.Objects.LinkPrims(
                                        Client.Network.Simulators.FirstOrDefault(
                                            o => o.Handle.Equals(rootPrimitive.RegionHandle)),
                                        primitives.Select(o => o.LocalID).ToList());
                                    break;
                                case Action.DELINK:
                                    Client.Objects.DelinkPrims(
                                        Client.Network.Simulators.FirstOrDefault(
                                            o => o.Handle.Equals(rootPrimitive.RegionHandle)),
                                        primitives.Select(o => o.LocalID).ToList());
                                    break;
                            }
                            if (!PrimChangeLinkEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Objects.ObjectUpdate -= ObjectUpdateEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_CHANGING_LINKS);
                            }
                            Client.Objects.ObjectUpdate -= ObjectUpdateEventHandler;
                        }
                    };
                    break;
                case ScriptKeys.PRIMITIVEBUY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        if (primitive.Properties.SaleType.Equals(SaleType.Not))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOR_SALE);
                        }
                        if (!primitive.Properties.SalePrice.Equals(0) &&
                            !HasCorradePermission(commandGroup.Name, (int) Permissions.Economy))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        UUID folderUUID;
                        string folder =
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                    message));
                        if (string.IsNullOrEmpty(folder) || !UUID.TryParse(folder, out folderUUID))
                        {
                            folderUUID = Client.Inventory.Store.RootFolder.UUID;
                        }
                        Client.Objects.BuyObject(
                            Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                            primitive.LocalID, primitive.Properties.SaleType,
                            primitive.Properties.SalePrice,
                            commandGroup.UUID, folderUUID);
                    };
                    break;
                case ScriptKeys.GETPRIMITIVEPAYPRICES:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }
                        if (primitive.Properties.SaleType.Equals(SaleType.Not))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOR_SALE);
                        }
                        List<string> csv = new List<string>();
                        ManualResetEvent PayPrceReceivedEvent = new ManualResetEvent(false);
                        EventHandler<PayPriceReplyEventArgs> PayPriceReplyEventHandler = (sender, args) =>
                        {
                            csv.Add(args.DefaultPrice.ToString(CultureInfo.DefaultThreadCurrentCulture));
                            csv.AddRange(
                                args.ButtonPrices.Select(o => o.ToString(CultureInfo.DefaultThreadCurrentCulture)));
                            PayPrceReceivedEvent.Set();
                        };
                        lock (ClientInstanceObjectsLock)
                        {
                            Client.Objects.PayPriceReply += PayPriceReplyEventHandler;
                            Client.Objects.RequestPayPrice(
                                Client.Network.Simulators.FirstOrDefault(o => o.Handle.Equals(primitive.RegionHandle)),
                                primitive.ID);
                            if (!PayPrceReceivedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                            {
                                Client.Objects.PayPriceReply -= PayPriceReplyEventHandler;
                                throw new ScriptException(ScriptError.TIMEOUT_REQUESTING_PRICE);
                            }
                            Client.Objects.PayPriceReply -= PayPriceReplyEventHandler;
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.CHANGEAPPEARANCE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Grooming))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string folder =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FOLDER)),
                                message));
                        if (string.IsNullOrEmpty(folder))
                        {
                            throw new ScriptException(ScriptError.NO_FOLDER_SPECIFIED);
                        }
                        // Check for items that can be worn.
                        List<InventoryBase> items =
                            GetInventoryFolderContents<InventoryBase>(Client.Inventory.Store.RootNode, folder)
                                .AsParallel().Where(CanBeWorn)
                                .ToList();
                        if (!items.Any())
                        {
                            throw new ScriptException(ScriptError.NO_EQUIPABLE_ITEMS);
                        }
                        // Now remove the current outfit items.
                        Client.Inventory.Store.GetContents(
                            Client.Inventory.FindFolderForType(AssetType.CurrentOutfitFolder)).FindAll(
                                o => CanBeWorn(o) && ((InventoryItem) o).AssetType.Equals(AssetType.Link))
                            .ForEach(p =>
                            {
                                InventoryItem item = ResolveItemLink(p as InventoryItem);
                                if (item is InventoryWearable)
                                {
                                    if (!IsBodyPart(item))
                                    {
                                        UnWear(item);
                                        return;
                                    }
                                    if (items.AsParallel().Any(q =>
                                    {
                                        InventoryWearable i = q as InventoryWearable;
                                        return i != null &&
                                               ((InventoryWearable) item).WearableType.Equals(i.WearableType);
                                    }))
                                        UnWear(item);
                                    return;
                                }
                                if (item is InventoryAttachment || item is InventoryObject)
                                {
                                    Detach(item);
                                }
                            });
                        // And equip the specified folder.
                        Parallel.ForEach(items, o =>
                        {
                            InventoryItem item = o as InventoryItem;
                            if (item is InventoryWearable)
                            {
                                Wear(item, false);
                                return;
                            }
                            if (item is InventoryAttachment || item is InventoryObject)
                            {
                                Attach(item, AttachmentPoint.Default, false);
                            }
                        });
                        // And rebake.
                        RebakeTimer.Change(corradeConfiguration.RebakeDelay, 0);
                    };
                    break;
                case ScriptKeys.PLAYSOUND:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Vector3 position;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                        message)),
                                out position))
                        {
                            position = Client.Self.SimPosition;
                        }
                        float gain;
                        if (!float.TryParse(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.GAIN)),
                                message)),
                            out gain))
                        {
                            gain = 1;
                        }
                        object item =
                            StringOrUUID(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)),
                                    message)));
                        InventoryItem inventoryItem;
                        switch (item != null)
                        {
                            case true:
                                InventoryBase inventoryBaseItem =
                                    FindInventory<InventoryBase>(Client.Inventory.Store.RootNode, item
                                        ).FirstOrDefault();
                                if (inventoryBaseItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                inventoryItem = inventoryBaseItem as InventoryItem;
                                if (inventoryItem == null)
                                {
                                    throw new ScriptException(ScriptError.INVENTORY_ITEM_NOT_FOUND);
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.NO_ITEM_SPECIFIED);
                        }
                        Client.Sound.SendSoundTrigger(inventoryItem.UUID, position, gain);
                    };
                    break;
                case ScriptKeys.TERRAIN:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        byte[] data = null;
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                message))
                                .ToLowerInvariant()))
                        {
                            case Action.GET:
                                ManualResetEvent[] DownloadTerrainEvents =
                                {
                                    new ManualResetEvent(false),
                                    new ManualResetEvent(false)
                                };
                                EventHandler<InitiateDownloadEventArgs> InitiateDownloadEventHandler =
                                    (sender, args) =>
                                    {
                                        Client.Assets.RequestAssetXfer(args.SimFileName, false, false, UUID.Zero,
                                            AssetType.Unknown, false);
                                        DownloadTerrainEvents[0].Set();
                                    };
                                EventHandler<XferReceivedEventArgs> XferReceivedEventHandler = (sender, args) =>
                                {
                                    data = args.Xfer.AssetData;
                                    DownloadTerrainEvents[1].Set();
                                };
                                lock (ClientInstanceAssetsLock)
                                {
                                    Client.Assets.InitiateDownload += InitiateDownloadEventHandler;
                                    Client.Assets.XferReceived += XferReceivedEventHandler;
                                    Client.Estate.EstateOwnerMessage("terrain", new List<string>
                                    {
                                        "download filename",
                                        simulator.Name
                                    });
                                    if (!WaitHandle.WaitAll(DownloadTerrainEvents.Select(o => (WaitHandle) o).ToArray(),
                                        (int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Assets.InitiateDownload -= InitiateDownloadEventHandler;
                                        Client.Assets.XferReceived -= XferReceivedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_DOWNLOADING_ASSET);
                                    }
                                    Client.Assets.InitiateDownload -= InitiateDownloadEventHandler;
                                    Client.Assets.XferReceived -= XferReceivedEventHandler;
                                }
                                if (data == null || !data.Any())
                                {
                                    throw new ScriptException(ScriptError.EMPTY_ASSET_DATA);
                                }
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), Convert.ToBase64String(data));
                                break;
                            case Action.SET:
                                try
                                {
                                    data = Convert.FromBase64String(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                                message)));
                                }
                                catch (Exception)
                                {
                                    throw new ScriptException(ScriptError.INVALID_ASSET_DATA);
                                }
                                if (!data.Any())
                                {
                                    throw new ScriptException(ScriptError.EMPTY_ASSET_DATA);
                                }
                                ManualResetEvent AssetUploadEvent = new ManualResetEvent(false);
                                EventHandler<AssetUploadEventArgs> AssetUploadEventHandler = (sender, args) =>
                                {
                                    if (args.Upload.Transferred.Equals(args.Upload.Size))
                                    {
                                        AssetUploadEvent.Set();
                                    }
                                };
                                lock (ClientInstanceAssetsLock)
                                {
                                    Client.Assets.UploadProgress += AssetUploadEventHandler;
                                    Client.Estate.UploadTerrain(data, simulator.Name);
                                    if (!AssetUploadEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                    {
                                        Client.Assets.UploadProgress -= AssetUploadEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_UPLOADING_ASSET);
                                    }
                                    Client.Assets.UploadProgress -= AssetUploadEventHandler;
                                }
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.GETTERRAINHEIGHT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Land))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string region =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.REGION)),
                                message));
                        Simulator simulator =
                            Client.Network.Simulators.FirstOrDefault(
                                o =>
                                    o.Name.Equals(
                                        string.IsNullOrEmpty(region) ? Client.Network.CurrentSim.Name : region,
                                        StringComparison.InvariantCultureIgnoreCase));
                        if (simulator == null)
                        {
                            throw new ScriptException(ScriptError.REGION_NOT_FOUND);
                        }
                        Vector3 southwest;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SOUTHWEST)),
                                        message)),
                                out southwest))
                        {
                            southwest = new Vector3(0, 0, 0);
                        }
                        Vector3 northeast;
                        if (
                            !Vector3.TryParse(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NORTHEAST)),
                                        message)),
                                out northeast))
                        {
                            northeast = new Vector3(255, 255, 0);
                        }

                        int x1 = Convert.ToInt32(southwest.X);
                        int y1 = Convert.ToInt32(southwest.Y);
                        int x2 = Convert.ToInt32(northeast.X);
                        int y2 = Convert.ToInt32(northeast.Y);

                        if (x1 > x2)
                        {
                            wasXORSwap(ref x1, ref x2);
                        }
                        if (y1 > y2)
                        {
                            wasXORSwap(ref y1, ref y2);
                        }

                        int sx = x2 - x1 + 1;
                        int sy = y2 - y1 + 1;

                        float[] csv = new float[sx*sy];
                        Parallel.ForEach(Enumerable.Range(x1, sx), x => Parallel.ForEach(Enumerable.Range(y1, sy), y =>
                        {
                            float height;
                            csv[sx*x + y] = simulator.TerrainHeightAtPoint(x, y, out height)
                                ? height
                                : -1;
                        }));
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv.Select(o => o.ToString(CultureInfo.DefaultThreadCurrentCulture))));
                        }
                    };
                    break;
                case ScriptKeys.CROUCH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                    .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Crouch(action.Equals(Action.START));
                                break;
                            default:
                                throw new ScriptException(ScriptError.FLY_ACTION_START_OR_STOP);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.JUMP:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Movement))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        Action action =
                            wasGetEnumValueFromDescription<Action>(wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.START:
                            case Action.STOP:
                                if (Client.Self.Movement.SitOnGround || !Client.Self.SittingOn.Equals(0))
                                {
                                    Client.Self.Stand();
                                }
                                // stop all non-built-in animations
                                List<UUID> lindenAnimations = new List<UUID>(typeof (Animations).GetProperties(
                                    BindingFlags.Public |
                                    BindingFlags.Static).AsParallel().Select(o => (UUID) o.GetValue(null)).ToList());
                                Parallel.ForEach(Client.Self.SignaledAnimations.Copy().Keys, o =>
                                {
                                    if (!lindenAnimations.Contains(o))
                                        Client.Self.AnimationStop(o, true);
                                });
                                Client.Self.Jump(action.Equals(Action.START));
                                break;
                            default:
                                throw new ScriptException(ScriptError.FLY_ACTION_START_OR_STOP);
                        }
                        // Set the camera on the avatar.
                        Client.Self.Movement.Camera.LookAt(
                            Client.Self.SimPosition,
                            Client.Self.SimPosition
                            );
                    };
                    break;
                case ScriptKeys.EXECUTE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Execute))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        string file =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FILE)),
                                message));
                        if (string.IsNullOrEmpty(file))
                        {
                            throw new ScriptException(ScriptError.NO_EXECUTABLE_FILE_PROVIDED);
                        }
                        ProcessStartInfo p = new ProcessStartInfo(file,
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PARAMETER)), message)))
                        {
                            RedirectStandardOutput = true,
                            RedirectStandardError = true,
                            WindowStyle = ProcessWindowStyle.Normal,
                            UseShellExecute = false
                        };
                        StringBuilder stdout = new StringBuilder();
                        StringBuilder stderr = new StringBuilder();
                        ManualResetEvent[] StdEvent =
                        {
                            new ManualResetEvent(false),
                            new ManualResetEvent(false)
                        };
                        Process q;
                        try
                        {
                            q = Process.Start(p);
                        }
                        catch (Exception)
                        {
                            throw new ScriptException(ScriptError.COULD_NOT_START_PROCESS);
                        }
                        q.OutputDataReceived += (sender, output) =>
                        {
                            if (output.Data == null)
                            {
                                StdEvent[0].Set();
                                return;
                            }
                            stdout.AppendLine(output.Data);
                        };
                        q.ErrorDataReceived += (sender, output) =>
                        {
                            if (output.Data == null)
                            {
                                StdEvent[1].Set();
                                return;
                            }
                            stderr.AppendLine(output.Data);
                        };
                        q.BeginErrorReadLine();
                        q.BeginOutputReadLine();
                        if (!q.WaitForExit((int) corradeConfiguration.ServicesTimeout))
                        {
                            throw new ScriptException(ScriptError.TIMEOUT_WAITING_FOR_EXECUTION);
                        }
                        if (StdEvent[0].WaitOne((int) corradeConfiguration.ServicesTimeout) && !stdout.Length.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), stdout.ToString());
                        }
                        if (StdEvent[1].WaitOne((int) corradeConfiguration.ServicesTimeout) && !stderr.Length.Equals(0))
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), stderr.ToString());
                        }
                    };
                    break;
                case ScriptKeys.GETCONFIGURATIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        List<string> data = new List<string>();
                        lock (ConfigurationFileLock)
                        {
                            data.AddRange(GetStructuredData(corradeConfiguration,
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                    message)))
                                );
                        }
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.SETCONFIGURATIONDATA:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        lock (ConfigurationFileLock)
                        {
                            wasCSVToStructure(
                                wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                    message)), ref corradeConfiguration);
                            corradeConfiguration.UpdateDynamicConfiguration(corradeConfiguration);
                            ConfigurationWatcher.EnableRaisingEvents = false;
                            corradeConfiguration.Save(CORRADE_CONSTANTS.CONFIGURATION_FILE, ref corradeConfiguration);
                            ConfigurationWatcher.EnableRaisingEvents = true;
                        }
                    };
                    break;
                case ScriptKeys.CACHE:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(wasInput(
                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                            .ToLowerInvariant()))
                        {
                            case Action.PURGE:
                                Client.Assets.Cache.BeginPrune();
                                Cache.Purge();
                                break;
                            case Action.SAVE:
                                SaveCorradeCache.Invoke();
                                break;
                            case Action.LOAD:
                                LoadCorradeCache.Invoke();
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                    };
                    break;
                case ScriptKeys.LOGOUT:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        ConnectionSemaphores['u'].Set();
                    };
                    break;
                case ScriptKeys.RLV:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                    message)).ToLowerInvariant()))
                        {
                            case Action.ENABLE:
                                corradeConfiguration.EnableRLV = true;
                                break;
                            case Action.DISABLE:
                                corradeConfiguration.EnableRLV = false;
                                lock (RLVRulesLock)
                                {
                                    RLVRules.Clear();
                                }
                                break;
                        }
                    };
                    break;
                case ScriptKeys.FILTER:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Filter))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        switch (wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)),
                                    message)).ToLowerInvariant()))
                        {
                            case Action.SET:
                                List<Filter> inputFilters = new List<Filter>();
                                string input =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.INPUT)),
                                        message));
                                if (!string.IsNullOrEmpty(input))
                                {
                                    foreach (
                                        KeyValuePair<string, string> i in
                                            wasCSVToEnumerable(input).AsParallel().Select((o, p) => new {o, p})
                                                .GroupBy(q => q.p/2, q => q.o)
                                                .Select(o => o.ToList())
                                                .TakeWhile(o => o.Count%2 == 0)
                                                .Where(
                                                    o =>
                                                        !string.IsNullOrEmpty(o.First()) ||
                                                        !string.IsNullOrEmpty(o.Last()))
                                                .ToDictionary(o => o.First(), p => p.Last()))
                                    {
                                        inputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Key));
                                        inputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Value));
                                    }
                                    lock (InputFiltersLock)
                                    {
                                        corradeConfiguration.InputFilters = inputFilters;
                                    }
                                }
                                List<Filter> outputFilters = new List<Filter>();
                                string output =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.OUTPUT)),
                                        message));
                                if (!string.IsNullOrEmpty(output))
                                {
                                    foreach (
                                        KeyValuePair<string, string> i in
                                            wasCSVToEnumerable(output).AsParallel().Select((o, p) => new {o, p})
                                                .GroupBy(q => q.p/2, q => q.o)
                                                .Select(o => o.ToList())
                                                .TakeWhile(o => o.Count%2 == 0)
                                                .Where(
                                                    o =>
                                                        !string.IsNullOrEmpty(o.First()) ||
                                                        !string.IsNullOrEmpty(o.Last()))
                                                .ToDictionary(o => o.First(), p => p.Last()))
                                    {
                                        outputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Key));
                                        outputFilters.Add(wasGetEnumValueFromDescription<Filter>(i.Value));
                                    }
                                    lock (OutputFiltersLock)
                                    {
                                        corradeConfiguration.OutputFilters = outputFilters;
                                    }
                                }
                                break;
                            case Action.GET:
                                switch (wasGetEnumValueFromDescription<Type>(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)),
                                            message)).ToLowerInvariant()))
                                {
                                    case Type.INPUT:
                                        lock (InputFiltersLock)
                                        {
                                            if (corradeConfiguration.InputFilters.Any())
                                            {
                                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                    wasEnumerableToCSV(corradeConfiguration.InputFilters.Select(
                                                        o => wasGetDescriptionFromEnumValue(o))));
                                            }
                                        }
                                        break;
                                    case Type.OUTPUT:
                                        lock (OutputFiltersLock)
                                        {
                                            if (corradeConfiguration.OutputFilters.Any())
                                            {
                                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                                    wasEnumerableToCSV(corradeConfiguration.OutputFilters.Select(
                                                        o => wasGetDescriptionFromEnumValue(o))));
                                            }
                                        }
                                        break;
                                }
                                break;
                        }
                    };
                    break;
                case ScriptKeys.INVENTORY:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Inventory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }

                        lock (GroupDirectoryTrackersLock)
                        {
                            if (!GroupDirectoryTrackers.Contains(commandGroup.UUID))
                            {
                                GroupDirectoryTrackers.Add(commandGroup.UUID, Client.Inventory.Store.RootFolder);
                            }
                        }
                        string path =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                message));
                        Func<string, InventoryBase, InventoryBase> findPath = null;
                        findPath = (o, p) =>
                        {
                            if (string.IsNullOrEmpty(o)) return p;

                            // Split all paths.
                            string[] unpack = o.Split(CORRADE_CONSTANTS.PATH_SEPARATOR[0]);
                            // Pop first item to process.
                            string first = unpack.First();
                            // Remove item.
                            unpack = unpack.AsParallel().Where(q => !q.Equals(first)).ToArray();

                            InventoryBase next = p;

                            // Avoid preceeding slashes.
                            if (string.IsNullOrEmpty(first)) goto CONTINUE;

                            HashSet<InventoryBase> contents =
                                new HashSet<InventoryBase>(Client.Inventory.Store.GetContents(p.UUID));
                            try
                            {
                                UUID itemUUID;
                                switch (!UUID.TryParse(first, out itemUUID))
                                {
                                    case true:
                                        next = contents.SingleOrDefault(q => q.Name.Equals(first));
                                        break;
                                    default:
                                        next = contents.SingleOrDefault(q => q.UUID.Equals(itemUUID));
                                        break;
                                }
                            }
                            catch (Exception)
                            {
                                throw new ScriptException(ScriptError.AMBIGUOUS_PATH);
                            }

                            switch (next != null && !next.Equals(default(InventoryBase)))
                            {
                                case false:
                                    throw new ScriptException(ScriptError.PATH_NOT_FOUND);
                            }

                            if (!(next is InventoryFolder))
                            {
                                return next;
                            }

                            CONTINUE:
                            return findPath(string.Join(CORRADE_CONSTANTS.PATH_SEPARATOR, unpack),
                                Client.Inventory.Store[next.UUID]);
                        };
                        InventoryBase item;
                        List<string> csv = new List<string>();
                        Action action = wasGetEnumValueFromDescription<Action>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ACTION)), message))
                                .ToLowerInvariant());
                        switch (action)
                        {
                            case Action.LS:
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        foreach (DirItem dirItem in Client.Inventory.Store.GetContents(
                                            item.UUID).AsParallel().Select(
                                                o => DirItem.FromInventoryBase(o)))
                                        {
                                            csv.AddRange(new[]
                                            {wasGetStructureMemberDescription(dirItem, dirItem.Name), dirItem.Name});
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Item),
                                                dirItem.Item.ToString()
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Type),
                                                wasGetDescriptionFromEnumValue(dirItem.Type)
                                            });
                                            csv.AddRange(new[]
                                            {
                                                wasGetStructureMemberDescription(dirItem, dirItem.Permissions),
                                                dirItem.Permissions
                                            });
                                        }
                                        break;
                                    case false:
                                        DirItem dir = DirItem.FromInventoryBase(item);
                                        csv.AddRange(new[] {wasGetStructureMemberDescription(dir, dir.Name), dir.Name});
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Item),
                                            dir.Item.ToString()
                                        });
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Type),
                                            wasGetDescriptionFromEnumValue(dir.Type)
                                        });
                                        csv.AddRange(new[]
                                        {
                                            wasGetStructureMemberDescription(dir, dir.Permissions),
                                            dir.Permissions
                                        });
                                        break;
                                }
                                break;
                            case Action.CWD:
                                lock (GroupDirectoryTrackersLock)
                                {
                                    DirItem dirItem =
                                        DirItem.FromInventoryBase(
                                            GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase);
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(dirItem, dirItem.Name), dirItem.Name});
                                    csv.AddRange(new[]
                                    {wasGetStructureMemberDescription(dirItem, dirItem.Item), dirItem.Item.ToString()});
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(dirItem, dirItem.Type),
                                        wasGetDescriptionFromEnumValue(dirItem.Type)
                                    });
                                    csv.AddRange(new[]
                                    {
                                        wasGetStructureMemberDescription(dirItem, dirItem.Permissions),
                                        dirItem.Permissions
                                    });
                                }
                                break;
                            case Action.CD:
                                if (string.IsNullOrEmpty(path))
                                {
                                    throw new ScriptException(ScriptError.NO_PATH_PROVIDED);
                                }
                                switch (!path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                {
                                    case true:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                    default:
                                        item = Client.Inventory.Store.RootFolder;
                                        break;
                                }
                                item = findPath(path, item);
                                if (!(item is InventoryFolder))
                                {
                                    throw new ScriptException(ScriptError.UNEXPECTED_ITEM_IN_PATH);
                                }
                                lock (GroupDirectoryTrackersLock)
                                {
                                    GroupDirectoryTrackers[commandGroup.UUID] = item;
                                }
                                break;
                            case Action.MKDIR:
                                string mkdirName =
                                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                        message));
                                if (string.IsNullOrEmpty(mkdirName))
                                {
                                    throw new ScriptException(ScriptError.NO_NAME_PROVIDED);
                                }
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                if (!(item is InventoryFolder))
                                {
                                    throw new ScriptException(ScriptError.UNEXPECTED_ITEM_IN_PATH);
                                }
                                if (Client.Inventory.CreateFolder(item.UUID, mkdirName) == UUID.Zero)
                                {
                                    throw new ScriptException(ScriptError.UNABLE_TO_CREATE_FOLDER);
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.CHMOD:
                                string itemPermissions =
                                    wasInput(
                                        wasKeyValueGet(
                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PERMISSIONS)), message));
                                if (string.IsNullOrEmpty(itemPermissions))
                                {
                                    throw new ScriptException(ScriptError.NO_PERMISSIONS_PROVIDED);
                                }
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                Action<InventoryItem, string> setPermissions = (o, p) =>
                                {
                                    OpenMetaverse.Permissions permissions = wasStringToPermissions(p);
                                    o.Permissions = permissions;
                                    Client.Inventory.RequestUpdateItem(o);
                                    bool succeeded = false;
                                    ManualResetEvent ItemReceivedEvent = new ManualResetEvent(false);
                                    EventHandler<ItemReceivedEventArgs> ItemReceivedEventHandler =
                                        (sender, args) =>
                                        {
                                            if (!args.Item.UUID.Equals(o.UUID)) return;
                                            succeeded = args.Item.Permissions.Equals(permissions);
                                            ItemReceivedEvent.Set();
                                        };
                                    lock (ClientInstanceInventoryLock)
                                    {
                                        Client.Inventory.ItemReceived += ItemReceivedEventHandler;
                                        Client.Inventory.RequestFetchInventory(o.UUID, o.OwnerID);
                                        if (
                                            !ItemReceivedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            Client.Inventory.ItemReceived -= ItemReceivedEventHandler;
                                            throw new ScriptException(ScriptError.TIMEOUT_RETRIEVING_ITEM);
                                        }
                                        Client.Inventory.ItemReceived -= ItemReceivedEventHandler;
                                    }
                                    if (!succeeded)
                                    {
                                        throw new ScriptException(ScriptError.SETTING_PERMISSIONS_FAILED);
                                    }
                                };
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        foreach (InventoryItem inventoryItem in Client.Inventory.Store.GetContents(
                                            item.UUID).OfType<InventoryItem>())
                                        {
                                            setPermissions.Invoke(inventoryItem, itemPermissions);
                                        }
                                        break;
                                    default:
                                        setPermissions.Invoke(item as InventoryItem, itemPermissions);
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.RM:
                                switch (!string.IsNullOrEmpty(path))
                                {
                                    case true:
                                        if (path[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            item = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            item = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                item = findPath(path, item);
                                switch (item is InventoryFolder)
                                {
                                    case true:
                                        Client.Inventory.MoveFolder(item.UUID,
                                            Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                        break;
                                    default:
                                        Client.Inventory.MoveItem(item.UUID,
                                            Client.Inventory.FindFolderForType(AssetType.TrashFolder));
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            case Action.CP:
                            case Action.MV:
                            case Action.LN:
                                string lnSourcePath =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SOURCE)),
                                        message));
                                InventoryBase sourceItem;
                                switch (!string.IsNullOrEmpty(lnSourcePath))
                                {
                                    case true:
                                        if (lnSourcePath[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            sourceItem = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            sourceItem = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                sourceItem = findPath(lnSourcePath, sourceItem);
                                switch (action)
                                {
                                    case Action.CP:
                                    case Action.LN:
                                        if (sourceItem is InventoryFolder)
                                        {
                                            throw new ScriptException(ScriptError.EXPECTED_ITEM_AS_SOURCE);
                                        }
                                        break;
                                }
                                string lnTargetPath =
                                    wasInput(wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TARGET)),
                                        message));
                                InventoryBase targetItem;
                                switch (!string.IsNullOrEmpty(lnTargetPath))
                                {
                                    case true:
                                        if (lnTargetPath[0].Equals(CORRADE_CONSTANTS.PATH_SEPARATOR[0]))
                                        {
                                            targetItem = Client.Inventory.Store.RootFolder;
                                            break;
                                        }
                                        goto default;
                                    default:
                                        lock (GroupDirectoryTrackersLock)
                                        {
                                            targetItem = GroupDirectoryTrackers[commandGroup.UUID] as InventoryBase;
                                        }
                                        break;
                                }
                                targetItem = findPath(lnTargetPath, targetItem);
                                if (!(targetItem is InventoryFolder))
                                {
                                    throw new ScriptException(ScriptError.EXPECTED_FOLDER_AS_TARGET);
                                }
                                switch (action)
                                {
                                    case Action.LN:
                                        Client.Inventory.CreateLink(targetItem.UUID, sourceItem, (succeeded, newItem) =>
                                        {
                                            if (!succeeded)
                                            {
                                                throw new ScriptException(ScriptError.UNABLE_TO_CREATE_ITEM);
                                            }
                                            Client.Inventory.RequestFetchInventory(newItem.UUID, newItem.OwnerID);
                                        });
                                        break;
                                    case Action.MV:
                                        switch (sourceItem is InventoryFolder)
                                        {
                                            case true:
                                                Client.Inventory.MoveFolder(sourceItem.UUID, targetItem.UUID);
                                                break;
                                            default:
                                                Client.Inventory.MoveItem(sourceItem.UUID, targetItem.UUID);
                                                break;
                                        }
                                        break;
                                    case Action.CP:
                                        Client.Inventory.RequestCopyItem(sourceItem.UUID, targetItem.UUID,
                                            sourceItem.Name,
                                            newItem =>
                                            {
                                                if (newItem == null)
                                                {
                                                    throw new ScriptException(ScriptError.UNABLE_TO_CREATE_ITEM);
                                                }
                                            });
                                        break;
                                }
                                UpdateInventoryRecursive.Invoke(Client.Inventory.Store.RootFolder);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ACTION);
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                case ScriptKeys.GETAVATARSDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        HashSet<Avatar> avatars = new HashSet<Avatar>();
                        object LockObject = new object();
                        switch (wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant()))
                        {
                            case Entity.RANGE:
                                Parallel.ForEach(
                                    GetAvatars(range, corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout)
                                        .AsParallel()
                                        .Where(o => Vector3.Distance(o.Position, Client.Self.SimPosition) <= range),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.PARCEL:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                                message)),
                                        out position))
                                {
                                    position = Client.Self.SimPosition;
                                }
                                Parcel parcel = null;
                                if (
                                    !GetParcelAtPosition(Client.Network.CurrentSim, position, ref parcel))
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                                }
                                Parallel.ForEach(GetAvatars(new[]
                                {
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMin),
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMax),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMin.X, parcel.AABBMax.Y, 0)),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMax.X, parcel.AABBMin.Y, 0))
                                }.Max(), corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout)
                                    .AsParallel()
                                    .Where(o => IsVectorInParcel(o.Position, parcel)), o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.REGION:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(Client.Network.CurrentSim);
                                    if (Client.Network.CurrentSim.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (
                                        !SimParcelsDownloadedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                HashSet<Parcel> regionParcels =
                                    new HashSet<Parcel>(Client.Network.CurrentSim.Parcels.Copy().Values);
                                Parallel.ForEach(
                                    GetAvatars(
                                        regionParcels.AsParallel().Select(o => new[]
                                        {
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMin),
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMax),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMin.X, o.AABBMax.Y, 0)),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMax.X, o.AABBMin.Y, 0))
                                        }.Max()).Max(), corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout)
                                        .AsParallel()
                                        .Where(o => regionParcels.AsParallel().Any(p => IsVectorInParcel(o.Position, p))),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            avatars.Add(o);
                                        }
                                    });
                                break;
                            case Entity.AVATAR:
                                UUID agentUUID = UUID.Zero;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref agentUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                Avatar avatar = GetAvatars(range, corradeConfiguration.ServicesTimeout,
                                    corradeConfiguration.DataTimeout)
                                    .AsParallel()
                                    .FirstOrDefault(o => o.ID.Equals(agentUUID));
                                if (avatar == null)
                                    throw new ScriptException(ScriptError.AVATAR_NOT_IN_RANGE);
                                avatars.Add(avatar);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }

                        // allow partial results
                        UpdateAvatars(ref avatars, corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout);

                        List<string> data = new List<string>();

                        Parallel.ForEach(avatars, o =>
                        {
                            IEnumerable<string> avatarData = GetStructuredData(o,
                                wasInput(
                                    wasKeyValueGet(
                                        wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                        message)));
                            if (avatarData.Any())
                            {
                                lock (LockObject)
                                {
                                    data.AddRange(avatarData);
                                }
                            }
                        });
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.GETPRIMITIVESDATA:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        HashSet<Primitive> updatePrimitives = new HashSet<Primitive>();
                        object LockObject = new object();
                        switch (wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)), message))
                                .ToLowerInvariant()))
                        {
                            case Entity.RANGE:
                                Parallel.ForEach(
                                    GetPrimitives(range, corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout)
                                        .AsParallel()
                                        .Where(o => Vector3.Distance(o.Position, Client.Self.SimPosition) <= range),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            updatePrimitives.Add(o);
                                        }
                                    });
                                break;
                            case Entity.PARCEL:
                                Vector3 position;
                                if (
                                    !Vector3.TryParse(
                                        wasInput(
                                            wasKeyValueGet(
                                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.POSITION)),
                                                message)),
                                        out position))
                                {
                                    position = Client.Self.SimPosition;
                                }
                                Parcel parcel = null;
                                if (
                                    !GetParcelAtPosition(Client.Network.CurrentSim, position, ref parcel))
                                {
                                    throw new ScriptException(ScriptError.COULD_NOT_FIND_PARCEL);
                                }
                                Parallel.ForEach(GetPrimitives(new[]
                                {
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMin),
                                    Vector3.Distance(Client.Self.SimPosition, parcel.AABBMax),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMin.X, parcel.AABBMax.Y, 0)),
                                    Vector3.Distance(Client.Self.SimPosition,
                                        new Vector3(parcel.AABBMax.X, parcel.AABBMin.Y, 0))
                                }.Max(), corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout), o =>
                                {
                                    lock (LockObject)
                                    {
                                        updatePrimitives.Add(o);
                                    }
                                });
                                break;
                            case Entity.REGION:
                                // Get all sim parcels
                                ManualResetEvent SimParcelsDownloadedEvent = new ManualResetEvent(false);
                                EventHandler<SimParcelsDownloadedEventArgs> SimParcelsDownloadedEventHandler =
                                    (sender, args) => SimParcelsDownloadedEvent.Set();
                                lock (ClientInstanceParcelsLock)
                                {
                                    Client.Parcels.SimParcelsDownloaded += SimParcelsDownloadedEventHandler;
                                    Client.Parcels.RequestAllSimParcels(Client.Network.CurrentSim);
                                    if (Client.Network.CurrentSim.IsParcelMapFull())
                                    {
                                        SimParcelsDownloadedEvent.Set();
                                    }
                                    if (
                                        !SimParcelsDownloadedEvent.WaitOne((int) corradeConfiguration.ServicesTimeout,
                                            false))
                                    {
                                        Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                        throw new ScriptException(ScriptError.TIMEOUT_GETTING_PARCELS);
                                    }
                                    Client.Parcels.SimParcelsDownloaded -= SimParcelsDownloadedEventHandler;
                                }
                                Parallel.ForEach(
                                    GetPrimitives(
                                        Client.Network.CurrentSim.Parcels.Copy().Values.AsParallel().Select(o => new[]
                                        {
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMin),
                                            Vector3.Distance(Client.Self.SimPosition, o.AABBMax),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMin.X, o.AABBMax.Y, 0)),
                                            Vector3.Distance(Client.Self.SimPosition,
                                                new Vector3(o.AABBMax.X, o.AABBMin.Y, 0))
                                        }.Max()).Max(), corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout),
                                    o =>
                                    {
                                        lock (LockObject)
                                        {
                                            updatePrimitives.Add(o);
                                        }
                                    });
                                break;
                            case Entity.AVATAR:
                                UUID agentUUID = UUID.Zero;
                                if (
                                    !UUID.TryParse(
                                        wasInput(
                                            wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.AGENT)),
                                                message)), out agentUUID) && !AgentNameToUUID(
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(
                                                                wasGetDescriptionFromEnumValue(ScriptKeys.FIRSTNAME)),
                                                            message)),
                                                    wasInput(
                                                        wasKeyValueGet(
                                                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.LASTNAME)),
                                                            message)),
                                                    corradeConfiguration.ServicesTimeout,
                                                    corradeConfiguration.DataTimeout,
                                                    ref agentUUID))
                                {
                                    throw new ScriptException(ScriptError.AGENT_NOT_FOUND);
                                }
                                Avatar avatar = GetAvatars(range, corradeConfiguration.ServicesTimeout,
                                    corradeConfiguration.DataTimeout)
                                    .AsParallel()
                                    .FirstOrDefault(o => o.ID.Equals(agentUUID));
                                if (avatar == null)
                                    throw new ScriptException(ScriptError.AVATAR_NOT_IN_RANGE);
                                HashSet<Primitive> objectsPrimitives =
                                    new HashSet<Primitive>(GetPrimitives(range, corradeConfiguration.ServicesTimeout,
                                        corradeConfiguration.DataTimeout));
                                Parallel.ForEach(objectsPrimitives,
                                    o =>
                                    {
                                        switch (!o.ParentID.Equals(avatar.LocalID))
                                        {
                                            case true:
                                                Primitive primitiveParent =
                                                    objectsPrimitives.AsParallel()
                                                        .FirstOrDefault(p => p.LocalID.Equals(o.ParentID));
                                                if (primitiveParent != null &&
                                                    primitiveParent.ParentID.Equals(avatar.LocalID))
                                                {
                                                    lock (LockObject)
                                                    {
                                                        updatePrimitives.Add(o);
                                                    }
                                                }
                                                break;
                                            default:
                                                lock (LockObject)
                                                {
                                                    updatePrimitives.Add(o);
                                                }
                                                break;
                                        }
                                    });
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }

                        // allow partial results
                        UpdatePrimitives(ref updatePrimitives, corradeConfiguration.DataTimeout);

                        List<string> data = new List<string>();
                        Parallel.ForEach(updatePrimitives, o =>
                        {
                            IEnumerable<string> primitiveData = GetStructuredData(o,
                                wasInput(
                                    wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                        message)));
                            if (primitiveData.Any())
                            {
                                lock (LockObject)
                                {
                                    data.AddRange(primitiveData);
                                }
                            }
                        });
                        if (data.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(data));
                        }
                    };
                    break;
                case ScriptKeys.EXPORTXML:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }

                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then do not export it.
                        if (!primitive.ParentID.Equals(0) && !GetAvatars(range, corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout)
                            .AsParallel()
                            .Any(o => o.LocalID.Equals(primitive.ParentID)))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }

                        HashSet<Primitive> exportPrimitivesSet = new HashSet<Primitive>();
                        Primitive root = new Primitive(primitive) {Position = Vector3.Zero};
                        exportPrimitivesSet.Add(root);

                        object LockObject = new object();

                        // find all the children that have the object as parent.
                        Parallel.ForEach(GetPrimitives(range, corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout), o =>
                            {
                                if (!o.ParentID.Equals(root.LocalID))
                                    return;
                                Primitive child = new Primitive(o);
                                child.Position = root.Position + child.Position*root.Rotation;
                                child.Rotation = root.Rotation*child.Rotation;
                                lock (LockObject)
                                {
                                    exportPrimitivesSet.Add(child);
                                }
                            });

                        // add all the textures to export
                        HashSet<UUID> exportTexturesSet = new HashSet<UUID>();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            if (!o.Textures.DefaultTexture.TextureID.Equals(Primitive.TextureEntry.WHITE_TEXTURE) &&
                                !exportTexturesSet.Contains(o.Textures.DefaultTexture.TextureID))
                            {
                                lock (LockObject)
                                {
                                    exportTexturesSet.Add(new UUID(o.Textures.DefaultTexture.TextureID));
                                }
                            }
                            Parallel.ForEach(o.Textures.FaceTextures, p =>
                            {
                                if (p != null &&
                                    !p.TextureID.Equals(Primitive.TextureEntry.WHITE_TEXTURE) &&
                                    !exportTexturesSet.Contains(p.TextureID))
                                {
                                    lock (LockObject)
                                    {
                                        exportTexturesSet.Add(new UUID(p.TextureID));
                                    }
                                }
                            });
                            if (o.Sculpt != null && !o.Sculpt.SculptTexture.Equals(UUID.Zero) &&
                                !exportTexturesSet.Contains(o.Sculpt.SculptTexture))
                            {
                                lock (LockObject)
                                {
                                    exportTexturesSet.Add(new UUID(o.Sculpt.SculptTexture));
                                }
                            }
                        });

                        // Get the destination format to convert the downloaded textures to.
                        string format =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                message));
                        PropertyInfo formatProperty = null;
                        if (!string.IsNullOrEmpty(format))
                        {
                            formatProperty = typeof (ImageFormat).GetProperties(
                                BindingFlags.Public |
                                BindingFlags.Static)
                                .AsParallel().FirstOrDefault(
                                    o =>
                                        format.Equals(o.Name, StringComparison.Ordinal));
                            if (formatProperty == null)
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED);
                            }
                        }

                        // download all the textures.
                        Dictionary<string, byte[]> exportTextureSetFiles = new Dictionary<string, byte[]>();
                        Parallel.ForEach(exportTexturesSet, o =>
                        {
                            byte[] assetData = null;
                            switch (!Client.Assets.Cache.HasAsset(o))
                            {
                                case true:
                                    lock (ClientInstanceAssetsLock)
                                    {
                                        ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                        Client.Assets.RequestImage(o, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(o)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                    }
                                    Client.Assets.Cache.SaveAssetToCache(o, assetData);
                                    break;
                                default:
                                    assetData = Client.Assets.Cache.GetCachedAssetBytes(o);
                                    break;
                            }
                            switch (formatProperty != null)
                            {
                                case true:
                                    ManagedImage managedImage;
                                    if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                    }
                                    using (MemoryStream imageStream = new MemoryStream())
                                    {
                                        try
                                        {
                                            using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                            {
                                                EncoderParameters encoderParameters =
                                                    new EncoderParameters(1);
                                                encoderParameters.Param[0] =
                                                    new EncoderParameter(Encoder.Quality, 100L);
                                                bitmapImage.Save(imageStream,
                                                    ImageCodecInfo.GetImageDecoders()
                                                        .AsParallel()
                                                        .FirstOrDefault(
                                                            p =>
                                                                p.FormatID.Equals(
                                                                    ((ImageFormat)
                                                                        formatProperty.GetValue(
                                                                            new ImageFormat(Guid.Empty)))
                                                                        .Guid)),
                                                    encoderParameters);
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(
                                                    ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                        }
                                        lock (LockObject)
                                        {
                                            exportTextureSetFiles.Add(
                                                o + "." + format.ToLower(),
                                                imageStream.ToArray());
                                        }
                                    }
                                    break;
                                default:
                                    format = "j2c";
                                    lock (LockObject)
                                    {
                                        exportTextureSetFiles.Add(o + "." + "j2c",
                                            assetData);
                                    }
                                    break;
                            }
                        });

                        HashSet<char> invalidPathCharacters = new HashSet<char>(Path.GetInvalidPathChars());

                        using (MemoryStream zipMemoryStream = new MemoryStream())
                        {
                            using (
                                ZipArchive zipOutputStream = new ZipArchive(zipMemoryStream, ZipArchiveMode.Create, true)
                                )
                            {
                                ZipArchive zipOutputStreamClosure = zipOutputStream;
                                // add all the textures to the zip file
                                Parallel.ForEach(exportTextureSetFiles, o =>
                                {
                                    lock (LockObject)
                                    {
                                        ZipArchiveEntry textureEntry =
                                            zipOutputStreamClosure.CreateEntry(
                                                new string(
                                                    o.Key.Where(p => !invalidPathCharacters.Contains(p)).ToArray()));
                                        using (Stream textureEntryDataStream = textureEntry.Open())
                                        {
                                            using (
                                                BinaryWriter textureEntryDataStreamWriter =
                                                    new BinaryWriter(textureEntryDataStream, Encoding.UTF8))
                                            {
                                                textureEntryDataStreamWriter.Write(o.Value);
                                                textureEntryDataStream.Flush();
                                            }
                                        }
                                    }
                                });

                                // add the primitives XML data to the zip file
                                ZipArchiveEntry primitiveEntry =
                                    zipOutputStreamClosure.CreateEntry(
                                        new string(
                                            (primitive.Properties.Name + ".xml").Where(
                                                p => !invalidPathCharacters.Contains(p))
                                                .ToArray()));
                                using (Stream primitiveEntryDataStream = primitiveEntry.Open())
                                {
                                    using (
                                        StreamWriter primitiveEntryDataStreamWriter =
                                            new StreamWriter(primitiveEntryDataStream, Encoding.UTF8))
                                    {
                                        primitiveEntryDataStreamWriter.Write(
                                            OSDParser.SerializeLLSDXmlString(
                                                Helpers.PrimListToOSD(exportPrimitivesSet.ToList())));
                                        primitiveEntryDataStreamWriter.Flush();
                                    }
                                }
                            }

                            // Base64-encode the zip stream and send it.
                            zipMemoryStream.Seek(0, SeekOrigin.Begin);

                            // If no path was specificed, then send the data.
                            string path =
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                    message));
                            if (string.IsNullOrEmpty(path))
                            {
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                    Convert.ToBase64String(zipMemoryStream.ToArray()));
                                return;
                            }
                            if (
                                !HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                            {
                                throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                            }
                            // Otherwise, save it to the specified file.
                            using (StreamWriter sw = new StreamWriter(path, false, Encoding.UTF8))
                            {
                                zipMemoryStream.WriteTo(sw.BaseStream);
                                zipMemoryStream.Flush();
                            }
                        }
                    };
                    break;
                case ScriptKeys.EXPORTDAE:
                    execute = () =>
                    {
                        if (
                            !HasCorradePermission(commandGroup.Name,
                                (int) Permissions.Interact))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        float range;
                        if (
                            !float.TryParse(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.RANGE)), message)),
                                out range))
                        {
                            range = corradeConfiguration.Range;
                        }
                        Primitive primitive = null;
                        if (
                            !FindPrimitive(
                                StringOrUUID(wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ITEM)), message))),
                                range,
                                ref primitive, corradeConfiguration.ServicesTimeout, corradeConfiguration.DataTimeout))
                        {
                            throw new ScriptException(ScriptError.PRIMITIVE_NOT_FOUND);
                        }

                        // if the primitive is not an object (the root) or the primitive 
                        // is not an object as an avatar attachment then do not export it.
                        if (!primitive.ParentID.Equals(0) && !GetAvatars(range, corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout)
                            .AsParallel()
                            .Any(o => o.LocalID.Equals(primitive.ParentID)))
                        {
                            throw new ScriptException(ScriptError.ITEM_IS_NOT_AN_OBJECT);
                        }

                        HashSet<Primitive> exportPrimitivesSet = new HashSet<Primitive>();
                        Primitive root = new Primitive(primitive) {Position = Vector3.Zero};
                        exportPrimitivesSet.Add(root);

                        object LockObject = new object();

                        // find all the children that have the object as parent.
                        Parallel.ForEach(GetPrimitives(range, corradeConfiguration.ServicesTimeout,
                            corradeConfiguration.DataTimeout), o =>
                            {
                                if (!o.ParentID.Equals(root.LocalID))
                                    return;
                                Primitive child = new Primitive(o);
                                child.Position = root.Position + child.Position*root.Rotation;
                                child.Rotation = root.Rotation*child.Rotation;
                                lock (LockObject)
                                {
                                    exportPrimitivesSet.Add(child);
                                }
                            });

                        // update the primitives in the link set
                        if (!UpdatePrimitives(ref exportPrimitivesSet, corradeConfiguration.DataTimeout))
                            throw new ScriptException(ScriptError.COULD_NOT_GET_PRIMITIVE_PROPERTIES);

                        // add all the textures to export
                        HashSet<UUID> exportTexturesSet = new HashSet<UUID>();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            Primitive.TextureEntryFace defaultTexture = o.Textures.DefaultTexture;
                            if (defaultTexture != null && !exportTexturesSet.Contains(defaultTexture.TextureID))
                            {
                                lock (LockObject)
                                {
                                    exportTexturesSet.Add(defaultTexture.TextureID);
                                }
                            }
                            Parallel.ForEach(o.Textures.FaceTextures, p =>
                            {
                                if (p != null && !exportTexturesSet.Contains(p.TextureID))
                                {
                                    lock (LockObject)
                                    {
                                        exportTexturesSet.Add(p.TextureID);
                                    }
                                }
                            });
                        });

                        // Get the destination format to convert the downloaded textures to.
                        string format =
                            wasInput(wasKeyValueGet(
                                wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.FORMAT)),
                                message));
                        PropertyInfo formatProperty = null;
                        if (!string.IsNullOrEmpty(format))
                        {
                            formatProperty = typeof (ImageFormat).GetProperties(
                                BindingFlags.Public |
                                BindingFlags.Static)
                                .AsParallel().FirstOrDefault(
                                    o =>
                                        format.Equals(o.Name, StringComparison.Ordinal));
                            if (formatProperty == null)
                            {
                                throw new ScriptException(ScriptError.UNKNOWN_IMAGE_FORMAT_REQUESTED);
                            }
                        }

                        // download all the textures.
                        Dictionary<string, byte[]> exportTextureSetFiles = new Dictionary<string, byte[]>();
                        Dictionary<UUID, string> exportMeshTextures = new Dictionary<UUID, string>();
                        Parallel.ForEach(exportTexturesSet, o =>
                        {
                            byte[] assetData = null;
                            switch (!Client.Assets.Cache.HasAsset(o))
                            {
                                case true:
                                    lock (ClientInstanceAssetsLock)
                                    {
                                        ManualResetEvent RequestAssetEvent = new ManualResetEvent(false);
                                        Client.Assets.RequestImage(o, ImageType.Normal,
                                            delegate(TextureRequestState state, AssetTexture asset)
                                            {
                                                if (!asset.AssetID.Equals(o)) return;
                                                if (!state.Equals(TextureRequestState.Finished)) return;
                                                assetData = asset.AssetData;
                                                RequestAssetEvent.Set();
                                            });
                                        if (
                                            !RequestAssetEvent.WaitOne((int) corradeConfiguration.ServicesTimeout, false))
                                        {
                                            throw new ScriptException(ScriptError.TIMEOUT_TRANSFERRING_ASSET);
                                        }
                                    }
                                    Client.Assets.Cache.SaveAssetToCache(o, assetData);
                                    break;
                                default:
                                    assetData = Client.Assets.Cache.GetCachedAssetBytes(o);
                                    break;
                            }
                            switch (formatProperty != null)
                            {
                                case true:
                                    ManagedImage managedImage;
                                    if (!OpenJPEG.DecodeToImage(assetData, out managedImage))
                                    {
                                        throw new Exception(
                                            wasGetDescriptionFromEnumValue(
                                                ScriptError.UNABLE_TO_DECODE_ASSET_DATA));
                                    }
                                    using (MemoryStream imageStream = new MemoryStream())
                                    {
                                        try
                                        {
                                            using (Bitmap bitmapImage = managedImage.ExportBitmap())
                                            {
                                                EncoderParameters encoderParameters =
                                                    new EncoderParameters(1);
                                                encoderParameters.Param[0] =
                                                    new EncoderParameter(Encoder.Quality, 100L);
                                                bitmapImage.Save(imageStream,
                                                    ImageCodecInfo.GetImageDecoders()
                                                        .AsParallel()
                                                        .FirstOrDefault(
                                                            p =>
                                                                p.FormatID.Equals(
                                                                    ((ImageFormat)
                                                                        formatProperty.GetValue(
                                                                            new ImageFormat(Guid.Empty)))
                                                                        .Guid)),
                                                    encoderParameters);
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            throw new Exception(
                                                wasGetDescriptionFromEnumValue(
                                                    ScriptError.UNABLE_TO_CONVERT_TO_REQUESTED_FORMAT));
                                        }
                                        lock (LockObject)
                                        {
                                            exportTextureSetFiles.Add(
                                                o + "." + format.ToLower(),
                                                imageStream.ToArray());
                                            exportMeshTextures.Add(o,
                                                o.ToString());
                                        }
                                    }
                                    break;
                                default:
                                    format = "j2c";
                                    lock (LockObject)
                                    {
                                        exportTextureSetFiles.Add(o + "." + "j2c",
                                            assetData);
                                        exportMeshTextures.Add(o,
                                            o.ToString());
                                    }
                                    break;
                            }
                        });

                        // meshmerize all the primitives
                        HashSet<FacetedMesh> exportMeshSet = new HashSet<FacetedMesh>();
                        MeshmerizerR mesher = new MeshmerizerR();
                        Parallel.ForEach(exportPrimitivesSet, o =>
                        {
                            FacetedMesh mesh = null;
                            if (!MakeFacetedMesh(o, mesher, ref mesh, corradeConfiguration.ServicesTimeout))
                            {
                                throw new ScriptException(ScriptError.COULD_NOT_MESHMERIZE_OBJECT);
                            }
                            if (mesh == null) return;
                            Parallel.ForEach(mesh.Faces, p =>
                            {
                                Primitive.TextureEntryFace textureEntryFace = p.TextureFace;
                                if (textureEntryFace == null) return;

                                // Sculpt UV vertically flipped compared to prims. Flip back
                                if (o.Sculpt != null && !o.Sculpt.SculptTexture.Equals(UUID.Zero) &&
                                    !o.Sculpt.Type.Equals(SculptType.Mesh))
                                {
                                    textureEntryFace = (Primitive.TextureEntryFace) textureEntryFace.Clone();
                                    textureEntryFace.RepeatV *= -1;
                                }
                                // Texture transform for this face
                                mesher.TransformTexCoords(p.Vertices, p.Center, textureEntryFace, o.Scale);
                            });
                            lock (LockObject)
                            {
                                exportMeshSet.Add(mesh);
                            }
                        });

                        HashSet<char> invalidPathCharacters = new HashSet<char>(Path.GetInvalidPathChars());

                        using (MemoryStream zipMemoryStream = new MemoryStream())
                        {
                            using (
                                ZipArchive zipOutputStream = new ZipArchive(zipMemoryStream, ZipArchiveMode.Create, true)
                                )
                            {
                                ZipArchive zipOutputStreamClosure = zipOutputStream;
                                // add all the textures to the zip file
                                Parallel.ForEach(exportTextureSetFiles, o =>
                                {
                                    lock (LockObject)
                                    {
                                        ZipArchiveEntry textureEntry =
                                            zipOutputStreamClosure.CreateEntry(
                                                new string(
                                                    o.Key.Where(
                                                        p => !invalidPathCharacters.Contains(p)).ToArray()));
                                        using (Stream textureEntryDataStream = textureEntry.Open())
                                        {
                                            using (
                                                BinaryWriter textureEntryDataStreamWriter =
                                                    new BinaryWriter(textureEntryDataStream, Encoding.UTF8))
                                            {
                                                textureEntryDataStreamWriter.Write(o.Value);
                                                textureEntryDataStream.Flush();
                                            }
                                        }
                                    }
                                });

                                // add the primitives XML data to the zip file
                                ZipArchiveEntry primitiveEntry =
                                    zipOutputStreamClosure.CreateEntry(
                                        new string(
                                            (primitive.Properties.Name + ".dae").Where(
                                                p => !invalidPathCharacters.Contains(p))
                                                .ToArray()));
                                using (Stream primitiveEntryDataStream = primitiveEntry.Open())
                                {
                                    using (
                                        XmlTextWriter XMLTextWriter = new XmlTextWriter(primitiveEntryDataStream,
                                            Encoding.UTF8))
                                    {
                                        XMLTextWriter.Formatting = Formatting.Indented;
                                        XMLTextWriter.WriteProcessingInstruction("xml",
                                            "version=\"1.0\" encoding=\"utf-8\"");
                                        GenerateCollada(exportMeshSet, exportMeshTextures, format)
                                            .WriteContentTo(XMLTextWriter);
                                        XMLTextWriter.Flush();
                                    }
                                }
                            }

                            // Base64-encode the zip stream and send it.
                            zipMemoryStream.Seek(0, SeekOrigin.Begin);

                            // If no path was specificed, then send the data.
                            string path =
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.PATH)),
                                    message));
                            if (string.IsNullOrEmpty(path))
                            {
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                    Convert.ToBase64String(zipMemoryStream.ToArray()));
                                return;
                            }
                            if (
                                !HasCorradePermission(commandGroup.Name, (int) Permissions.System))
                            {
                                throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                            }
                            // Otherwise, save it to the specified file.
                            using (StreamWriter fs = new StreamWriter(path, false, Encoding.UTF8))
                            {
                                zipMemoryStream.WriteTo(fs.BaseStream);
                                zipMemoryStream.Flush();
                            }
                        }
                    };
                    break;
                case ScriptKeys.GETSTATUS:
                    execute = () =>
                    {
                        uint status;
                        if (!uint.TryParse(wasInput(wasKeyValueGet(
                            wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.STATUS)),
                            message)), out status))
                        {
                            throw new ScriptException(ScriptError.INVALID_STATUS_SUPPLIED);
                        }
                        switch (wasGetEnumValueFromDescription<Entity>(
                            wasInput(
                                wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.ENTITY)),
                                    message)).ToLowerInvariant()))
                        {
                            case Entity.DESCRIPTION:
                                FieldInfo scriptErrorFieldInfo = typeof (ScriptError).GetFields(
                                    BindingFlags.Public | BindingFlags.Static)
                                    .AsParallel()
                                    .FirstOrDefault(
                                        o =>
                                            wasGetAttributeFromEnumValue<StatusAttribute>((ScriptError) o.GetValue(null))
                                                .Status.Equals(status));
                                if (scriptErrorFieldInfo == null)
                                    throw new ScriptException(ScriptError.STATUS_NOT_FOUND);
                                string description =
                                    wasGetDescriptionFromEnumValue((ScriptError) scriptErrorFieldInfo.GetValue(null));
                                if (string.IsNullOrEmpty(description))
                                    throw new ScriptException(ScriptError.NO_DESCRIPTION_FOR_STATUS);
                                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA), description);
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_ENTITY);
                        }
                    };
                    break;
                case ScriptKeys.PING:
                    execute =
                        () =>
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasGetDescriptionFromEnumValue(ScriptKeys.PONG));
                    break;
                case ScriptKeys.VERSION:
                    execute =
                        () =>
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                CORRADE_CONSTANTS.CORRADE_VERSION);
                    break;
                case ScriptKeys.DIRECTORYSEARCH:
                    execute = () =>
                    {
                        if (!HasCorradePermission(commandGroup.Name, (int) Permissions.Directory))
                        {
                            throw new ScriptException(ScriptError.NO_CORRADE_PERMISSIONS);
                        }
                        wasAdaptiveAlarm DirectorySearchResultsAlarm =
                            new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
                        string name =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.NAME)),
                                message));
                        string fields =
                            wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                message));
                        object LockObject = new object();
                        List<string> csv = new List<string>();
                        int handledEvents = 0;
                        int counter = 1;
                        switch (
                            wasGetEnumValueFromDescription<Type>(
                                wasInput(wasKeyValueGet(
                                    wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.TYPE)), message))
                                    .ToLowerInvariant()))
                        {
                            case Type.CLASSIFIED:
                                DirectoryManager.Classified searchClassified = new DirectoryManager.Classified();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchClassified);
                                Dictionary<DirectoryManager.Classified, int> classifieds =
                                    new Dictionary<DirectoryManager.Classified, int>();
                                EventHandler<DirClassifiedsReplyEventArgs> DirClassifiedsEventHandler =
                                    (sender, args) => Parallel.ForEach(args.Classifieds, o =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        int score = !string.IsNullOrEmpty(fields)
                                            ? wasGetFields(searchClassified, searchClassified.GetType().Name)
                                                .Sum(
                                                    p =>
                                                        (from q in
                                                            wasGetFields(o,
                                                                o.GetType().Name)
                                                            let r = wasGetInfoValue(p.Key, p.Value)
                                                            where r != null
                                                            let s = wasGetInfoValue(q.Key, q.Value)
                                                            where s != null
                                                            where r.Equals(s)
                                                            select r).Count())
                                            : 0;
                                        lock (LockObject)
                                        {
                                            if (!classifieds.ContainsKey(o))
                                            {
                                                classifieds.Add(o, score);
                                            }
                                        }
                                    });
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirClassifiedsReply += DirClassifiedsEventHandler;
                                    Client.Directory.StartClassifiedSearch(name);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.DirClassifiedsReply -= DirClassifiedsEventHandler;
                                }
                                Dictionary<DirectoryManager.Classified, int> safeClassifieds;
                                lock (LockObject)
                                {
                                    safeClassifieds =
                                        classifieds.OrderByDescending(o => o.Value)
                                            .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeClassifieds,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.EVENT:
                                DirectoryManager.EventsSearchData searchEvent = new DirectoryManager.EventsSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchEvent);
                                Dictionary<DirectoryManager.EventsSearchData, int> events =
                                    new Dictionary<DirectoryManager.EventsSearchData, int>();
                                EventHandler<DirEventsReplyEventArgs> DirEventsEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        handledEvents += args.MatchedEvents.Count;
                                        Parallel.ForEach(args.MatchedEvents, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchEvent, searchEvent.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!events.ContainsKey(o))
                                                {
                                                    events.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.EVENT.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.EVENT.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartEventsSearch(name, (uint) handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirEventsReply += DirEventsEventHandler;
                                    Client.Directory.StartEventsSearch(name,
                                        (uint) handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.DirEventsReply -= DirEventsEventHandler;
                                }
                                Dictionary<DirectoryManager.EventsSearchData, int> safeEvents;
                                lock (LockObject)
                                {
                                    safeEvents = events.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeEvents,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.GROUP:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new ScriptException(ScriptError.NO_SEARCH_TEXT_PROVIDED);
                                }
                                DirectoryManager.GroupSearchData searchGroup = new DirectoryManager.GroupSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchGroup);
                                Dictionary<DirectoryManager.GroupSearchData, int> groups =
                                    new Dictionary<DirectoryManager.GroupSearchData, int>();
                                EventHandler<DirGroupsReplyEventArgs> DirGroupsEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        handledEvents += args.MatchedGroups.Count;
                                        Parallel.ForEach(args.MatchedGroups, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchGroup, searchGroup.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!groups.ContainsKey(o))
                                                {
                                                    groups.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.GROUP.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.GROUP.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartGroupSearch(name, handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirGroupsReply += DirGroupsEventHandler;
                                    Client.Directory.StartGroupSearch(name, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.DirGroupsReply -= DirGroupsEventHandler;
                                }
                                Dictionary<DirectoryManager.GroupSearchData, int> safeGroups;
                                lock (LockObject)
                                {
                                    safeGroups = groups.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeGroups,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.LAND:
                                DirectoryManager.DirectoryParcel searchLand = new DirectoryManager.DirectoryParcel();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchLand);
                                Dictionary<DirectoryManager.DirectoryParcel, int> lands =
                                    new Dictionary<DirectoryManager.DirectoryParcel, int>();
                                EventHandler<DirLandReplyEventArgs> DirLandReplyEventArgs =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        handledEvents += args.DirParcels.Count;
                                        Parallel.ForEach(args.DirParcels, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchLand, searchLand.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!lands.ContainsKey(o))
                                                {
                                                    lands.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.LAND.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                                DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue,
                                                handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirLandReply += DirLandReplyEventArgs;
                                    Client.Directory.StartLandSearch(DirectoryManager.DirFindFlags.SortAsc,
                                        DirectoryManager.SearchTypeFlags.Any, int.MaxValue, int.MaxValue, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.DirLandReply -= DirLandReplyEventArgs;
                                }
                                Dictionary<DirectoryManager.DirectoryParcel, int> safeLands;
                                lock (LockObject)
                                {
                                    safeLands = lands.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeLands,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.PEOPLE:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new ScriptException(ScriptError.NO_SEARCH_TEXT_PROVIDED);
                                }
                                DirectoryManager.AgentSearchData searchAgent = new DirectoryManager.AgentSearchData();
                                Dictionary<DirectoryManager.AgentSearchData, int> agents =
                                    new Dictionary<DirectoryManager.AgentSearchData, int>();
                                EventHandler<DirPeopleReplyEventArgs> DirPeopleReplyEventHandler =
                                    (sender, args) =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        handledEvents += args.MatchedPeople.Count;
                                        Parallel.ForEach(args.MatchedPeople, o =>
                                        {
                                            int score = !string.IsNullOrEmpty(fields)
                                                ? wasGetFields(searchAgent, searchAgent.GetType().Name)
                                                    .Sum(
                                                        p =>
                                                            (from q in
                                                                wasGetFields(o, o.GetType().Name)
                                                                let r = wasGetInfoValue(p.Key, p.Value)
                                                                where r != null
                                                                let s = wasGetInfoValue(q.Key, q.Value)
                                                                where s != null
                                                                where r.Equals(s)
                                                                select r).Count())
                                                : 0;
                                            lock (LockObject)
                                            {
                                                if (!agents.ContainsKey(o))
                                                {
                                                    agents.Add(o, score);
                                                }
                                            }
                                        });
                                        if (handledEvents > LINDEN_CONSTANTS.DIRECTORY.PEOPLE.SEARCH_RESULTS_COUNT &&
                                            ((handledEvents - counter)%
                                             LINDEN_CONSTANTS.DIRECTORY.PEOPLE.SEARCH_RESULTS_COUNT).Equals(0))
                                        {
                                            ++counter;
                                            Client.Directory.StartPeopleSearch(name, handledEvents);
                                        }
                                    };
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.DirPeopleReply += DirPeopleReplyEventHandler;
                                    Client.Directory.StartPeopleSearch(name, handledEvents);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.DirPeopleReply -= DirPeopleReplyEventHandler;
                                }
                                Dictionary<DirectoryManager.AgentSearchData, int> safeAgents;
                                lock (LockObject)
                                {
                                    safeAgents = agents.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safeAgents,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            case Type.PLACE:
                                if (string.IsNullOrEmpty(name))
                                {
                                    throw new ScriptException(ScriptError.NO_SEARCH_TEXT_PROVIDED);
                                }
                                DirectoryManager.PlacesSearchData searchPlaces = new DirectoryManager.PlacesSearchData();
                                wasCSVToStructure(
                                    wasInput(
                                        wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.DATA)),
                                            message)),
                                    ref searchPlaces);
                                Dictionary<DirectoryManager.PlacesSearchData, int> places =
                                    new Dictionary<DirectoryManager.PlacesSearchData, int>();
                                EventHandler<PlacesReplyEventArgs> DirPlacesReplyEventHandler =
                                    (sender, args) => Parallel.ForEach(args.MatchedPlaces, o =>
                                    {
                                        DirectorySearchResultsAlarm.Alarm(corradeConfiguration.DataTimeout);
                                        int score = !string.IsNullOrEmpty(fields)
                                            ? wasGetFields(searchPlaces, searchPlaces.GetType().Name)
                                                .Sum(
                                                    p =>
                                                        (from q in
                                                            wasGetFields(o, o.GetType().Name)
                                                            let r = wasGetInfoValue(p.Key, p.Value)
                                                            where r != null
                                                            let s = wasGetInfoValue(q.Key, q.Value)
                                                            where s != null
                                                            where r.Equals(s)
                                                            select r).Count())
                                            : 0;
                                        lock (LockObject)
                                        {
                                            if (!places.ContainsKey(o))
                                            {
                                                places.Add(o, score);
                                            }
                                        }
                                    });
                                lock (ClientInstanceDirectoryLock)
                                {
                                    Client.Directory.PlacesReply += DirPlacesReplyEventHandler;
                                    Client.Directory.StartPlacesSearch(name);
                                    DirectorySearchResultsAlarm.Signal.WaitOne(
                                        (int) corradeConfiguration.ServicesTimeout,
                                        false);
                                    Client.Directory.PlacesReply -= DirPlacesReplyEventHandler;
                                }
                                Dictionary<DirectoryManager.PlacesSearchData, int> safePlaces;
                                lock (LockObject)
                                {
                                    safePlaces = places.OrderByDescending(o => o.Value)
                                        .ToDictionary(o => o.Key, p => p.Value);
                                }
                                Parallel.ForEach(safePlaces,
                                    o => Parallel.ForEach(wasGetFields(o.Key, o.Key.GetType().Name), p =>
                                    {
                                        lock (LockObject)
                                        {
                                            csv.Add(p.Key.Name);
                                            csv.AddRange(wasGetInfo(p.Key, p.Value));
                                        }
                                    }));
                                break;
                            default:
                                throw new ScriptException(ScriptError.UNKNOWN_DIRECTORY_SEARCH_TYPE);
                        }
                        if (csv.Any())
                        {
                            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.DATA),
                                wasEnumerableToCSV(csv));
                        }
                    };
                    break;
                default:
                    execute =
                        () => { throw new ScriptException(ScriptError.COMMAND_NOT_FOUND); };
                    break;
            }

            // sift action
            System.Action sift = () =>
            {
                string pattern =
                    wasInput(wasKeyValueGet(wasOutput(wasGetDescriptionFromEnumValue(ScriptKeys.SIFT)), message));
                if (string.IsNullOrEmpty(pattern)) return;
                string data;
                if (!result.TryGetValue(wasGetDescriptionFromEnumValue(ResultKeys.DATA), out data)) return;
                data = wasEnumerableToCSV((((new Regex(pattern, RegexOptions.Compiled)).Matches(data)
                    .AsParallel()
                    .Cast<Match>()
                    .Select(m => m.Groups)).SelectMany(
                        matchGroups => Enumerable.Range(0, matchGroups.Count).Skip(1),
                        (matchGroups, i) => new {matchGroups, i})
                    .SelectMany(@t => Enumerable.Range(0, @t.matchGroups[@t.i].Captures.Count),
                        (@t, j) => @t.matchGroups[@t.i].Captures[j].Value)));
                switch (!string.IsNullOrEmpty(data))
                {
                    case true:
                        result[wasGetDescriptionFromEnumValue(ResultKeys.DATA)] = data;
                        break;
                    default:
                        result.Remove(wasGetDescriptionFromEnumValue(ResultKeys.DATA));
                        break;
                }
            };

            // execute command, sift data and check for errors
            bool success = false;
            try
            {
                execute.Invoke();
                sift.Invoke();
                success = true;
            }
            catch (ScriptException sx)
            {
                // we have a script error so return a status as well
                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.ERROR), sx.Message);
                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.STATUS),
                    sx.Status.ToString());
            }
            catch (Exception ex)
            {
                // we have a generic exception so return the message
                result.Add(wasGetDescriptionFromEnumValue(ResultKeys.ERROR), ex.Message);
            }

            // add the final success status
            result.Add(wasGetDescriptionFromEnumValue(ResultKeys.SUCCESS),
                success.ToString(CultureInfo.DefaultThreadCurrentCulture));

            // build afterburn
            object AfterBurnLock = new object();
            HashSet<string> resultKeys = new HashSet<string>(wasGetEnumDescriptions<ResultKeys>());
            HashSet<string> scriptKeys = new HashSet<string>(wasGetEnumDescriptions<ScriptKeys>());
            Parallel.ForEach(wasKeyValueDecode(message), o =>
            {
                // remove keys that are script keys, result keys or invalid key-value pairs
                if (string.IsNullOrEmpty(o.Key) || resultKeys.Contains(wasInput(o.Key)) ||
                    scriptKeys.Contains(wasInput(o.Key)) ||
                    string.IsNullOrEmpty(o.Value))
                    return;
                lock (AfterBurnLock)
                {
                    result.Add(o.Key, o.Value);
                }
            });

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets the values from structures as strings.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="structure">the structure</param>
        /// <param name="query">a CSV list of fields or properties to get</param>
        /// <returns>value strings</returns>
        private static IEnumerable<string> GetStructuredData<T>(T structure, string query)
        {
            HashSet<string[]> result = new HashSet<string[]>();
            switch (!structure.Equals(default(T)))
            {
                case false:
                    return result.SelectMany(o => o);
            }
            List<string> data;
            object LockObject = new object();
            Parallel.ForEach(wasCSVToEnumerable(query).AsParallel().Where(o => !string.IsNullOrEmpty(o)), name =>
            {
                KeyValuePair<FieldInfo, object> fi =
                    wasGetFields(structure, structure.GetType().Name).AsParallel()
                        .FirstOrDefault(o => o.Key.Name.Equals(name, StringComparison.Ordinal));

                lock (LockObject)
                {
                    data = new List<string> {name};
                    data.AddRange(wasGetInfo(fi.Key, fi.Value));
                    if (data.Count >= 2)
                    {
                        result.Add(data.ToArray());
                    }
                }

                KeyValuePair<PropertyInfo, object> pi =
                    wasGetProperties(structure, structure.GetType().Name).AsParallel().FirstOrDefault(
                        o => o.Key.Name.Equals(name, StringComparison.Ordinal));

                lock (LockObject)
                {
                    data = new List<string> {name};
                    data.AddRange(wasGetInfo(pi.Key, pi.Value));
                    if (data.Count >= 2)
                    {
                        result.Add(data.ToArray());
                    }
                }
            });
            return result.SelectMany(o => o);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Takes as input a CSV data values and sets the corresponding
        ///     structure's fields or properties from the CSV data.
        /// </summary>
        /// <typeparam name="T">the type of the structure</typeparam>
        /// <param name="data">a CSV string</param>
        /// <param name="structure">the structure to set the fields and properties for</param>
        private static void wasCSVToStructure<T>(string data, ref T structure)
        {
            foreach (
                KeyValuePair<string, string> match in
                    wasCSVToEnumerable(data).AsParallel().Select((o, p) => new {o, p})
                        .GroupBy(q => q.p/2, q => q.o)
                        .Select(o => o.ToList())
                        .TakeWhile(o => o.Count%2 == 0)
                        .Where(o => !string.IsNullOrEmpty(o.First()) || !string.IsNullOrEmpty(o.Last()))
                        .ToDictionary(o => o.First(), p => p.Last()))
            {
                KeyValuePair<string, string> localMatch = match;
                KeyValuePair<FieldInfo, object> fi =
                    wasGetFields(structure, structure.GetType().Name)
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(fi.Key, fi.Value, match.Value, ref structure);

                KeyValuePair<PropertyInfo, object> pi =
                    wasGetProperties(structure, structure.GetType().Name)
                        .AsParallel().FirstOrDefault(
                            o =>
                                o.Key.Name.Equals(localMatch.Key,
                                    StringComparison.Ordinal));

                wasSetInfo(pi.Key, pi.Value, match.Value, ref structure);
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Sends a post request to an URL with set key-value pairs.
        /// </summary>
        /// <param name="URL">the url to send the message to</param>
        /// <param name="message">key-value pairs to send</param>
        /// <param name="millisecondsTimeout">the time in milliseconds for the request to timeout</param>
        private static void wasPOST(string URL, Dictionary<string, string> message, uint millisecondsTimeout)
        {
            HttpWebRequest request;
            byte[] byteArray;
            try
            {
                request = (HttpWebRequest) WebRequest.Create(URL);
                request.Proxy = WebRequest.DefaultWebProxy;
                request.Timeout = (int) millisecondsTimeout;
                request.AllowAutoRedirect = true;
                request.AllowWriteStreamBuffering = true;
                request.Pipelined = true;
                request.KeepAlive = true;
                request.ProtocolVersion = HttpVersion.Version11;
                request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
                request.Method = WebRequestMethods.Http.Post;
                // set the content type based on chosen output filers
                switch (corradeConfiguration.OutputFilters.Last())
                {
                    case Filter.RFC1738:
                        request.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.WWW_FORM_URLENCODED;
                        break;
                    default:
                        request.ContentType = CORRADE_CONSTANTS.CONTENT_TYPE.TEXT_PLAIN;
                        break;
                }
                request.UserAgent = CORRADE_CONSTANTS.USER_AGENT;
                byteArray =
                    Encoding.UTF8.GetBytes(wasKeyValueEncode(message));
                request.ContentLength = byteArray.Length;
            }
            catch (Exception ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_BUILDING_POST_REQUEST), URL, ex.Message);
                return;
            }

            try
            {
                using (Stream dataStream = request.GetRequestStream())
                {
                    dataStream.Write(byteArray, 0, byteArray.Length);
                }
            }
            catch (WebException ex)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SENDING_POST_REQUEST), URL, ex.Message);
            }
        }

        private static void HandleTerseObjectUpdate(object sender, TerseObjectUpdateEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.TerseUpdates, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleRadarObjects(object sender, SimChangedEventArgs e)
        {
            lock (RadarObjectsLock)
            {
                if (RadarObjects.Any())
                {
                    RadarObjects.Clear();
                }
            }
        }

        private static void HandleSimChanged(object sender, SimChangedEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.RegionCrossed, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMoneyBalance(object sender, BalanceEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Balance, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        private static void HandleMoneyBalance(object sender, MoneyBalanceReplyEventArgs e)
        {
            CorradeThreadPool[CorradeThreadType.NOTIFICATION].Spawn(
                () => SendNotification(Notifications.Economy, e),
                corradeConfiguration.MaximumNotificationThreads);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>URI unescapes an RFC3986 URI escaped string</summary>
        /// <param name="data">a string to unescape</param>
        /// <returns>the resulting string</returns>
        private static string wasURIUnescapeDataString(string data)
        {
            // Uri.UnescapeDataString can only handle 32766 characters at a time
            return string.Join("", Enumerable.Range(0, (data.Length + 32765)/32766)
                .Select(o => Uri.UnescapeDataString(data.Substring(o*32766, Math.Min(32766, data.Length - (o*32766)))))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC3986 URI Escapes a string</summary>
        /// <param name="data">a string to escape</param>
        /// <returns>an RFC3986 escaped string</returns>
        private static string wasURIEscapeDataString(string data)
        {
            // Uri.EscapeDataString can only handle 32766 characters at a time
            return string.Join("", Enumerable.Range(0, (data.Length + 32765)/32766)
                .Select(o => Uri.EscapeDataString(data.Substring(o*32766, Math.Min(32766, data.Length - (o*32766)))))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC1738 URL Escapes a string</summary>
        /// <param name="data">a string to escape</param>
        /// <returns>an RFC1738 escaped string</returns>
        private static string wasURLEscapeDataString(string data)
        {
            return HttpUtility.UrlEncode(data);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>RFC1738 URL Unescape a string</summary>
        /// <param name="data">a string to unescape</param>
        /// <returns>an RFC1738 unescaped string</returns>
        private static string wasURLUnescapeDataString(string data)
        {
            return HttpUtility.UrlDecode(data);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a list of string to a comma-separated values string.
        /// </summary>
        /// <param name="l">a list of strings</param>
        /// <returns>a commma-separated list of values</returns>
        /// <remarks>compliant with RFC 4180</remarks>
        public static string wasEnumerableToCSV(IEnumerable<string> l)
        {
            string[] csv = l.Select(o => o.Clone() as string).ToArray();
            Parallel.ForEach(csv.Select((v, i) => new {i, v}), o =>
            {
                string cell = o.v.Replace("\"", "\"\"");
                switch (new[] {'"', ' ', ',', '\r', '\n'}.Any(p => cell.Contains(p)))
                {
                    case true:
                        csv[o.i] = "\"" + cell + "\"";
                        break;
                    default:
                        csv[o.i] = cell;
                        break;
                }
            });
            return string.Join(",", csv);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Converts a comma-separated list of values to a list of strings.
        /// </summary>
        /// <param name="csv">a comma-separated list of values</param>
        /// <returns>a list of strings</returns>
        /// <remarks>compliant with RFC 4180</remarks>
        public static IEnumerable<string> wasCSVToEnumerable(string csv)
        {
            Stack<char> s = new Stack<char>();
            StringBuilder m = new StringBuilder();
            for (int i = 0; i < csv.Length; ++i)
            {
                switch (csv[i])
                {
                    case ',':
                        if (!s.Any() || !s.Peek().Equals('"'))
                        {
                            yield return m.ToString();
                            m = new StringBuilder();
                            continue;
                        }
                        m.Append(csv[i]);
                        continue;
                    case '"':
                        if (i + 1 < csv.Length && csv[i].Equals(csv[i + 1]))
                        {
                            m.Append(csv[i]);
                            ++i;
                            continue;
                        }
                        if (!s.Any() || !s.Peek().Equals(csv[i]))
                        {
                            s.Push(csv[i]);
                            continue;
                        }
                        s.Pop();
                        continue;
                }
                m.Append(csv[i]);
            }

            yield return m.ToString();
        }

        /// <summary>
        ///     Material information for Collada DAE Export.
        /// </summary>
        /// <remarks>This class is taken from the Radegast Viewer with changes by Wizardry and Steamworks.</remarks>
        private class MaterialInfo
        {
            public Color4 Color;
            public string Name;
            public UUID TextureID;

            public bool Matches(Primitive.TextureEntryFace TextureEntry)
            {
                return TextureID.Equals(TextureEntry.TextureID) && Color.Equals(TextureEntry.RGBA);
            }
        }

        /// <summary>
        ///     Constants for Corrade's integrated chat bot.
        /// </summary>
        private struct AIML_BOT_CONSTANTS
        {
            public const string DIRECTORY = @"AIMLBot";
            public const string BRAIN_FILE = @"AIMLBot.brain";
            public const string BRAIN_SESSION_FILE = @"AIMLbot.session";

            public struct AIML
            {
                public const string DIRECTORY = @"AIML";
            }

            public struct BRAIN
            {
                public const string DIRECTORY = @"brain";
            }

            public struct CONFIG
            {
                public const string DIRECTORY = @"config";
                public const string SETTINGS_FILE = @"Settings.xml";
                public const string NAME = @"NAME";
                public const string AIMLDIRECTORY = @"AIMLDIRECTORY";
                public const string CONFIGDIRECTORY = @"CONFIGDIRECTORY";
                public const string LOGDIRECTORY = @"LOGDIRECTORY";
            }

            public struct LOG
            {
                public const string DIRECTORY = @"logs";
            }
        }

        /// <summary>
        ///     Possible actions.
        /// </summary>
        private enum Action : uint
        {
            [Description("none")] NONE = 0,
            [Description("get")] GET,
            [Description("set")] SET,
            [Description("add")] ADD,
            [Description("remove")] REMOVE,
            [Description("start")] START,
            [Description("stop")] STOP,
            [Description("mute")] MUTE,
            [Description("unmute")] UNMUTE,
            [Description("restart")] RESTART,
            [Description("cancel")] CANCEL,
            [Description("accept")] ACCEPT,
            [Description("decline")] DECLINE,
            [Description("online")] ONLINE,
            [Description("offline")] OFFLINE,
            [Description("request")] REQUEST,
            [Description("response")] RESPONSE,
            [Description("delete")] DELETE,
            [Description("take")] TAKE,
            [Description("read")] READ,
            [Description("wrtie")] WRITE,
            [Description("purge")] PURGE,
            [Description("crossed")] CROSSED,
            [Description("changed")] CHANGED,
            [Description("reply")] REPLY,
            [Description("offer")] OFFER,
            [Description("generic")] GENERIC,
            [Description("point")] POINT,
            [Description("look")] LOOK,
            [Description("update")] UPDATE,
            [Description("received")] RECEIVED,
            [Description("joined")] JOINED,
            [Description("parted")] PARTED,
            [Description("save")] SAVE,
            [Description("load")] LOAD,
            [Description("enable")] ENABLE,
            [Description("disable")] DISABLE,
            [Description("process")] PROCESS,
            [Description("rebuild")] REBUILD,
            [Description("clear")] CLEAR,
            [Description("ls")] LS,
            [Description("cwd")] CWD,
            [Description("cd")] CD,
            [Description("mkdir")] MKDIR,
            [Description("chmod")] CHMOD,
            [Description("rm")] RM,
            [Description("ln")] LN,
            [Description("mv")] MV,
            [Description("cp")] CP,
            [Description("appear")] APPEAR,
            [Description("vanish")] VANISH,
            [Description("list")] LIST,
            [Description("link")] LINK,
            [Description("delink")] DELINK,
            [Description("ban")] BAN,
            [Description("unban")] UNBAN
        }

        /// <summary>
        ///     Agent structure.
        /// </summary>
        private struct Agent
        {
            [Description("firstname")] public string FirstName;

            [Description("lastname")] public string LastName;

            [Description("uuid")] public UUID UUID;
        }

        /// <summary>
        ///     A structure to track Beam effects.
        /// </summary>
        private struct BeamEffect
        {
            [Description("alpha")] public float Alpha;

            [Description("color")] public Vector3 Color;

            [Description("duration")] public float Duration;

            [Description("effect")] public UUID Effect;

            [Description("offset")] public Vector3d Offset;

            [Description("source")] public UUID Source;

            [Description("target")] public UUID Target;

            [Description("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     Constants used by Corrade.
        /// </summary>
        private struct CORRADE_CONSTANTS
        {
            /// <summary>
            ///     Copyright.
            /// </summary>
            public const string COPYRIGHT = @"(c) Copyright 2013 Wizardry and Steamworks";

            public const string WIZARDRY_AND_STEAMWORKS = @"Wizardry and Steamworks";
            public const string CORRADE = @"Corrade";
            public const string WIZARDRY_AND_STEAMWORKS_WEBSITE = @"http://grimore.org";

            /// <summary>
            ///     Censor characters for passwords.
            /// </summary>
            public const string PASSWORD_CENSOR = "***";

            /// <summary>
            ///     Corrade channel sent to the simulator.
            /// </summary>
            public const string CLIENT_CHANNEL = @"[Wizardry and Steamworks]:Corrade";

            public const string CURRENT_OUTFIT_FOLDER_NAME = @"Current Outfit";
            public const string DEFAULT_SERVICE_NAME = @"Corrade";
            public const string LOG_FACILITY = @"Application";
            public const string WEB_REQUEST = @"Web Request";
            public const string CONFIGURATION_FILE = @"Corrade.ini";
            public const string DATE_TIME_STAMP = @"dd-MM-yyyy HH:mm";
            public const string INVENTORY_CACHE_FILE = @"Inventory.cache";
            public const string AGENT_CACHE_FILE = @"Agent.cache";
            public const string GROUP_CACHE_FILE = @"Group.cache";
            public const string PATH_SEPARATOR = @"/";
            public const string ERROR_SEPARATOR = @" : ";
            public const string CACHE_DIRECTORY = @"cache";
            public const string ASSET_CACHE_DIRECTORY = @"assets";
            public const string LOG_FILE_EXTENSION = @"log";
            public const string STATE_DIRECTORY = @"state";
            public const string NOTIFICATIONS_STATE_FILE = @"Notifications.state";
            public const string GROUP_MEMBERS_STATE_FILE = @"GroupMembers.state";
            public const string LINDEN_GLOBALIZATION_FILE = @"LindenGlobalization.xml";
            public const string LINDEN_GLOBALIZATION_NAME = @"Linden-Lab";

            public static readonly Regex AvatarFullNameRegex = new Regex(@"^(?<first>.*?)([\s\.]|$)(?<last>.*?)$",
                RegexOptions.Compiled);

            public static readonly Regex OneOrMoRegex = new Regex(@".+?", RegexOptions.Compiled);

            public static readonly Regex InventoryOfferObjectNameRegEx = new Regex(@"^[']{0,1}(.+?)(('\s)|$)",
                RegexOptions.Compiled);

            public static readonly Regex EjectedFromGroupRegEx =
                new Regex(@"You have been ejected from '(.+?)' by .+?\.$", RegexOptions.Compiled);

            /// <summary>
            ///     Corrade version.
            /// </summary>
            public static readonly string CORRADE_VERSION = Assembly.GetEntryAssembly().GetName().Version.ToString();

            /// <summary>
            ///     Corrade user agent.
            /// </summary>
            public static readonly string USER_AGENT = string.Format("{0}/{1} ({2})", CORRADE,
                CORRADE_VERSION,
                WIZARDRY_AND_STEAMWORKS_WEBSITE);

            /// <summary>
            ///     Corrade compile date.
            /// </summary>
            public static readonly string CORRADE_COMPILE_DATE = new DateTime(2000, 1, 1).Add(new TimeSpan(
                TimeSpan.TicksPerDay*Assembly.GetEntryAssembly().GetName().Version.Build + // days since 1 January 2000
                TimeSpan.TicksPerSecond*2*Assembly.GetEntryAssembly().GetName().Version.Revision)).ToLongDateString();

            /// <summary>
            ///     Corrade Logo.
            /// </summary>
            public static readonly List<string> LOGO = new List<string>
            {
                @"",
                @"       _..--=--..._  ",
                @"    .-'            '-.  .-.  ",
                @"   /.'              '.\/  /  ",
                @"  |=-     Corrade    -=| (  ",
                @"   \'.              .'/\  \  ",
                @"    '-.,_____ _____.-'  '-'  ",
                @"          [_____]=8  ",
                @"               \  ",
                @"                 Good day!  ",
                @"",
                string.Format(CultureInfo.DefaultThreadCurrentCulture, "Version: {0}, Compiled: {1}", CORRADE_VERSION,
                    CORRADE_COMPILE_DATE),
                string.Format(CultureInfo.DefaultThreadCurrentCulture, "Copyright: {0}", COPYRIGHT)
            };

            /// <summary>
            ///     Conten-types that Corrade can send and receive.
            /// </summary>
            public struct CONTENT_TYPE
            {
                public const string TEXT_PLAIN = @"text/plain";
                public const string WWW_FORM_URLENCODED = @"application/x-www-form-urlencoded";
            }

            public struct PERMISSIONS
            {
                public const string NONE = @"------------------------------";
            }

            public struct PRIMTIVE_BODIES
            {
                [Description("cube")] public static readonly Primitive.ConstructionData CUBE = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("prism")] public static readonly Primitive.ConstructionData PRISM = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 1.0f,
                    PathShearX = -0.5f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("pyramid")] public static readonly Primitive.ConstructionData PYRAMID = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Square,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("tetrahedron")] public static readonly Primitive.ConstructionData TETRAHEDRON = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.EqualTriangle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("cylinder")] public static readonly Primitive.ConstructionData CYLINDER = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("hemicylinder")] public static readonly Primitive.ConstructionData HEMICYLINDER = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.25f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 0.75f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("cone")] public static readonly Primitive.ConstructionData CONE = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("hemicone")] public static readonly Primitive.ConstructionData HEMICONE = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0f,
                    PathCurve = PathCurve.Line,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 0.0f,
                    PathScaleY = 0.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.25f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 0.75f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("sphere")] public static readonly Primitive.ConstructionData SPHERE = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.HalfCircle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("hemisphere")] public static readonly Primitive.ConstructionData HEMISPHERE = new Primitive
                    .ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 0.5f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 1.0f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.HalfCircle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("torus")] public static readonly Primitive.ConstructionData TORUS = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 0.25f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.Circle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };

                [Description("ring")] public static readonly Primitive.ConstructionData RING = new Primitive.
                    ConstructionData
                {
                    AttachmentPoint = AttachmentPoint.Default,
                    Material = Material.Wood,
                    PathBegin = 0.0f,
                    PathCurve = PathCurve.Circle,
                    PathEnd = 1.0f,
                    PathRadiusOffset = 0.0f,
                    PathRevolutions = 1.0f,
                    PathScaleX = 1.0f,
                    PathScaleY = 0.25f,
                    PathShearX = 0.0f,
                    PathShearY = 0.0f,
                    PathSkew = 0.0f,
                    PathTaperX = 0.0f,
                    PathTaperY = 0.0f,
                    PathTwistBegin = 0.0f,
                    PCode = PCode.Prim,
                    ProfileBegin = 0.0f,
                    ProfileCurve = ProfileCurve.EqualTriangle,
                    ProfileEnd = 1.0f,
                    ProfileHole = HoleType.Same,
                    ProfileHollow = 0.0f,
                    State = 0
                };
            }
        }

        /// <summary>
        ///     Corrade's caches.
        /// </summary>
        public struct Cache
        {
            public static HashSet<Agents> AgentCache = new HashSet<Agents>();
            public static HashSet<Groups> GroupCache = new HashSet<Groups>();
            public static HashSet<UUID> CurrentGroupsCache = new HashSet<UUID>();
            public static HashSet<MuteEntry> MutesCache = new HashSet<MuteEntry>();

            internal static void Purge()
            {
                lock (Locks.AgentCacheLock)
                {
                    AgentCache.Clear();
                }
                lock (Locks.GroupCacheLock)
                {
                    GroupCache.Clear();
                }
                lock (Locks.CurrentGroupsCacheLock)
                {
                    CurrentGroupsCache.Clear();
                }
                lock (Locks.MutesCacheLock)
                {
                    MutesCache.Clear();
                }
            }

            public static void AddAgent(string FirstName, string LastName, UUID agentUUID)
            {
                Agents agent = new Agents
                {
                    FirstName = FirstName,
                    LastName = LastName,
                    UUID = agentUUID
                };

                lock (Locks.AgentCacheLock)
                {
                    if (!AgentCache.Contains(agent))
                    {
                        AgentCache.Add(agent);
                    }
                }
            }

            public static Agents GetAgent(string FirstName, string LastName)
            {
                lock (Locks.AgentCacheLock)
                {
                    return AgentCache.AsParallel().FirstOrDefault(
                        o =>
                            o.FirstName.Equals(FirstName, StringComparison.OrdinalIgnoreCase) &&
                            o.LastName.Equals(LastName, StringComparison.OrdinalIgnoreCase));
                }
            }

            public static Agents GetAgent(UUID agentUUID)
            {
                lock (Locks.AgentCacheLock)
                {
                    return AgentCache.AsParallel().FirstOrDefault(o => o.UUID.Equals(agentUUID));
                }
            }

            public static void AddGroup(string GroupName, UUID GroupUUID)
            {
                Groups group = new Groups
                {
                    Name = GroupName,
                    UUID = GroupUUID
                };
                lock (Locks.GroupCacheLock)
                {
                    if (!GroupCache.Contains(group))
                    {
                        GroupCache.Add(group);
                    }
                }
            }

            /// <summary>
            ///     Serializes to a file.
            /// </summary>
            /// <param name="FileName">File path of the new xml file</param>
            /// <param name="o">the object to save</param>
            public static void Save<T>(string FileName, T o)
            {
                try
                {
                    using (StreamWriter writer = new StreamWriter(FileName, false, Encoding.UTF8))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (T));
                        serializer.Serialize(writer, o);
                        writer.Flush();
                    }
                }
                catch (Exception e)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_CACHE), e.Message);
                }
            }

            /// <summary>
            ///     Load an object from an xml file
            /// </summary>
            /// <param name="FileName">Xml file name</param>
            /// <param name="o">the object to load to</param>
            /// <returns>The object created from the xml file</returns>
            public static T Load<T>(string FileName, T o)
            {
                if (!File.Exists(FileName)) return o;
                try
                {
                    using (StreamReader stream = new StreamReader(FileName, Encoding.UTF8))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (T));
                        return (T) serializer.Deserialize(stream);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_CACHE), ex.Message);
                }
                return o;
            }

            public struct Agents
            {
                public string FirstName;
                public string LastName;
                public UUID UUID;
            }

            public struct Groups
            {
                public string Name;
                public UUID UUID;
            }

            public struct Locks
            {
                public static readonly object AgentCacheLock = new object();
                public static readonly object GroupCacheLock = new object();
                public static readonly object CurrentGroupsCacheLock = new object();
                public static readonly object MutesCacheLock = new object();
            }
        }

        /// <summary>
        ///     An element from the callback queue waiting to be dispatched.
        /// </summary>
        private struct CallbackQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
        }

        [Serializable]
        public class CorradeConfiguration
        {
            private uint _activateDelay = 5000;
            private bool _autoActivateGroup;
            private string _bindIPAddress = string.Empty;
            private uint _callbackQueueLength = 100;
            private uint _callbackThrottle = 1000;
            private uint _callbackTimeout = 5000;
            private bool _clientLogEnabled = true;
            private string _clientLogFile = "logs/Corrade.log";
            private uint _connectionIdleTime = 900000;
            private uint _connectionLimit = 100;
            private wasAdaptiveAlarm.DECAY_TYPE _dataDecayType = wasAdaptiveAlarm.DECAY_TYPE.ARITHMETIC;
            private uint _dataTimeout = 2500;
            private string _driveIdentifierHash = string.Empty;
            private bool _enableAIML;
            private bool _enableHTTPServer;
            private bool _enableRLV;

            private ENIGMA _enigma = new ENIGMA
            {
                rotors = new[] {'3', 'g', '1'},
                plugs = new[] {'z', 'p', 'q'},
                reflector = 'b'
            };

            private int _exitCodeAbnormal = -2;
            private int _exitCodeExpected = -1;
            private string _firstName = string.Empty;
            private uint _groupCreateFee = 100;
            private HashSet<Group> _groups = new HashSet<Group>();
            private uint _HTTPServerBodyTimeout = 5000;
            private HTTPCompressionMethod _HTTPServerCompression = HTTPCompressionMethod.NONE;
            private uint _HTTPServerDrainTimeout = 10000;
            private uint _HTTPServerHeaderTimeout = 2500;
            private uint _HTTPServerIdleTimeout = 2500;
            private bool _HTTPServerKeepAlive = true;
            private string _HTTPServerPrefix = @"http://+:8080/";
            private uint _HTTPServerQueueTimeout = 10000;
            private uint _HTTPServerTimeout = 5000;
            private List<Filter> _inputFilters = new List<Filter>();
            private string _instantMessageLogDirectory = @"logs/im";
            private bool _instantMessageLogEnabled;
            private string _lastName = string.Empty;
            private string _localMessageLogDirectory = @"logs/local";
            private bool _localMessageLogEnabled;
            private string _loginURL = @"https://login.agni.lindenlab.com/cgi-bin/login.cgi";
            private uint _logoutGrace = 2500;
            private HashSet<Master> _masters = new HashSet<Master>();
            private uint _maximumCommandThreads = 10;
            private uint _maximumInstantMessageThreads = 10;
            private uint _maximumLogThreads = 20;
            private uint _maximumNotificationThreads = 10;
            private uint _maximumPOSTThreads = 25;
            private uint _maximumRLVThreads = 10;
            private uint _membershipSweepInterval = 60000;
            private string _networkCardMAC = string.Empty;
            private uint _notificationQueueLength = 100;
            private uint _notificationThrottle = 1000;
            private uint _notificationTimeout = 5000;
            private List<Filter> _outputFilters = new List<Filter>();
            private string _password = string.Empty;
            private float _range = 64;
            private uint _rebakeDelay = 1000;
            private string _regionMessageLogDirectory = @"logs/region";
            private bool _regionMessageLogEnabled;
            private uint _schedulerExpiration = 60000;
            private uint _servicesTimeout = 60000;
            private string _startLocation = "last";
            private uint _throttleAsset = 100000;
            private uint _throttleCloud = 10000;
            private uint _throttleLand = 80000;
            private uint _throttleResend = 100000;
            private uint _throttleTask = 200000;
            private uint _throttleTexture = 100000;
            private uint _throttleTotal = 600000;
            private uint _throttleWind = 10000;
            private bool _TOSAccepted;
            private bool _useExpect100Continue;
            private bool _useNaggle;
            private string _vigenereSecret = string.Empty;

            public string FirstName
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _firstName;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _firstName = value;
                    }
                }
            }

            public string LastName
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _lastName;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _lastName = value;
                    }
                }
            }

            public string Password
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _password;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _password = value;
                    }
                }
            }

            public string LoginURL
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _loginURL;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _loginURL = value;
                    }
                }
            }

            public string InstantMessageLogDirectory
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _instantMessageLogDirectory;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _instantMessageLogDirectory = value;
                    }
                }
            }

            public bool InstantMessageLogEnabled
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _instantMessageLogEnabled;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _instantMessageLogEnabled = value;
                    }
                }
            }

            public string LocalMessageLogDirectory
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _localMessageLogDirectory;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _localMessageLogDirectory = value;
                    }
                }
            }

            public bool LocalMessageLogEnabled
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _localMessageLogEnabled;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _localMessageLogEnabled = value;
                    }
                }
            }

            public string RegionMessageLogDirectory
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _regionMessageLogDirectory;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _regionMessageLogDirectory = value;
                    }
                }
            }

            public bool RegionMessageLogEnabled
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _regionMessageLogEnabled;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _regionMessageLogEnabled = value;
                    }
                }
            }

            public bool EnableHTTPServer
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enableHTTPServer;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enableHTTPServer = value;
                    }
                }
            }

            public bool EnableAIML
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enableAIML;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enableAIML = value;
                    }
                }
            }

            public bool EnableRLV
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enableRLV;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enableRLV = value;
                    }
                }
            }

            public string HTTPServerPrefix
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerPrefix;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerPrefix = value;
                    }
                }
            }

            public uint HTTPServerTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerTimeout = value;
                    }
                }
            }

            public uint HTTPServerDrainTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerDrainTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerDrainTimeout = value;
                    }
                }
            }

            public uint HTTPServerBodyTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerBodyTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerBodyTimeout = value;
                    }
                }
            }

            public uint HTTPServerHeaderTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerHeaderTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerHeaderTimeout = value;
                    }
                }
            }

            public uint HTTPServerIdleTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerIdleTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerIdleTimeout = value;
                    }
                }
            }

            public uint HTTPServerQueueTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerQueueTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerQueueTimeout = value;
                    }
                }
            }

            public HTTPCompressionMethod HTTPServerCompression
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerCompression;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerCompression = value;
                    }
                }
            }

            public uint ThrottleTotal
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleTotal;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleTotal = value;
                    }
                }
            }

            public uint ThrottleLand
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleLand;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleLand = value;
                    }
                }
            }

            public uint ThrottleTask
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleTask;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleTask = value;
                    }
                }
            }

            public uint ThrottleTexture
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleTexture;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleTexture = value;
                    }
                }
            }

            public uint ThrottleWind
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleWind;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleWind = value;
                    }
                }
            }

            public uint ThrottleResend
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleResend;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleResend = value;
                    }
                }
            }

            public uint ThrottleAsset
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleAsset;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleAsset = value;
                    }
                }
            }

            public uint ThrottleCloud
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _throttleCloud;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _throttleCloud = value;
                    }
                }
            }

            public bool HTTPServerKeepAlive
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _HTTPServerKeepAlive;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _HTTPServerKeepAlive = value;
                    }
                }
            }

            public uint CallbackTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackTimeout = value;
                    }
                }
            }

            public uint CallbackThrottle
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackThrottle;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackThrottle = value;
                    }
                }
            }

            public uint CallbackQueueLength
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _callbackQueueLength;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _callbackQueueLength = value;
                    }
                }
            }

            public uint NotificationTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationTimeout = value;
                    }
                }
            }

            public uint NotificationThrottle
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationThrottle;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationThrottle = value;
                    }
                }
            }

            public uint NotificationQueueLength
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _notificationQueueLength;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _notificationQueueLength = value;
                    }
                }
            }

            public uint ConnectionLimit
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _connectionLimit;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _connectionLimit = value;
                    }
                }
            }

            public uint ConnectionIdleTime
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _connectionIdleTime;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _connectionIdleTime = value;
                    }
                }
            }

            public float Range
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _range;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _range = value;
                    }
                }
            }

            public uint SchedulerExpiration
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _schedulerExpiration;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _schedulerExpiration = value;
                    }
                }
            }

            public uint MaximumNotificationThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumNotificationThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumNotificationThreads = value;
                    }
                }
            }

            public uint MaximumCommandThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumCommandThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumCommandThreads = value;
                    }
                }
            }

            public uint MaximumRLVThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumRLVThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumRLVThreads = value;
                    }
                }
            }

            public uint MaximumInstantMessageThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumInstantMessageThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumInstantMessageThreads = value;
                    }
                }
            }

            public uint MaximumLogThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumLogThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumLogThreads = value;
                    }
                }
            }

            public uint MaximumPOSTThreads
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _maximumPOSTThreads;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _maximumPOSTThreads = value;
                    }
                }
            }

            public bool UseNaggle
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _useNaggle;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _useNaggle = value;
                    }
                }
            }

            public bool UseExpect100Continue
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _useExpect100Continue;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _useExpect100Continue = value;
                    }
                }
            }

            public uint ServicesTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _servicesTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _servicesTimeout = value;
                    }
                }
            }

            public uint DataTimeout
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _dataTimeout;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _dataTimeout = value;
                    }
                }
            }

            public wasAdaptiveAlarm.DECAY_TYPE DataDecayType
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _dataDecayType;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _dataDecayType = value;
                    }
                }
            }

            public uint RebakeDelay
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _rebakeDelay;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _rebakeDelay = value;
                    }
                }
            }

            public uint MembershipSweepInterval
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _membershipSweepInterval;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _membershipSweepInterval = value;
                    }
                }
            }

            public bool TOSAccepted
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _TOSAccepted;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _TOSAccepted = value;
                    }
                }
            }

            public string StartLocation
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _startLocation;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _startLocation = value;
                    }
                }
            }

            public string BindIPAddress
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _bindIPAddress;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _bindIPAddress = value;
                    }
                }
            }

            public string NetworkCardMAC
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _networkCardMAC;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _networkCardMAC = value;
                    }
                }
            }

            public string DriveIdentifierHash
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _driveIdentifierHash;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _driveIdentifierHash = value;
                    }
                }
            }

            public string ClientLogFile
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _clientLogFile;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _clientLogFile = value;
                    }
                }
            }

            public bool ClientLogEnabled
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _clientLogEnabled;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _clientLogEnabled = value;
                    }
                }
            }

            public bool AutoActivateGroup
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _autoActivateGroup;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _autoActivateGroup = value;
                    }
                }
            }

            public uint ActivateDelay
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _activateDelay;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _activateDelay = value;
                    }
                }
            }

            public uint GroupCreateFee
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _groupCreateFee;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _groupCreateFee = value;
                    }
                }
            }

            public int ExitCodeExpected
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _exitCodeExpected;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _exitCodeExpected = value;
                    }
                }
            }

            public int ExitCodeAbnormal
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _exitCodeAbnormal;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _exitCodeAbnormal = value;
                    }
                }
            }

            public HashSet<Group> Groups
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _groups;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _groups = value;
                    }
                }
            }

            public HashSet<Master> Masters
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _masters;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _masters = value;
                    }
                }
            }

            public List<Filter> InputFilters
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return !_inputFilters.Any() ? new List<Filter> {Filter.RFC1738} : _inputFilters;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _inputFilters = value;
                    }
                }
            }

            public List<Filter> OutputFilters
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return !_outputFilters.Any() ? new List<Filter> {Filter.RFC1738} : _outputFilters;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _outputFilters = value;
                    }
                }
            }

            public string VIGENERESecret
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _vigenereSecret;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _vigenereSecret = value;
                    }
                }
            }

            public ENIGMA ENIGMA
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _enigma;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _enigma = value;
                    }
                }
            }

            public uint LogoutGrace
            {
                get
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        return _logoutGrace;
                    }
                }
                set
                {
                    lock (ClientInstanceConfigurationLock)
                    {
                        _logoutGrace = value;
                    }
                }
            }

            public void Save(string file, ref CorradeConfiguration configuration)
            {
                try
                {
                    using (StreamWriter writer = new StreamWriter(file, false, Encoding.UTF8))
                    {
                        XmlSerializer serializer = new XmlSerializer(typeof (CorradeConfiguration));
                        serializer.Serialize(writer, configuration);
                        writer.Flush();
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_SAVE_CORRADE_CONFIGURATION),
                        ex.Message);
                }
            }

            public void Load(string file, ref CorradeConfiguration configuration)
            {
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READING_CORRADE_CONFIGURATION));
                try
                {
                    using (StreamReader stream = new StreamReader(file, Encoding.UTF8))
                    {
                        XmlSerializer serializer =
                            new XmlSerializer(typeof (CorradeConfiguration));
                        configuration = (CorradeConfiguration) serializer.Deserialize(stream);
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.UNABLE_TO_LOAD_CORRADE_CONFIGURATION),
                        ex.Message);
                    return;
                }
                UpdateDynamicConfiguration(configuration);
                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.READ_CORRADE_CONFIGURATION));
            }

            public void UpdateDynamicConfiguration(CorradeConfiguration configuration)
            {
                // Enable AIML in case it was enabled in the configuration file.
                try
                {
                    switch (configuration.EnableAIML)
                    {
                        case true:
                            switch (!AIMLBotBrainCompiled)
                            {
                                case true:
                                    new Thread(
                                        () =>
                                        {
                                            lock (AIMLBotLock)
                                            {
                                                LoadChatBotFiles.Invoke();
                                                AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                            }
                                        })
                                    {IsBackground = true, Priority = ThreadPriority.Lowest}.Start();
                                    break;
                                default:
                                    AIMLBotConfigurationWatcher.EnableRaisingEvents = true;
                                    AIMLBot.isAcceptingUserInput = true;
                                    break;
                            }
                            break;
                        default:
                            AIMLBotConfigurationWatcher.EnableRaisingEvents = false;
                            AIMLBot.isAcceptingUserInput = false;
                            break;
                    }
                }
                catch (Exception ex)
                {
                    Feedback(wasGetDescriptionFromEnumValue(ConsoleError.ERROR_SETTING_UP_AIML_CONFIGURATION_WATCHER),
                        ex.Message);
                }

                // Dynamically disable or enable notifications.
                Parallel.ForEach(wasGetEnumDescriptions<Notifications>().AsParallel().Select(
                    wasGetEnumValueFromDescription<Notifications>), o =>
                    {
                        bool enabled = configuration.Groups.AsParallel().Any(
                            p =>
                                !(p.NotificationMask & (uint) o).Equals(0));
                        switch (o)
                        {
                            case Notifications.GroupMembership:
                                switch (enabled)
                                {
                                    case true:
                                        // Start the group membership thread.
                                        StartGroupMembershipSweepThread.Invoke();
                                        break;
                                    default:
                                        // Stop the group sweep thread.
                                        StopGroupMembershipSweepThread.Invoke();
                                        break;
                                }
                                break;
                            case Notifications.Friendship:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Friends.FriendshipOffered += HandleFriendshipOffered;
                                        Client.Friends.FriendshipResponse += HandleFriendShipResponse;
                                        Client.Friends.FriendOnline += HandleFriendOnlineStatus;
                                        Client.Friends.FriendOffline += HandleFriendOnlineStatus;
                                        Client.Friends.FriendRightsUpdate += HandleFriendRightsUpdate;
                                        break;
                                    default:
                                        Client.Friends.FriendshipOffered -= HandleFriendshipOffered;
                                        Client.Friends.FriendshipResponse -= HandleFriendShipResponse;
                                        Client.Friends.FriendOnline -= HandleFriendOnlineStatus;
                                        Client.Friends.FriendOffline -= HandleFriendOnlineStatus;
                                        Client.Friends.FriendRightsUpdate -= HandleFriendRightsUpdate;
                                        break;
                                }
                                break;
                            case Notifications.ScriptPermission:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.ScriptQuestion += HandleScriptQuestion;
                                        break;
                                    default:
                                        Client.Self.ScriptQuestion -= HandleScriptQuestion;
                                        break;
                                }
                                break;
                            case Notifications.AlertMessage:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.AlertMessage += HandleAlertMessage;
                                        break;
                                    default:
                                        Client.Self.AlertMessage -= HandleAlertMessage;
                                        break;
                                }
                                break;
                            case Notifications.Balance:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MoneyBalance += HandleMoneyBalance;
                                        break;
                                    default:
                                        Client.Self.MoneyBalance -= HandleMoneyBalance;
                                        break;
                                }
                                break;
                            case Notifications.Economy:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MoneyBalanceReply += HandleMoneyBalance;
                                        break;
                                    default:
                                        Client.Self.MoneyBalanceReply -= HandleMoneyBalance;
                                        break;
                                }
                                break;
                            case Notifications.ScriptDialog:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.ScriptDialog += HandleScriptDialog;
                                        break;
                                    default:
                                        Client.Self.ScriptDialog -= HandleScriptDialog;
                                        break;
                                }
                                break;
                            case Notifications.TerseUpdates:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Objects.TerseObjectUpdate += HandleTerseObjectUpdate;
                                        break;
                                    default:
                                        Client.Objects.TerseObjectUpdate -= HandleTerseObjectUpdate;
                                        break;
                                }
                                break;
                            case Notifications.ViewerEffect:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Avatars.ViewerEffect += HandleViewerEffect;
                                        Client.Avatars.ViewerEffectPointAt += HandleViewerEffect;
                                        Client.Avatars.ViewerEffectLookAt += HandleViewerEffect;
                                        break;
                                    default:
                                        Client.Avatars.ViewerEffect -= HandleViewerEffect;
                                        Client.Avatars.ViewerEffectPointAt -= HandleViewerEffect;
                                        Client.Avatars.ViewerEffectLookAt -= HandleViewerEffect;
                                        break;
                                }
                                break;
                            case Notifications.MeanCollision:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.MeanCollision += HandleMeanCollision;
                                        break;
                                    default:
                                        Client.Self.MeanCollision -= HandleMeanCollision;
                                        break;
                                }
                                break;
                            case Notifications.RegionCrossed:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.RegionCrossed += HandleRegionCrossed;
                                        Client.Network.SimChanged += HandleSimChanged;
                                        break;
                                    default:
                                        Client.Self.RegionCrossed -= HandleRegionCrossed;
                                        Client.Network.SimChanged -= HandleSimChanged;
                                        break;
                                }
                                break;
                            case Notifications.LoadURL:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.LoadURL += HandleLoadURL;
                                        break;
                                    default:
                                        Client.Self.LoadURL -= HandleLoadURL;
                                        break;
                                }
                                break;
                            case Notifications.ScriptControl:
                                switch (enabled)
                                {
                                    case true:
                                        Client.Self.ScriptControlChange += HandleScriptControlChange;
                                        break;
                                    default:
                                        Client.Self.ScriptControlChange -= HandleScriptControlChange;
                                        break;
                                }
                                break;
                        }
                    });

                // Depending on whether groups have bound to the viewer effects notification, 
                // start or stop the viwer effect expiration thread.
                switch (
                    configuration.Groups.AsParallel()
                        .Any(o => !(o.NotificationMask & (uint) Notifications.ViewerEffect).Equals(0)))
                {
                    case true:
                        // Don't start if the expiration thread is already started.
                        if (EffectsExpirationThread != null) return;
                        // Start sphere and beam effect expiration thread
                        runEffectsExpirationThread = true;
                        EffectsExpirationThread = new Thread(() =>
                        {
                            do
                            {
                                Thread.Sleep(1000);
                                lock (SphereEffectsLock)
                                {
                                    SphereEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                                }
                                lock (BeamEffectsLock)
                                {
                                    BeamEffects.RemoveWhere(o => DateTime.Compare(DateTime.Now, o.Termination) > 0);
                                }
                            } while (runEffectsExpirationThread);
                        })
                        {IsBackground = true, Priority = ThreadPriority.Lowest};
                        EffectsExpirationThread.Start();
                        break;
                    default:
                        runEffectsExpirationThread = false;
                        try
                        {
                            if (EffectsExpirationThread != null)
                            {
                                if (
                                    (EffectsExpirationThread.ThreadState.Equals(ThreadState.Running) ||
                                     EffectsExpirationThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                                {
                                    if (!EffectsExpirationThread.Join(1000))
                                    {
                                        EffectsExpirationThread.Abort();
                                        EffectsExpirationThread.Join();
                                    }
                                }
                            }
                        }
                        catch (Exception)
                        {
                            /* We are going down and we do not care. */
                        }
                        finally
                        {
                            EffectsExpirationThread = null;
                        }
                        break;
                }

                // Depending on whether any group has bound either the avatar radar notification, 
                // or the primitive radar notification, install or uinstall the listeners.
                switch (
                    configuration.Groups.AsParallel().Any(
                        o =>
                            !(o.NotificationMask & (uint) Notifications.RadarAvatars).Equals(0) ||
                            !(o.NotificationMask & (uint) Notifications.RadarPrimitives).Equals(0)))
                {
                    case true:
                        Client.Network.SimChanged += HandleRadarObjects;
                        Client.Objects.AvatarUpdate += HandleAvatarUpdate;
                        Client.Objects.ObjectUpdate += HandleObjectUpdate;
                        Client.Objects.KillObject += HandleKillObject;
                        break;
                    default:
                        Client.Network.SimChanged -= HandleRadarObjects;
                        Client.Objects.AvatarUpdate -= HandleAvatarUpdate;
                        Client.Objects.ObjectUpdate -= HandleObjectUpdate;
                        Client.Objects.KillObject -= HandleKillObject;
                        break;
                }

                // Enable the HTTP server in case it is supported and it was enabled in the configuration file.
                switch (HttpListener.IsSupported)
                {
                    case true:
                        switch (configuration.EnableHTTPServer)
                        {
                            case true:
                                // Don't start if the HTTP server is already started.
                                if (HTTPListenerThread != null) return;
                                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.STARTING_HTTP_SERVER));
                                runHTTPServer = true;
                                HTTPListenerThread = new Thread(() =>
                                {
                                    try
                                    {
                                        using (HTTPListener = new HttpListener())
                                        {
                                            HTTPListener.Prefixes.Add(configuration.HTTPServerPrefix);
                                            HTTPListener.TimeoutManager.DrainEntityBody =
                                                TimeSpan.FromMilliseconds(configuration.HTTPServerDrainTimeout);
                                            HTTPListener.TimeoutManager.EntityBody =
                                                TimeSpan.FromMilliseconds(configuration.HTTPServerBodyTimeout);
                                            HTTPListener.TimeoutManager.HeaderWait =
                                                TimeSpan.FromMilliseconds(configuration.HTTPServerHeaderTimeout);
                                            HTTPListener.TimeoutManager.IdleConnection =
                                                TimeSpan.FromMilliseconds(configuration.HTTPServerIdleTimeout);
                                            HTTPListener.TimeoutManager.RequestQueue =
                                                TimeSpan.FromMilliseconds(configuration.HTTPServerQueueTimeout);
                                            HTTPListener.Start();
                                            while (runHTTPServer && HTTPListener.IsListening)
                                            {
                                                (HTTPListener.BeginGetContext(ProcessHTTPRequest,
                                                    HTTPListener)).AsyncWaitHandle.WaitOne(
                                                        (int) configuration.HTTPServerTimeout,
                                                        false);
                                            }
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR),
                                            ex.Message);
                                    }
                                })
                                {IsBackground = true, Priority = ThreadPriority.Lowest};
                                HTTPListenerThread.Start();
                                break;
                            default:
                                Feedback(wasGetDescriptionFromEnumValue(ConsoleError.STOPPING_HTTP_SERVER));
                                runHTTPServer = false;
                                try
                                {
                                    if (HTTPListenerThread != null)
                                    {
                                        HTTPListener.Stop();
                                        if (
                                            (HTTPListenerThread.ThreadState.Equals(ThreadState.Running) ||
                                             HTTPListenerThread.ThreadState.Equals(ThreadState.WaitSleepJoin)))
                                        {
                                            if (!HTTPListenerThread.Join(1000))
                                            {
                                                HTTPListenerThread.Abort();
                                                HTTPListenerThread.Join();
                                            }
                                        }
                                    }
                                }
                                catch (Exception)
                                {
                                    /* We are going down and we do not care. */
                                }
                                finally
                                {
                                    HTTPListenerThread = null;
                                }
                                break;
                        }
                        break;
                    default:
                        Feedback(wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_ERROR),
                            wasGetDescriptionFromEnumValue(ConsoleError.HTTP_SERVER_NOT_SUPPORTED));
                        break;
                }

                // Apply settings to the instance.
                Client.Self.Movement.Camera.Far = configuration.Range;
                Client.Settings.LOGIN_TIMEOUT = (int) configuration.ServicesTimeout;
                Client.Settings.LOGOUT_TIMEOUT = (int) configuration.ServicesTimeout;
                Client.Settings.SIMULATOR_TIMEOUT = (int) configuration.ServicesTimeout;
            }
        }

        /// <summary>
        ///     Structure containing error messages printed on console for the owner.
        /// </summary>
        private enum ConsoleError
        {
            [Description("none")] NONE = 0,
            [Description("access denied")] ACCESS_DENIED,

            [Description(
                "the Terms of Service (TOS) for the grid you are connecting to have not been accepted, please check your configuration file"
                )] TOS_NOT_ACCEPTED,
            [Description("teleport failed")] TELEPORT_FAILED,
            [Description("teleport succeeded")] TELEPORT_SUCCEEDED,
            [Description("accepted friendship")] ACCEPTED_FRIENDSHIP,
            [Description("login failed")] LOGIN_FAILED,
            [Description("login succeeded")] LOGIN_SUCCEEDED,
            [Description("failed to set appearance")] APPEARANCE_SET_FAILED,
            [Description("appearance set")] APPEARANCE_SET_SUCCEEDED,
            [Description("all simulators disconnected")] ALL_SIMULATORS_DISCONNECTED,
            [Description("simulator connected")] SIMULATOR_CONNECTED,
            [Description("event queue started")] EVENT_QUEUE_STARTED,
            [Description("disconnected")] DISCONNECTED,
            [Description("logging out")] LOGGING_OUT,
            [Description("logging in")] LOGGING_IN,
            [Description("agent not found")] AGENT_NOT_FOUND,
            [Description("reading Corrade configuration")] READING_CORRADE_CONFIGURATION,
            [Description("read Corrade configuration")] READ_CORRADE_CONFIGURATION,
            [Description("configuration file modified")] CONFIGURATION_FILE_MODIFIED,
            [Description("HTTP server error")] HTTP_SERVER_ERROR,
            [Description("HTTP server not supported")] HTTP_SERVER_NOT_SUPPORTED,
            [Description("starting HTTP server")] STARTING_HTTP_SERVER,
            [Description("stopping HTTP server")] STOPPING_HTTP_SERVER,
            [Description("HTTP server processing aborted")] HTTP_SERVER_PROCESSING_ABORTED,
            [Description("timeout logging out")] TIMEOUT_LOGGING_OUT,
            [Description("callback error")] CALLBACK_ERROR,
            [Description("notification error")] NOTIFICATION_ERROR,
            [Description("inventory cache items loaded")] INVENTORY_CACHE_ITEMS_LOADED,
            [Description("inventory cache items saved")] INVENTORY_CACHE_ITEMS_SAVED,
            [Description("unable to load Corrade cache")] UNABLE_TO_LOAD_CORRADE_CACHE,
            [Description("unable to save Corrade cache")] UNABLE_TO_SAVE_CORRADE_CACHE,
            [Description("failed to manifest RLV behaviour")] FAILED_TO_MANIFEST_RLV_BEHAVIOUR,
            [Description("behaviour not implemented")] BEHAVIOUR_NOT_IMPLEMENTED,
            [Description("workers exceeded")] WORKERS_EXCEEDED,
            [Description("AIML bot configuration modified")] AIML_CONFIGURATION_MODIFIED,
            [Description("read AIML bot configuration")] READ_AIML_BOT_CONFIGURATION,
            [Description("reading AIML bot configuration")] READING_AIML_BOT_CONFIGURATION,
            [Description("wrote AIML bot configuration")] WROTE_AIML_BOT_CONFIGURATION,
            [Description("writing AIML bot configuration")] WRITING_AIML_BOT_CONFIGURATION,
            [Description("error loading AIML bot files")] ERROR_LOADING_AIML_BOT_FILES,
            [Description("error saving AIML bot files")] ERROR_SAVING_AIML_BOT_FILES,
            [Description("could not write to client log file")] COULD_NOT_WRITE_TO_CLIENT_LOG_FILE,
            [Description("could not write to group chat log file")] COULD_NOT_WRITE_TO_GROUP_CHAT_LOG_FILE,
            [Description("could not write to instant message log file")] COULD_NOT_WRITE_TO_INSTANT_MESSAGE_LOG_FILE,
            [Description("could not write to local message log file")] COULD_NOT_WRITE_TO_LOCAL_MESSAGE_LOG_FILE,
            [Description("could not write to region message log file")] COULD_NOT_WRITE_TO_REGION_MESSAGE_LOG_FILE,
            [Description("unknown IP address")] UNKNOWN_IP_ADDRESS,
            [Description("unable to save Corrade notifications state")] UNABLE_TO_SAVE_CORRADE_NOTIFICATIONS_STATE,
            [Description("unable to load Corrade notifications state")] UNABLE_TO_LOAD_CORRADE_NOTIFICATIONS_STATE,
            [Description("unknwon notification type")] UNKNOWN_NOTIFICATION_TYPE,
            [Description("teleport throttled")] TELEPORT_THROTTLED,
            [Description("uncaught exception for thread")] UNCAUGHT_EXCEPTION_FOR_THREAD,
            [Description("error setting up configuration watcher")] ERROR_SETTING_UP_CONFIGURATION_WATCHER,
            [Description("error setting up AIML configuration watcher")] ERROR_SETTING_UP_AIML_CONFIGURATION_WATCHER,
            [Description("callback throttled")] CallbackThrottleD,
            [Description("notification throttled")] NOTIFICATION_THROTTLED,
            [Description("error updating inventory")] ERROR_UPDATING_INVENTORY,
            [Description("unable to load group members state")] UNABLE_TO_LOAD_GROUP_MEMBERS_STATE,
            [Description("unable to save group members state")] UNABLE_TO_SAVE_GROUP_MEMBERS_STATE,
            [Description("error sending POST request")] ERROR_SENDING_POST_REQUEST,
            [Description("error building POST request")] ERROR_BUILDING_POST_REQUEST,
            [Description("notifications file modified")] NOTIFICATIONS_FILE_MODIFIED,
            [Description("error setting up Linden globalization")] ERROR_SETTING_UP_LINDEN_GLOBALIZATION,
            [Description("unable to load Corrade configuration")] UNABLE_TO_LOAD_CORRADE_CONFIGURATION,
            [Description("unable to save Corrade configuration")] UNABLE_TO_SAVE_CORRADE_CONFIGURATION
        }

        /// <summary>
        ///     Corrade's internal thread structure.
        /// </summary>
        public struct CorradeThread
        {
            /// <summary>
            ///     Holds all the live threads.
            /// </summary>
            private static readonly HashSet<Thread> WorkSet = new HashSet<Thread>();

            private static readonly object WorkSetLock = new object();

            /// <summary>
            ///     Semaphore for sequential execution of threads.
            /// </summary>
            private static readonly ManualResetEvent ThreadCompletedEvent = new ManualResetEvent(true);

            /// <summary>
            ///     Holds a map of groups to execution time in milliseconds.
            /// </summary>
            private static readonly Dictionary<UUID, GroupExecution> GroupExecutionTime =
                new Dictionary<UUID, GroupExecution>();

            private static readonly object GroupExecutionTimeLock = new object();
            private static readonly Stopwatch ThreadExecutuionStopwatch = new Stopwatch();
            private static CorradeThreadType corradeThreadType;

            /// <summary>
            ///     Constructor for a Corrade thread.
            /// </summary>
            /// <param name="corradeThreadType">the type of Corrade thread</param>
            public CorradeThread(CorradeThreadType corradeThreadType)
            {
                CorradeThread.corradeThreadType = corradeThreadType;
            }

            /// <summary>
            ///     This is a sequential scheduler that benefits from not blocking Corrade
            ///     and guarrantees that any Corrade thread spawned this way will only execute
            ///     until the previous thread spawned this way has completed.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            public void SpawnSequential(ThreadStart s, uint m)
            {
                lock (WorkSetLock)
                {
                    WorkSet.RemoveWhere(o => !o.IsAlive);
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                Thread t = new Thread(() =>
                {
                    // Wait for previous sequential thread to complete.
                    ThreadCompletedEvent.WaitOne(Timeout.Infinite);
                    ThreadCompletedEvent.Reset();
                    // protect inner thread
                    try
                    {
                        s();
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            wasGetDescriptionFromEnumValue(
                                ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            wasGetDescriptionFromEnumValue(corradeThreadType), ex.Message);
                    }
                    // Thread has completed.
                    ThreadCompletedEvent.Set();
                })
                {IsBackground = true, Priority = ThreadPriority.Lowest};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            /// <summary>
            ///     This is an ad-hoc scheduler where threads will be executed in a
            ///     first-come first-served fashion.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            public void Spawn(ThreadStart s, uint m)
            {
                lock (WorkSetLock)
                {
                    WorkSet.RemoveWhere(o => !o.IsAlive);
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                Thread t = new Thread(() =>
                {
                    // protect inner thread
                    try
                    {
                        s();
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            wasGetDescriptionFromEnumValue(
                                ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            wasGetDescriptionFromEnumValue(corradeThreadType), ex.Message);
                    }
                })
                {IsBackground = true, Priority = ThreadPriority.Lowest};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            /// <summary>
            ///     This is a fairness-oriented group/time-based scheduler that monitors
            ///     the execution time of threads for each configured group and favors
            ///     threads for the configured groups that have the smallest accumulated
            ///     execution time.
            /// </summary>
            /// <param name="s">the code to execute as a ThreadStart delegate</param>
            /// <param name="m">the maximum amount of threads</param>
            /// <param name="groupUUID">the UUID of the group</param>
            /// <param name="expiration">the time in milliseconds after which measurements are expunged</param>
            public void Spawn(ThreadStart s, uint m, UUID groupUUID, uint expiration)
            {
                // Don't accept to schedule bogus groups.
                if (groupUUID.Equals(UUID.Zero))
                    return;
                lock (WorkSetLock)
                {
                    WorkSet.RemoveWhere(o => !o.IsAlive);
                    if (WorkSet.Count > m)
                    {
                        return;
                    }
                }
                Thread t = new Thread(() =>
                {
                    // protect inner thread
                    try
                    {
                        // First remove any groups that have expired.
                        lock (GroupExecutionTimeLock)
                        {
                            List<UUID> RemoveGroups = new List<UUID>();
                            object LockObject = new object();
                            Parallel.ForEach(GroupExecutionTime, o =>
                            {
                                if ((DateTime.Now - o.Value.TimeStamp).Milliseconds > expiration)
                                {
                                    lock (LockObject)
                                    {
                                        RemoveGroups.Add(o.Key);
                                    }
                                }
                            });
                            Parallel.ForEach(RemoveGroups, o =>
                            {
                                lock (LockObject)
                                {
                                    GroupExecutionTime.Remove(o);
                                }
                            });
                        }
                        int sleepTime = 0;
                        List<KeyValuePair<UUID, GroupExecution>> sortedTimeGroups;
                        lock (GroupExecutionTimeLock)
                        {
                            sortedTimeGroups = GroupExecutionTime.ToList();
                        }
                        // In case only one group is involved, then do not schedule the group.
                        if (sortedTimeGroups.Count > 1 && sortedTimeGroups.Any(o => o.Key.Equals(groupUUID)))
                        {
                            sortedTimeGroups.Sort((o, p) => o.Value.ExecutionTime.CompareTo(p.Value.ExecutionTime));
                            int draw = CorradeRandom.Next(sortedTimeGroups.Sum(o => o.Value.ExecutionTime));
                            int accu = 0;
                            foreach (KeyValuePair<UUID, GroupExecution> group in sortedTimeGroups)
                            {
                                accu += group.Value.ExecutionTime;
                                if (accu < draw) continue;
                                sleepTime = group.Value.ExecutionTime;
                                break;
                            }
                        }
                        Thread.Sleep(sleepTime);
                        ThreadExecutuionStopwatch.Restart();
                        s();
                        ThreadExecutuionStopwatch.Stop();
                        lock (GroupExecutionTimeLock)
                        {
                            // add or change the mean execution time for a group
                            switch (GroupExecutionTime.ContainsKey(groupUUID))
                            {
                                case true:
                                    GroupExecutionTime[groupUUID] = new GroupExecution
                                    {
                                        ExecutionTime = (GroupExecutionTime[groupUUID].ExecutionTime +
                                                         (int) ThreadExecutuionStopwatch.ElapsedMilliseconds)/
                                                        2,
                                        TimeStamp = DateTime.Now
                                    };
                                    break;
                                default:
                                    GroupExecutionTime.Add(groupUUID, new GroupExecution
                                    {
                                        ExecutionTime = (int) ThreadExecutuionStopwatch.ElapsedMilliseconds,
                                        TimeStamp = DateTime.Now
                                    });
                                    break;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Feedback(
                            wasGetDescriptionFromEnumValue(
                                ConsoleError.UNCAUGHT_EXCEPTION_FOR_THREAD),
                            wasGetDescriptionFromEnumValue(corradeThreadType), ex.Message);
                    }
                })
                {IsBackground = true, Priority = ThreadPriority.Lowest};
                lock (WorkSetLock)
                {
                    WorkSet.Add(t);
                }
                t.Start();
            }

            private struct GroupExecution
            {
                public int ExecutionTime;
                public DateTime TimeStamp;
            }
        }

        /// <summary>
        ///     An inventory item.
        /// </summary>
        private struct DirItem
        {
            [Description("item")] public UUID Item;

            [Description("name")] public string Name;

            [Description("permissions")] public string Permissions;

            [Description("type")] public DirItemType Type;

            public static DirItem FromInventoryBase(InventoryBase inventoryBase)
            {
                DirItem item = new DirItem
                {
                    Name = inventoryBase.Name,
                    Item = inventoryBase.UUID,
                    Permissions = CORRADE_CONSTANTS.PERMISSIONS.NONE
                };

                if (inventoryBase is InventoryFolder)
                {
                    item.Type = DirItemType.FOLDER;
                    return item;
                }

                if (!(inventoryBase is InventoryItem)) return item;

                InventoryItem inventoryItem = inventoryBase as InventoryItem;
                item.Permissions = wasPermissionsToString(inventoryItem.Permissions);

                if (inventoryItem is InventoryWearable)
                {
                    item.Type = (DirItemType) typeof (DirItemType).GetFields(BindingFlags.Public |
                                                                             BindingFlags.Static)
                        .AsParallel().FirstOrDefault(
                            o =>
                                string.Equals(o.Name,
                                    Enum.GetName(typeof (WearableType),
                                        (inventoryItem as InventoryWearable).WearableType),
                                    StringComparison.InvariantCultureIgnoreCase)).GetValue(null);
                    return item;
                }

                if (inventoryItem is InventoryTexture)
                {
                    item.Type = DirItemType.TEXTURE;
                    return item;
                }

                if (inventoryItem is InventorySound)
                {
                    item.Type = DirItemType.SOUND;
                    return item;
                }

                if (inventoryItem is InventoryCallingCard)
                {
                    item.Type = DirItemType.CALLINGCARD;
                    return item;
                }

                if (inventoryItem is InventoryLandmark)
                {
                    item.Type = DirItemType.LANDMARK;
                    return item;
                }

                if (inventoryItem is InventoryObject)
                {
                    item.Type = DirItemType.OBJECT;
                    return item;
                }

                if (inventoryItem is InventoryNotecard)
                {
                    item.Type = DirItemType.NOTECARD;
                    return item;
                }

                if (inventoryItem is InventoryCategory)
                {
                    item.Type = DirItemType.CATEGORY;
                    return item;
                }

                if (inventoryItem is InventoryLSL)
                {
                    item.Type = DirItemType.LSL;
                    return item;
                }

                if (inventoryItem is InventorySnapshot)
                {
                    item.Type = DirItemType.SNAPSHOT;
                    return item;
                }

                if (inventoryItem is InventoryAttachment)
                {
                    item.Type = DirItemType.ATTACHMENT;
                    return item;
                }

                if (inventoryItem is InventoryAnimation)
                {
                    item.Type = DirItemType.ANIMATION;
                    return item;
                }

                if (inventoryItem is InventoryGesture)
                {
                    item.Type = DirItemType.GESTURE;
                    return item;
                }

                item.Type = DirItemType.NONE;
                return item;
            }
        }

        /// <summary>
        ///     Holds item types with the wearable inventory item type expanded to wearable types.
        /// </summary>
        private enum DirItemType : uint
        {
            [Description("none")] NONE = 0,
            [Description("texture")] TEXTURE,
            [Description("sound")] SOUND,
            [Description("callingcard")] CALLINGCARD,
            [Description("landmark")] LANDMARK,
            [Description("object")] OBJECT,
            [Description("notecard")] NOTECARD,
            [Description("category")] CATEGORY,
            [Description("LSL")] LSL,
            [Description("snapshot")] SNAPSHOT,
            [Description("attachment")] ATTACHMENT,
            [Description("animation")] ANIMATION,
            [Description("gesture")] GESTURE,
            [Description("folder")] FOLDER,
            [Description("shape")] SHAPE,
            [Description("skin")] SKIN,
            [Description("hair")] HAIR,
            [Description("eyes")] EYES,
            [Description("shirt")] SHIRT,
            [Description("pants")] PANTS,
            [Description("shoes")] SHOES,
            [Description("socks")] SOCKS,
            [Description("jacket")] JACKET,
            [Description("gloves")] GLOVES,
            [Description("undershirt")] UNDERSHIRT,
            [Description("underpants")] UNDERPANTS,
            [Description("skirt")] SKIRT,
            [Description("tattoo")] TATTOO,
            [Description("alpha")] ALPHA,
            [Description("physics")] PHYSICS
        }

        /// <summary>
        ///     Directions in 3D cartesian.
        /// </summary>
        private enum Direction : uint
        {
            [Description("none")] NONE = 0,
            [Description("back")] BACK,
            [Description("forward")] FORWARD,
            [Description("left")] LEFT,
            [Description("right")] RIGHT,
            [Description("up")] UP,
            [Description("down")] DOWN
        }

        /// <summary>
        ///     ENIGMA machine settings.
        /// </summary>
        public struct ENIGMA
        {
            public char[] plugs;
            public char reflector;
            public char[] rotors;
        }

        /// <summary>
        ///     Possible entities.
        /// </summary>
        private enum Entity : uint
        {
            [Description("none")] NONE = 0,
            [Description("avatar")] AVATAR,
            [Description("local")] LOCAL,
            [Description("group")] GROUP,
            [Description("estate")] ESTATE,
            [Description("region")] REGION,
            [Description("object")] OBJECT,
            [Description("parcel")] PARCEL,
            [Description("range")] RANGE,
            [Description("syntax")] SYNTAX,
            [Description("permission")] PERMISSION,
            [Description("description")] DESCRIPTION
        }

        /// <summary>
        ///     Group structure.
        /// </summary>
        [Serializable]
        public struct Group
        {
            public string ChatLog;
            public bool ChatLogEnabled;
            public string DatabaseFile;
            public string Name;
            public HashSet<Notifications> Notifications;
            public string Password;
            public HashSet<Permissions> Permissions;
            public UUID UUID;
            public uint Workers;

            public uint NotificationMask
            {
                get
                {
                    return Notifications != null && Notifications.Any()
                        ? Notifications.Cast<uint>()
                            .Aggregate((p, q) => p |= q)
                        : 0;
                }
            }

            public uint PermissionMask
            {
                get
                {
                    return Permissions != null && Permissions.Any()
                        ? Permissions.Cast<uint>()
                            .Aggregate((p, q) => p |= q)
                        : 0;
                }
            }
        }

        /// <summary>
        ///     A structure for group invites.
        /// </summary>
        private struct GroupInvite
        {
            [Description("agent")] public Agent Agent;

            [Description("fee")] public int Fee;

            [Description("group")] public string Group;

            [Description("session")] public UUID Session;
        }

        /// <summary>
        ///     An event for the group membership notification.
        /// </summary>
        private class GroupMembershipEventArgs : EventArgs
        {
            public Action Action;
            public string AgentName;
            public UUID AgentUUID;
            public string GroupName;
            public UUID GroupUUID;
        }

        /// <summary>
        ///     An event for a group message.
        /// </summary>
        private class GroupMessageEventArgs : EventArgs
        {
            public UUID AgentUUID;
            public string FirstName;
            public string GroupName;
            public UUID GroupUUID;
            public string LastName;
            public string Message;
        }

        /// <summary>
        ///     Linden constants.
        /// </summary>
        private struct LINDEN_CONSTANTS
        {
            public struct ALERTS
            {
                public const string NO_ROOM_TO_SIT_HERE = @"No room to sit here, try another spot.";

                public const string UNABLE_TO_SET_HOME =
                    @"You can only set your 'Home Location' on your land or at a mainland Infohub.";

                public const string HOME_SET = @"Home position set.";
            }

            public struct ASSETS
            {
                public struct NOTECARD
                {
                    public const string NEWLINE = "\n";
                    public const uint MAXIMUM_BODY_LENTH = 65536;
                }
            }

            public struct AVATARS
            {
                public const uint SET_DISPLAY_NAME_SUCCESS = 200;
                public const string LASTNAME_PLACEHOLDER = @"Resident";
                public const uint MAXIMUM_DISPLAY_NAME_CHARACTERS = 31;
                public const uint MINIMUM_DISPLAY_NAME_CHARACTERS = 1;
                public const uint MAXIMUM_NUMBER_OF_ATTACHMENTS = 38;

                public struct PROFILE
                {
                    public const uint SECOND_LIFE_TEXT_SIZE = 510;
                    public const uint FIRST_LIFE_TEXT_SIZE = 253;
                }

                public struct PICKS
                {
                    public const uint MAXIMUM_PICKS = 10;
                    public const uint MAXIMUM_PICK_DESCRIPTION_SIZE = 1022;
                }

                public struct CLASSIFIEDS
                {
                    public const uint MAXIMUM_CLASSIFIEDS = 100;
                }
            }

            public struct PRIMITIVES
            {
                public const uint MAXIMUM_NAME_SIZE = 63;
                public const uint MAXIMUM_DESCRIPTION_SIZE = 127;
                public const double MAXIMUM_REZ_HEIGHT = 4096.0;
                public const double MINIMUM_SIZE_X = 0.01;
                public const double MINIMUM_SIZE_Y = 0.01;
                public const double MINIMUM_SIZE_Z = 0.01;
                public const double MAXIMUM_SIZE_X = 64.0;
                public const double MAXIMUM_SIZE_Y = 64.0;
                public const double MAXIMUM_SIZE_Z = 64.0;
            }

            public struct OBJECTS
            {
                public const uint MAXIMUM_PRIMITIVE_COUNT = 256;
            }

            public struct DIRECTORY
            {
                public struct EVENT
                {
                    public const uint SEARCH_RESULTS_COUNT = 200;
                }

                public struct GROUP
                {
                    public const uint SEARCH_RESULTS_COUNT = 100;
                }

                public struct LAND
                {
                    public const uint SEARCH_RESULTS_COUNT = 100;
                }

                public struct PEOPLE
                {
                    public const uint SEARCH_RESULTS_COUNT = 100;
                }
            }

            public struct ESTATE
            {
                public const uint REGION_RESTART_DELAY = 120;
                public const uint MAXIMUM_BAN_LIST_LENGTH = 500;
                public const uint MAXIMUM_GROUP_LIST_LENGTH = 63;
                public const uint MAXIMUM_USER_LIST_LENGTH = 500;
                public const uint MAXIMUM_MANAGER_LIST_LENGTH = 10;

                public struct MESSAGES
                {
                    public const string REGION_RESTART_MESSAGE = @"restart";
                }
            }

            public struct PARCELS
            {
                public const double MAXIMUM_AUTO_RETURN_TIME = 999999;
                public const uint MINIMUM_AUTO_RETURN_TIME = 0;
                public const uint MAXIMUM_NAME_LENGTH = 63;
                public const uint MAXIMUM_DESCRIPTION_LENGTH = 255;
            }

            public struct GRID
            {
                public const string SECOND_LIFE = @"Second Life";
            }

            public struct CHAT
            {
                public const uint MAXIMUM_MESSAGE_LENGTH = 1024;
            }

            public struct GROUPS
            {
                public const uint MAXIMUM_NUMBER_OF_ROLES = 10;
                public const string EVERYONE_ROLE_NAME = @"Everyone";
                public const uint MAXIMUM_GROUP_NAME_LENGTH = 35;
                public const uint MAXIMUM_GROUP_TITLE_LENGTH = 20;
            }

            public struct NOTICES
            {
                public const uint MAXIMUM_NOTICE_MESSAGE_LENGTH = 512;
            }

            public struct LSL
            {
                public const string CSV_DELIMITER = @", ";
                public const float SENSOR_RANGE = 96;
            }

            public struct REGION
            {
                public const float TELEPORT_MINIMUM_DISTANCE = 1;
            }

            public struct VIEWER
            {
                public const float MAXIMUM_DRAW_DISTANCE = 4096;
            }

            public struct TELEPORTS
            {
                public struct THROTTLE
                {
                    public const uint MAX_TELEPORTS = 10;
                    public const uint GRACE_SECONDS = 15;
                }
            }
        }

        /// <summary>
        ///     A structure to track LookAt effects.
        /// </summary>
        private struct LookAtEffect
        {
            [Description("effect")] public UUID Effect;

            [Description("offset")] public Vector3d Offset;

            [Description("source")] public UUID Source;

            [Description("target")] public UUID Target;

            [Description("type")] public LookAtType Type;
        }

        /// <summary>
        ///     Masters structure.
        /// </summary>
        public struct Master
        {
            public string FirstName;
            public string LastName;
        }

        /// <summary>
        ///     A Corrade notification.
        /// </summary>
        public struct Notification
        {
            public SerializableDictionary<string, string> Afterburn;
            public HashSet<string> Data;
            public string GroupName;
            public UUID GroupUUID;
            public SerializableDictionary<Notifications, HashSet<string>> NotificationDestination;

            public uint NotificationMask
            {
                get
                {
                    /* Build the notification mask and send it. */
                    return NotificationDestination != null && NotificationDestination.Any()
                        ? NotificationDestination.Keys.Cast<uint>()
                            .Aggregate((p, q) => p |= q)
                        : 0;
                }
            }
        }

        /// <summary>
        ///     An element from the notification queue waiting to be dispatched.
        /// </summary>
        private struct NotificationQueueElement
        {
            public Dictionary<string, string> message;
            public string URL;
        }

        /// <summary>
        ///     A structure to track PointAt effects.
        /// </summary>
        private struct PointAtEffect
        {
            [Description("effect")] public UUID Effect;

            [Description("offset")] public Vector3d Offset;

            [Description("source")] public UUID Source;

            [Description("target")] public UUID Target;

            [Description("type")] public PointAtType Type;
        }

        /// <summary>
        ///     Keys returned by Corrade.
        /// </summary>
        private enum ResultKeys : uint
        {
            [Description("none")] NONE = 0,
            [Description("data")] DATA,
            [Description("success")] SUCCESS,
            [Description("error")] ERROR,
            [Description("status")] STATUS
        }

        /// <summary>
        ///     A structure for script dialogs.
        /// </summary>
        private struct ScriptDialog
        {
            public Agent Agent;

            [Description("button")] public List<string> Button;

            [Description("channel")] public int Channel;

            [Description("item")] public UUID Item;

            [Description("message")] public string Message;

            [Description("name")] public string Name;
        }

        /// <summary>
        ///     The status for an error message.
        /// </summary>
        public class StatusAttribute : Attribute
        {
            protected readonly uint statusCode;

            public StatusAttribute(uint statusCode)
            {
                this.statusCode = statusCode;
            }

            public uint Status
            {
                get { return statusCode; }
            }
        }

        /// <summary>
        ///     An exception thrown on script errors.
        /// </summary>
        [Serializable]
        public class ScriptException : Exception
        {
            public ScriptException(ScriptError error)
                : base(wasGetDescriptionFromEnumValue(error))
            {
                Status = wasGetAttributeFromEnumValue<StatusAttribute>(error).Status;
            }

            protected ScriptException(SerializationInfo info, StreamingContext context)
                : base(info, context)
            {
            }

            public uint Status { get; }
        }

        /// <summary>
        ///     Keys reconigzed by Corrade.
        /// </summary>
        private enum ScriptKeys : uint
        {
            [Description("none")] NONE = 0,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setconfigurationdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<CorradeConfiguration,[CorradeConfiguration...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.System)] [Description("setconfigurationdata")] SETCONFIGURATIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getconfigurationdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<CorradeConfiguration,[CorradeConfiguration...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.System)] [Description("getconfigurationdata")] GETCONFIGURATIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=ban>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<ban|unban|list>>&action=ban,unban:[avatars=<UUID|STRING[,UUID|STRING...]>]&action=ban:[eject=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("ban")] BAN,

            [IsCommand(true)] [CommandInputSyntax("<command=ping>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.None)] [Description("ping")] PING,
            [Description("pong")] PONG,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=batcheject>&<group=<UUID|STRING>>&<password=<STRING>>&[avatars=<UUID|STRING[,UUID|STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("batcheject")] BATCHEJECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=batchinvite>&<group=<UUID|STRING>>&<password=<STRING>>&[role=<UUID[,STRING...]>]&[avatars=<UUID|STRING[,UUID|STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("batchinvite")] BATCHINVITE,

            [Description("avatars")] AVATARS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectmediadata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<face=<INTEGER>>&[data=<MediaEntry[,MediaEntry...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectmediadata")] SETOBJECTMEDIADATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getobjectmediadata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<MediaEntry[,MediaEntry...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getobjectmediadata")] GETOBJECTMEDIADATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivematerial>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[material=<Material>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivematerial")] SETPRIMITIVEMATERIAL,

            [Description("material")] MATERIAL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivelightdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<LightData[,LightData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivelightdata")] SETPRIMITIVELIGHTDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivelightdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<LightData [,LightData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivelightdata")] GETPRIMITIVELIGHTDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiveflexibledata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<FlexibleData[,FlexibleData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitiveflexibledata")] SETPRIMITIVEFLEXIBLEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveflexibledata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<FlexibleData[,FlexibleData ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitiveflexibledata")] GETPRIMITIVEFLEXIBLEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=creategrass>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&<type=<Grass>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("creategrass")] CREATEGRASS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getstatus>&<group=<UUID|STRING>>&<password=<STRING>>&<status=<INTEGER>>&<entity=<description>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.None)] [Description("getstatus")] GETSTATUS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivebodytypes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivebodytypes")] GETPRIMITIVEBODYTYPES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivephysicsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<PhysicsProperties[,PhysicsProperties ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivephysicsdata")] GETPRIMITIVEPHYSICSDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivepropertiesdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<ObjectProperties[,ObjectProperties ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivepropertiesdata")] GETPRIMITIVEPROPERTIESDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiveflags>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<SINGLE>]&[temporary=<BOOL>]&[shadows=<BOOL>]&[restitution=<SINGLE>]&[phantom=<BOOL>]&[gravity=<SINGLE>]&[friction=<SINGLE>]&[density=<SINGLE>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitiveflags")] SETPRIMITIVEFLAGS,

            [Description("temporary")] TEMPORARY,
            [Description("shadows")] SHADOWS,
            [Description("restitution")] RESTITUTION,
            [Description("phantom")] PHANTOM,
            [Description("gravity")] GRAVITY,
            [Description("friction")] FRICTION,
            [Description("density")] DENSITY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=grab>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&<item=<UUID|STRING>>&[range=<FLOAT>]&<texture=<VECTOR3>&<surface=<VECTOR3>>&<normal=<VECTOR3>>&<binormal=<VECTOR3>>&<face=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("grab")] GRAB,

            [Description("texture")] TEXTURE,
            [Description("surface")] SURFACE,
            [Description("normal")] NORMAL,
            [Description("binormal")] BINORMAL,
            [Description("face")] FACE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createtree>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&<type=<Tree>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("createtree")] CREATETREE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivetexturedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[index=<INTEGER>]&[data=<TextureEntryFace [,TextureEntryFace ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivetexturedata")] SETPRIMITIVETEXTUREDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivetexturedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<TextureEntry[,TextureEntry ...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivetexturedata")] GETPRIMITIVETEXTUREDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivesculptdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<SculptData[,SculptData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivesculptdata")] SETPRIMITIVESCULPTDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivesculptdata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<SculptData[,SculptData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivesculptdata")] GETPRIMITIVESCULPTDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiveshapedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[type=<CorradePrimitiveShape>]&[data=<ConstructionData[,ConstructionData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitiveshapedata")] SETPRIMITIVESHAPEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveshapedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[data=<ConstructionData[,ConstructionData...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitiveshapedata")] GETPRIMITIVESHAPEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createprimitive>&<group=<UUID|STRING>>&<password=<STRING>>>&[region=<STRING>]&<position=<VECTOR3>>&[rotation=<Quaternion>]&[type=<CorradePrimitiveShape>]&[data=<ConstructionData>]&[flags=<PrimFlags>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("createprimitive")] CREATEPRIMITIVE,

            [Description("flags")] FLAGS,
            [Description("take")] TAKE,
            [Description("pass")] PASS,
            [Description("controls")] CONTROLS,
            [Description("afterburn")] AFTERBURN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivepayprices>&<group=<UUID|STRING>>&<password=<STRING>>>&item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivepayprices")] GETPRIMITIVEPAYPRICES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=primitivebuy>&<group=<UUID|STRING>>&<password=<STRING>>>&item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact | (uint) Permissions.Economy)] [Description("primitivebuy")] PRIMITIVEBUY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=changeprimitivelink>&<group=<UUID|STRING>>&<password=<STRING>>>&<action=<link|delink>>&action=link:<item=<STRING|UUID,STRING|UUID[,STRING|UUID...>>&action=delink:<item=<STRING|UUID[,STRING|UUID...>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("changeprimitivelink")] CHANGEPRIMITIVELINK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupmemberdata>&<group=<UUID|STRING>>&<password=<STRING>>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarGroup[,AvatarGroup...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getgroupmemberdata")] GETGROUPMEMBERDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getcommand>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<entity=<syntax|permission>>&entity=syntax:<type=<input>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.None)] [Description("getcommand")] GETCOMMAND,
            [IsCommand(true)] [CommandInputSyntax("<command=listcommands>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.None)] [Description("listcommands")] LISTCOMMANDS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getconnectedregions>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Land)] [Description("getconnectedregions")] GETCONNECTEDREGIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getnetworkdata>&<group=<UUID|STRING>>&<password=<STRING>>&[data=<NetworkManager[,NetworkManager...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("getnetworkdata")] GETNETWORKDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=typing>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("typing")] TYPING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=busy>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("busy")] BUSY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=away>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("away")] AWAY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getobjectpermissions")] GETOBJECTPERMISSIONS,
            [Description("scale")] SCALE,
            [Description("uniform")] UNIFORM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectscale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectscale")] SETOBJECTSCALE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivescale>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<scale=<FLOAT>>&[uniform=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivescale")] SETPRIMITIVESCALE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiverotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<rotation=<QUATERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitiverotation")] SETPRIMITIVEROTATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitiveposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitiveposition")] SETPRIMITIVEPOSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=exportdae>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("exportdae")] EXPORTDAE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=exportxml>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[range=<FLOAT>]&[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("exportxml")] EXPORTXML,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivesdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Primitive[,Primitive...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivesdata")] GETPRIMITIVESDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatarsdata>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<range|parcel|region|avatar>>&entity=range:[range=<FLOAT>]&entity=parcel:[position=<VECTOR2>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[data=<Avatar[,Avatar...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getavatarsdata")] GETAVATARSDATA,
            [Description("format")] FORMAT,
            [Description("volume")] VOLUME,
            [Description("audible")] AUDIBLE,
            [Description("path")] PATH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=inventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<ls|cwd|cd|mkdir|chmod|rm|cp|mv|ln>>&action=ls|mkdir|chmod:[path=<STRING>]&action=cd,action=rm:<path=<STRING>>&action=mkdir:<name=<STRING>>&action=chmod:<permissions=<STRING>>&action=cp|mv|ln:<source=<STRING>>&action=cp|mv|ln:<target=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("inventory")] INVENTORY,
            [Description("offset")] OFFSET,
            [Description("alpha")] ALPHA,
            [Description("color")] COLOR,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point>>&<id=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("deleteviewereffect")] DELETEVIEWEREFFECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getviewereffects>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getviewereffects")] GETVIEWEREFFECTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setviewereffect>&<group=<UUID|STRING>>&<password=<STRING>>&<effect=<Look|Point|Sphere|Beam>>&effect=Look:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Look:<offset=<VECTOR3>>&effect=Look:<type=LookAt>&effect=Point:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Point:<offset=<VECTOR3>>&effect=Point:<type=PointAt>&effect=Beam:<item=<UUID|STRING>&<range=<FLOAT>>>|<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&effect=Beam:<color=<VECTOR3>>&effect=Beam:<alpha=<FLOAT>>&effect=Beam:<duration=<FLOAT>>&effect=Beam:<offset=<VECTOR3>>&effect=Sphere:<color=<VECTOR3>>&effect=Sphere:<alpha=<FLOAT>>&effect=Sphere:<duration=<FLOAT>>&effect=Sphere:<offset=<VECTOR3>>&[id=<UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setviewereffect")] SETVIEWEREFFECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=ai>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<process|enable|disable|rebuild>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Talk)] [Description("ai")] AI,
            [IsCommand(true)] [CommandInputSyntax("<command=gettitles>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("gettitles")] GETTITLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=tag>&<group=<UUID|STRING>>&<password=<STRING>>&action=<set|get>&action=set:<title=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("tag")] TAG,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=filter>&<group=<UUID|STRING>>&<password=<STRING>>&action=<set|get>&action=get:<type=<input|output>>&action=set:<input=<STRING>>&action=set:<output=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Filter)] [Description("filter")] FILTER,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=run>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable|get>>&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.Movement)] [Description("run")] RUN,
            [IsCommand(true)] [CommandInputSyntax("<command=relax>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("relax")] RELAX,
            [Description("sift")] SIFT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=rlv>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<enable|disable>>&[callback=<STRING>]")
                              ] [CommandPermissionMask((uint) Permissions.System)] [Description("rlv")] RLV,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventorypath>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("getinventorypath")] GETINVENTORYPATH,
            [Description("committed")] COMMITTED,
            [Description("credit")] CREDIT,
            [Description("success")] SUCCESS,
            [Description("transaction")] TRANSACTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptdialogs>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getscriptdialogs")] GETSCRIPTDIALOGS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptpermissionrequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getscriptpermissionrequests")] GETSCRIPTPERMISSIONREQUESTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getteleportlures>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("getteleportlures")] GETTELEPORTLURES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytogroupinvite>&<group=<UUID|STRING>>&<password=<STRING>>&[action=<accept|decline>]&<session=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group | (uint) Permissions.Economy)] [Description("replytogroupinvite")] REPLYTOGROUPINVITE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupinvites>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("getgroupinvites")] GETGROUPINVITES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getmemberroles>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getmemberroles")] GETMEMBERROLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=execute>&<group=<UUID|STRING>>&<password=<STRING>>&<file=<STRING>>&[parameter=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Execute)] [Description("execute")] EXECUTE,
            [Description("parameter")] PARAMETER,
            [Description("file")] FILE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=cache>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<purge|load|save>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.System)] [Description("cache")] CACHE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgridregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<GridRegion[,GridRegion...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getgridregiondata")] GETGRIDREGIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregionparcelsboundingbox>&<group=<UUID|STRING>>&<password=<STRING>>&[region=<STRING>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getregionparcelsboundingbox")] GETREGIONPARCELSBOUNDINGBOX,
            [Description("pattern")] PATTERN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=searchinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<pattern=<STRING>>&[type=<AssetType>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("searchinventory")] SEARCHINVENTORY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getterrainheight>&<group=<UUID|STRING>>&<password=<STRING>>&[southwest=<VECTOR>]&[northwest=<VECTOR>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getterrainheight")] GETTERRAINHEIGHT,
            [Description("northeast")] NORTHEAST,
            [Description("southwest")] SOUTHWEST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=upload>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Clothing:[wear=<WearableType>]&type=Bodypart:[wear=<WearableType>]&<data=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory | (uint) Permissions.Economy)] [Description("upload")] UPLOAD,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=download>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<type=<Texture|Sound|Animation|Clothing|Bodypart|Landmark|Gesture|Notecard|LSLText>>&type=Texture:[format=<ImageFormat>]&[path=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact | (uint) Permissions.System)] [Description("download")] DOWNLOAD,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR>]&[data=<Parcel[,Parcel...]>]&[region=<STRING>]&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.Land)] [Description("setparceldata")] SETPARCELDATA,
            [Description("new")] NEW,
            [Description("old")] OLD,
            [Description("aggressor")] AGGRESSOR,
            [Description("magnitude")] MAGNITUDE,
            [Description("time")] TIME,
            [Description("victim")] VICTIM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=playgesture>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("playgesture")] PLAYGESTURE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=jump>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("jump")] JUMP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=crouch>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("crouch")] CROUCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=turnto>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR3>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("turnto")] TURNTO,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=nudge>&<group=<UUID|STRING>>&<password=<STRING>>&<direction=<left|right|up|down|back|forward>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("nudge")] NUDGE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createnotecard>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[text=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("createnotecard")] CREATENOTECARD,
            [Description("direction")] DIRECTION,
            [Description("agent")] AGENT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoinventoryoffer>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<accept|decline>>&<session=<UUID>>&[folder=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("replytoinventoryoffer")] REPLYTOINVENTORYOFFER,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventoryoffers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("getinventoryoffers")] GETINVENTORYOFFERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=updateprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|remove|take>>&action=add:<entity=<UUID|STRING>>&action=remove:<entity=<UUID|STRING>>&action=take:<entity=<UUID|STRING>>&action=take:<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("updateprimitiveinventory")] UPDATEPRIMITIVEINVENTORY,
            [IsCommand(true)] [CommandInputSyntax("<command=version>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.None)] [Description("version")] VERSION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=playsound>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[gain=<FLOAT>]&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("playsound")] PLAYSOUND,
            [Description("gain")] GAIN,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolemembers>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getrolemembers")] GETROLEMEMBERS,
            [Description("status")] STATUS,
            [IsCommand(true)] [CommandInputSyntax("<command=getmembers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("getmembers")] GETMEMBERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoteleportlure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<session=<UUID>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("replytoteleportlure")] REPLYTOTELEPORTLURE,
            [Description("session")] SESSION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoscriptpermissionrequest>&<group=<UUID|STRING>>&<password=<STRING>>&<task=<UUID>>&<item=<UUID>>&<permissions=<ScriptPermission>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("replytoscriptpermissionrequest")] REPLYTOSCRIPTPERMISSIONREQUEST,
            [Description("task")] TASK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparcellist>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getparcellist")] GETPARCELLIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelrelease>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("parcelrelease")] PARCELRELEASE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelbuy>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[forgroup=<BOOL>]&[removecontribution=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land | (uint) Permissions.Economy)] [Description("parcelbuy")] PARCELBUY,
            [Description("removecontribution")] REMOVECONTRIBUTION,
            [Description("forgroup")] FORGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parceldeed>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("parceldeed")] PARCELDEED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelreclaim>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("parcelreclaim")] PARCELRECLAIM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=unwear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("unwear")] UNWEAR,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=wear>&<group=<UUID|STRING>>&<password=<STRING>>&<wearables=<STRING[,UUID...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("wear")] WEAR,
            [Description("wearables")] WEARABLES,
            [IsCommand(true)] [CommandInputSyntax("<command=getwearables>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("getwearables")] GETWEARABLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=changeappearance>&<group=<UUID|STRING>>&<password=<STRING>>&<folder=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("changeappearance")] CHANGEAPPEARANCE,
            [Description("folder")] FOLDER,
            [Description("replace")] REPLACE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectrotation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<rotation=<QUARTERNION>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectrotation")] SETOBJECTROTATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivedescription>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<description=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivedescription")] SETPRIMITIVEDESCRIPTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprimitivename>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setprimitivename")] SETPRIMITIVENAME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectposition>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<position=<VECTOR3>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectposition")] SETOBJECTPOSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectsaleinfo>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<price=<INTEGER>>&<type=<SaleType>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectsaleinfo")] SETOBJECTSALEINFO,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectgroup>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectgroup")] SETOBJECTGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=objectdeed>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("objectdeed")] OBJECTDEED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setobjectpermissions>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<permissions=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setobjectpermissions")] SETOBJECTPERMISSIONS,
            [Description("permissions")] PERMISSIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<region|parcel>>&entity=parcel:<position=<VECTOR2>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getavatarpositions")] GETAVATARPOSITIONS,
            [Description("delay")] DELAY,
            [Description("asset")] ASSET,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setregiondebug>&<group=<UUID|STRING>>&<password=<STRING>>&<scripts=<BOOL>>&<collisions=<BOOL>>&<physics=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("setregiondebug")] SETREGIONDEBUG,
            [Description("scripts")] SCRIPTS,
            [Description("collisions")] COLLISIONS,
            [Description("physics")] PHYSICS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getmapavatarpositions>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getmapavatarpositions")] GETMAPAVATARPOSITIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=mapfriend>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("mapfriend")] MAPFRIEND,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytofriendshiprequest>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<action=<accept|decline>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("replytofriendshiprequest")] REPLYTOFRIENDSHIPREQUEST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getfriendshiprequests>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("getfriendshiprequests")] GETFRIENDSHIPREQUESTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=grantfriendrights>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<rights=<FriendRights>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("grantfriendrights")] GRANTFRIENDRIGHTS,
            [Description("rights")] RIGHTS,

            [IsCommand(true)] [CommandInputSyntax("<command=getfriendslist>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("getfriendslist")] GETFRIENDSLIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=terminatefriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("terminatefriendship")] TERMINATEFRIENDSHIP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=offerfriendship>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("offerfriendship")] OFFERFRIENDSHIP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getfrienddata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<FriendInfo[,FriendInfo...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Friendship)] [Description("getfrienddata")] GETFRIENDDATA,
            [Description("days")] DAYS,
            [Description("interval")] INTERVAL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupaccountsummarydata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<GroupAccountSummary[,GroupAccountSummary...]>>&<days=<INTEGER>>&<interval=<INTEGER>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getgroupaccountsummarydata")] GETGROUPACCOUNTSUMMARYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getselfdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AgentManager[,AgentManager...]>>&[callback=<STRING>]"
                )
                              ] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("getselfdata")] GETSELFDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("deleteclassified")] DELETECLASSIFIED,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addclassified>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<price=<INTEGER>>&<type=<Any|Shopping|LandRental|PropertyRental|SpecialAttraction|NewProducts|Employment|Wanted|Service|Personal>>&[item=<UUID|STRING>]&[description=<STRING>]&[renew=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming | (uint) Permissions.Economy)] [Description("addclassified")] ADDCLASSIFIED,
            [Description("price")] PRICE,
            [Description("renew")] RENEW,
            [IsCommand(true)] [CommandInputSyntax("<command=logout>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.System)] [Description("logout")] LOGOUT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=displayname>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<get|set>>&action=set:<name=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("displayname")] DISPLAYNAME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=returnprimitives>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<entity=<parcel|estate>>&<type=<Owner|Group|Other|Sell|ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers>>&type=Owner|Group|Other|Sell:[position=<VECTOR2>]&type=ReturnScripted|ReturnOnOthersLand|ReturnScriptedAndOnOthers:[all=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("returnprimitives")] RETURNPRIMITIVES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getgroupdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getgroupdata")] GETGROUPDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getavatardata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<Avatar[,Avatar...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getavatardata")] GETAVATARDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveinventory>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitiveinventory")] GETPRIMITIVEINVENTORY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("getinventorydata")] GETINVENTORYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveinventorydata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<InventoryItem[,InventoryItem...]>>&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitiveinventorydata")] GETPRIMITIVEINVENTORYDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getscriptrunning")] GETSCRIPTRUNNING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setscriptrunning>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<entity=<STRING|UUID>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("setscriptrunning")] SETSCRIPTRUNNING,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=derez>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[folder=<STRING|UUID>]&[type=<DeRezDestination>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("derez")] DEREZ,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparceldata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Parcel[,Parcel...]>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getparceldata")] GETPARCELDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=rez>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<item=<UUID|STRING>&[rotation=<QUARTERNION>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("rez")] REZ,
            [Description("rotation")] ROTATION,
            [Description("index")] INDEX,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=replytoscriptdialog>&<group=<UUID|STRING>>&<password=<STRING>>&<channel=<INTEGER>>&<index=<INTEGER>&<button=<STRING>>&<item=<UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("replytoscriptdialog")] REPLYTOSCRIPTDIALOG,
            [Description("owner")] OWNER,
            [Description("button")] BUTTON,

            [IsCommand(true)] [CommandInputSyntax("<command=getanimations>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")
                              ] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("getanimations")] GETANIMATIONS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=animation>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("animation")] ANIMATION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&<action=<add|remove>>&type=ban|manager|user,action=add|remove:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&type=group,action=add|remove:<target=<STRING|UUID>>&[all=<BOOL>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("setestatelist")] SETESTATELIST,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getestatelist>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<ban|group|manager|user>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getestatelist")] GETESTATELIST,
            [Description("all")] ALL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregiontop>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<scripts|colliders>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getregiontop")] GETREGIONTOP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=restartregion>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<scripts|colliders>>&[delay=<INTEGER>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("restartregion")] RESTARTREGION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=directorysearch>&<group=<UUID|STRING>>&<password=<STRING>>&<type=<classified|event|group|land|people|places>>&type=classified:<data=<Classified[,Classified...]>>&type=classified:<name=<STRING>>&type=event:<data=<EventsSearchData[,EventSearchData...]>>&type=event:<name=<STRING>>&type=group:<data=<GroupSearchData[,GroupSearchData...]>>&type=land:<data=<DirectoryParcel[,DirectoryParcel...]>>&type=people:<data=<AgentSearchData[,AgentSearchData...]>>&type=places:<data=<DirectoryParcel[,DirectoryParcel...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Directory)] [Description("directorysearch")] DIRECTORYSEARCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprofiledata")] GETPROFILEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getparticlesystem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getparticlesystem")] GETPARTICLESYSTEM,
            [Description("data")] DATA,
            [Description("range")] RANGE,
            [Description("balance")] BALANCE,
            [Description("key")] KEY,
            [Description("value")] VALUE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=database>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<get|set|delete>>&action=get|delete:<key=<STRING>>&action=set:<key=<STRING>>&action=set:<value=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Database)] [Description("database")] DATABASE,
            [Description("text")] TEXT,
            [Description("quorum")] QUORUM,
            [Description("majority")] MAJORITY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=startproposal>&<group=<UUID|STRING>>&<password=<STRING>>&<duration=<INTEGER>>&<majority=<FLOAT>>&<quorum=<INTEGER>>&<text=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("startproposal")] STARTPROPOSAL,
            [Description("duration")] DURATION,
            [Description("action")] ACTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deletefromrole>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("deletefromrole")] DELETEFROMROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addtorole>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("addtorole")] ADDTOROLE,
            [IsCommand(true)] [CommandInputSyntax("<command=leave>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("leave")] LEAVE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=updategroupdata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<[Charter<,STRING>][,ListInProfile<,BOOL>][,MembershipFee<,INTEGER>][,OpenEnrollment<,BOOL>][,ShowInList<,BOOL>]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("updategroupdata")] UPDATEGROUPDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=eject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("eject")] EJECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=invite>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[role=<UUID[,STRING...]>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("invite")] INVITE,
            [IsCommand(true)] [CommandInputSyntax("<command=join>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group | (uint) Permissions.Economy)] [Description("join")] JOIN,
            [Description("callback")] CALLBACK,
            [Description("group")] GROUP,
            [Description("password")] Password,
            [Description("firstname")] FIRSTNAME,
            [Description("lastname")] LASTNAME,
            [Description("command")] COMMAND,
            [Description("role")] ROLE,
            [Description("title")] TITLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=tell>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<local|group|avatar|estate|region>>&entity=local:<type=<Normal|Whisper|Shout>>&entity=local,type=Normal|Whisper|Shout:[channel=<INTEGER>]&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Talk)] [Description("tell")] TELL,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=notice>&<group=<UUID|STRING>>&<password=<STRING>>&<message=<STRING>>&[subject=<STRING>]&[item=<UUID|STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("notice")] NOTICE,
            [Description("message")] MESSAGE,
            [Description("subject")] SUBJECT,
            [Description("item")] ITEM,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=pay>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<avatar|object|group>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=object:<target=<UUID>>&[reason=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Economy)] [Description("pay")] PAY,
            [Description("amount")] AMOUNT,
            [Description("target")] TARGET,
            [Description("reason")] REASON,
            [IsCommand(true)] [CommandInputSyntax("<command=getbalance>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Economy)] [Description("getbalance")] GETBALANCE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=teleport>&<group=<UUID|STRING>>&<password=<STRING>>&<region=<STRING>>&[position=<VECTOR3>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("teleport")] TELEPORT,
            [Description("region")] REGION,
            [Description("position")] POSITION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getregiondata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Simulator[,Simulator...]>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getregiondata")] GETREGIONDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=sit>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("sit")] SIT,
            [IsCommand(true)] [CommandInputSyntax("<command=stand>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("stand")] STAND,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parceleject>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[ban=<BOOL>]&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("parceleject")] PARCELEJECT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=creategroup>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<Group[,Group...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group | (uint) Permissions.Economy)] [Description("creategroup")] CREATEGROUP,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=parcelfreeze>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[freeze=<BOOL>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("parcelfreeze")] PARCELFREEZE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=createrole>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<STRING>>&[powers=<GroupPowers[,GroupPowers...]>]&[title=<STRING>]&[description=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("createrole")] CREATEROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleterole>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("deleterole")] DELETEROLE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolesmembers>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("getrolesmembers")] GETROLESMEMBERS,
            [IsCommand(true)] [CommandInputSyntax("<command=getroles>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Group)] [Description("getroles")] GETROLES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getrolepowers>&<group=<UUID|STRING>>&<password=<STRING>>&<role=<UUID|STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("getrolepowers")] GETROLEPOWERS,
            [Description("powers")] POWERS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=lure>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("lure")] LURE,
            [Description("URL")] URL,
            [IsCommand(true)] [CommandInputSyntax("<command=sethome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("sethome")] SETHOME,
            [IsCommand(true)] [CommandInputSyntax("<command=gohome>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("gohome")] GOHOME,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=setprofiledata>&<group=<UUID|STRING>>&<password=<STRING>>&<data=<AvatarProperties[,AvatarProperties...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("setprofiledata")] SETPROFILEDATA,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=give>&<group=<UUID|STRING>>&<password=<STRING>>&<entity=<avatar|object>>&entity=avatar:<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&entity=avatar:<item=<UUID|STRING>&entity=object:<item=<UUID|STRING>&entity=object:[range=<FLOAT>]&entity=object:<target=<UUID|STRING>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("give")] GIVE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deleteitem>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<STRING|UUID>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("deleteitem")] DELETEITEM,
            [IsCommand(true)] [CommandInputSyntax("<command=emptytrash>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Inventory)] [Description("emptytrash")] EMPTYTRASH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=fly>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<start|stop>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Movement)] [Description("fly")] FLY,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=addpick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[description=<STRING>]&[item=<STRING|UUID>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("addpick")] ADDPICK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=deletepick>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("deltepick")] DELETEPICK,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=touch>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("touch")] TOUCH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=moderate>&<group=<UUID|STRING>>&<password=<STRING>>&<agent=<UUID>|firstname=<STRING>&lastname=<STRING>>&<type=<voice|text>>&<silence=<BOOL>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Group)] [Description("moderate")] MODERATE,
            [Description("type")] TYPE,
            [Description("silence")] SILENCE,
            [Description("freeze")] FREEZE,
            [IsCommand(true)] [CommandInputSyntax("<command=rebake>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("rebake")] REBAKE,

            [IsCommand(true)] [CommandInputSyntax("<command=getattachments>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("getattachments")] GETATTACHMENTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=attach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<AttachmentPoint<,<UUID|STRING>>[,AttachmentPoint<,<UUID|STRING>>...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("attach")] ATTACH,
            [Description("attachments")] ATTACHMENTS,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=detach>&<group=<UUID|STRING>>&<password=<STRING>>&<attachments=<STRING[,UUID...]>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("detach")] DETACH,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitiveowners>&<group=<UUID|STRING>>&<password=<STRING>>&[position=<VECTOR2>]&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("getprimitiveowners")] GETPRIMITIVEOWNERS,
            [Description("entity")] ENTITY,
            [Description("channel")] CHANNEL,
            [Description("name")] NAME,
            [Description("description")] DESCRIPTION,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=getprimitivedata>&<group=<UUID|STRING>>&<password=<STRING>>&<item=<UUID|STRING>>&[range=<FLOAT>]&<data=<Primitive[,Primitive...]>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Interact)] [Description("getprimitivedata")] GETPRIMITIVEDATA,
            [IsCommand(true)] [CommandInputSyntax("<command=activate>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Grooming)] [Description("activate")] ACTIVATE,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=autopilot>&<group=<UUID|STRING>>&<password=<STRING>>&<position=<VECTOR2>>&<action=<start|stop>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Movement)] [Description("autopilot")] AUTOPILOT,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=mute>&<group=<UUID|STRING>>&<password=<STRING>>&<name=<STRING>>&<target=<UUID>>&<action=<mute|unmute>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Mute)] [Description("mute")] MUTE,
            [IsCommand(true)] [CommandInputSyntax("<command=getmutes>&<group=<UUID|STRING>>&<password=<STRING>>&[callback=<STRING>]")] [CommandPermissionMask((uint) Permissions.Mute)] [Description("getmutes")] GETMUTES,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=notify>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<add|set|remove|list|clear|purge>>&action=add|set|remove|clear:<type=<STRING[,STRING...]>>&action=add|set|remove:<URL=<STRING>>&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Notifications)] [Description("notify")] NOTIFY,
            [Description("source")] SOURCE,
            [Description("effect")] EFFECT,
            [Description("id")] ID,

            [IsCommand(true)] [CommandInputSyntax(
                "<command=terrain>&<group=<UUID|STRING>>&<password=<STRING>>&<action=<set|get>>&action=set:<data=<STRING>>&[region=<STRING>]&[callback=<STRING>]"
                )] [CommandPermissionMask((uint) Permissions.Land)] [Description("terrain")] TERRAIN,
            [Description("output")] OUTPUT,
            [Description("input")] INPUT
        }

        /// <summary>
        ///     The permission mask of a command.
        /// </summary>
        private class CommandPermissionMaskAttribute : Attribute
        {
            protected readonly uint permissionMask;

            public CommandPermissionMaskAttribute(uint permissionMask)
            {
                this.permissionMask = permissionMask;
            }

            public uint PermissionMask
            {
                get { return permissionMask; }
            }
        }

        /// <summary>
        ///     Whether this is a command or not.
        /// </summary>
        private class IsCommandAttribute : Attribute
        {
            protected readonly bool isCommand;

            public IsCommandAttribute(bool isCommand)
            {
                this.isCommand = isCommand;
            }

            public bool IsCommand
            {
                get { return isCommand; }
            }
        }

        /// <summary>
        ///     The syntax for a command.
        /// </summary>
        private class CommandInputSyntaxAttribute : Attribute
        {
            protected readonly string syntax;

            public CommandInputSyntaxAttribute(string syntax)
            {
                this.syntax = syntax;
            }

            public string Syntax
            {
                get { return syntax; }
            }
        }

        /// <summary>
        ///     A structure for script permission requests.
        /// </summary>
        private struct ScriptPermissionRequest
        {
            public Agent Agent;

            [Description("item")] public UUID Item;

            [Description("name")] public string Name;

            [Description("permission")] public ScriptPermission Permission;

            [Description("region")] public string Region;

            [Description("task")] public UUID Task;
        }

        /// <summary>
        ///     A serializable dictionary implementation.
        /// </summary>
        /// <typeparam name="TKey">the key</typeparam>
        /// <typeparam name="TVal">the value</typeparam>
        /// <remarks>Copyright (c) Dacris Software Inc. MIT license</remarks>
        [Serializable]
        public sealed class SerializableDictionary<TKey, TVal> : Dictionary<TKey, TVal>, IXmlSerializable, ISerializable
        {
            #region Constants

            private const string DictionaryNodeName = "Dictionary";
            private const string ItemNodeName = "Item";
            private const string KeyNodeName = "Key";
            private const string ValueNodeName = "Value";

            #endregion

            #region Constructors

            public SerializableDictionary()
            {
            }

            public SerializableDictionary(IDictionary<TKey, TVal> dictionary)
                : base(dictionary)
            {
            }

            public SerializableDictionary(IEqualityComparer<TKey> comparer)
                : base(comparer)
            {
            }

            public SerializableDictionary(int capacity)
                : base(capacity)
            {
            }

            public SerializableDictionary(IDictionary<TKey, TVal> dictionary, IEqualityComparer<TKey> comparer)
                : base(dictionary, comparer)
            {
            }

            public SerializableDictionary(int capacity, IEqualityComparer<TKey> comparer)
                : base(capacity, comparer)
            {
            }

            #endregion

            #region ISerializable Members

            private SerializableDictionary(SerializationInfo info, StreamingContext context)
                : base(info, context)
            {
                int itemCount = info.GetInt32("ItemCount");
                for (int i = 0; i < itemCount; i++)
                {
                    KeyValuePair<TKey, TVal> kvp =
                        (KeyValuePair<TKey, TVal>)
                            info.GetValue(string.Format("Item{0}", i), typeof (KeyValuePair<TKey, TVal>));
                    Add(kvp.Key, kvp.Value);
                }
            }

            void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
            {
                info.AddValue("ItemCount", Count);
                int itemIdx = 0;
                foreach (KeyValuePair<TKey, TVal> kvp in this)
                {
                    info.AddValue(string.Format("Item{0}", itemIdx), kvp, typeof (KeyValuePair<TKey, TVal>));
                    itemIdx++;
                }
                base.GetObjectData(info, context);
            }

            #endregion

            #region IXmlSerializable Members

            void IXmlSerializable.WriteXml(XmlWriter writer)
            {
                //writer.WriteStartElement(DictionaryNodeName);
                foreach (KeyValuePair<TKey, TVal> kvp in this)
                {
                    writer.WriteStartElement(ItemNodeName);
                    writer.WriteStartElement(KeyNodeName);
                    KeySerializer.Serialize(writer, kvp.Key);
                    writer.WriteEndElement();
                    writer.WriteStartElement(ValueNodeName);
                    ValueSerializer.Serialize(writer, kvp.Value);
                    writer.WriteEndElement();
                    writer.WriteEndElement();
                }
                //writer.WriteEndElement();
            }

            void IXmlSerializable.ReadXml(XmlReader reader)
            {
                if (reader.IsEmptyElement)
                {
                    return;
                }

                // Move past container
                if (!reader.Read())
                {
                    throw new XmlException("Error in Deserialization of Dictionary");
                }

                //reader.ReadStartElement(DictionaryNodeName);
                while (reader.NodeType != XmlNodeType.EndElement)
                {
                    reader.ReadStartElement(ItemNodeName);
                    reader.ReadStartElement(KeyNodeName);
                    TKey key = (TKey) KeySerializer.Deserialize(reader);
                    reader.ReadEndElement();
                    reader.ReadStartElement(ValueNodeName);
                    TVal value = (TVal) ValueSerializer.Deserialize(reader);
                    reader.ReadEndElement();
                    reader.ReadEndElement();
                    Add(key, value);
                    reader.MoveToContent();
                }
                //reader.ReadEndElement();

                reader.ReadEndElement(); // Read End Element to close Read of containing node
            }

            XmlSchema IXmlSerializable.GetSchema()
            {
                return null;
            }

            #endregion

            #region Private Properties

            private XmlSerializer ValueSerializer
            {
                get { return valueSerializer ?? (valueSerializer = new XmlSerializer(typeof (TVal))); }
            }

            private XmlSerializer KeySerializer
            {
                get { return keySerializer ?? (keySerializer = new XmlSerializer(typeof (TKey))); }
            }

            #endregion

            #region Private Members

            private XmlSerializer keySerializer;
            private XmlSerializer valueSerializer;

            #endregion
        }

        /// <summary>
        ///     A structure to track Sphere effects.
        /// </summary>
        private struct SphereEffect
        {
            [Description("alpha")] public float Alpha;

            [Description("color")] public Vector3 Color;

            [Description("duration")] public float Duration;

            [Description("effect")] public UUID Effect;

            [Description("offset")] public Vector3d Offset;

            [Description("termination")] public DateTime Termination;
        }

        /// <summary>
        ///     A structure for teleport lures.
        /// </summary>
        private struct TeleportLure
        {
            public Agent Agent;
            public UUID Session;
        }

        /// <summary>
        ///     Various types.
        /// </summary>
        private enum Type : uint
        {
            [Description("none")] NONE = 0,
            [Description("text")] TEXT,
            [Description("voice")] VOICE,
            [Description("scripts")] SCRIPTS,
            [Description("colliders")] COLLIDERS,
            [Description("ban")] BAN,
            [Description("group")] GROUP,
            [Description("user")] USER,
            [Description("manager")] MANAGER,
            [Description("classified")] CLASSIFIED,
            [Description("event")] EVENT,
            [Description("land")] LAND,
            [Description("people")] PEOPLE,
            [Description("place")] PLACE,
            [Description("input")] INPUT,
            [Description("output")] OUTPUT
        }

        /// <summary>
        ///     Possible viewer effects.
        /// </summary>
        private enum ViewerEffectType : uint
        {
            [Description("none")] NONE = 0,
            [Description("look")] LOOK,
            [Description("point")] POINT,
            [Description("sphere")] SPHERE,
            [Description("beam")] BEAM
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Given a number of allowed events per seconds, this class allows you
        ///     to determine via the IsSafe property whether it is safe to trigger
        ///     another lined-up event. This is mostly used to check that throttles
        ///     are being respected.
        /// </summary>
        public class wasTimedThrottle : IDisposable
        {
            private readonly uint EventsAllowed;
            private readonly object LockObject = new object();
            private uint _Events;
            private System.Timers.Timer timer;

            public wasTimedThrottle(uint events, uint seconds)
            {
                EventsAllowed = events;
                if (timer == null)
                {
                    timer = new System.Timers.Timer(seconds);
                    timer.Elapsed += (o, p) =>
                    {
                        lock (LockObject)
                        {
                            _Events = 0;
                        }
                    };
                    timer.Start();
                }
            }

            public bool IsSafe
            {
                get
                {
                    lock (LockObject)
                    {
                        return ++_Events <= EventsAllowed;
                    }
                }
            }

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool dispose)
            {
                if (timer != null)
                {
                    timer.Dispose();
                    timer = null;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2013 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     An alarm class similar to the UNIX alarm with the added benefit
        ///     of a decaying timer that tracks the time between rescheduling.
        /// </summary>
        /// <remarks>
        ///     (C) Wizardry and Steamworks 2013 - License: GNU GPLv3
        /// </remarks>
        public class wasAdaptiveAlarm : IDisposable
        {
            [Flags]
            public enum DECAY_TYPE
            {
                [XmlEnum(Name = "none")] [Description("none")] NONE = 0,
                [XmlEnum(Name = "arithmetic")] [Description("arithmetic")] ARITHMETIC = 1,
                [XmlEnum(Name = "geometric")] [Description("geometric")] GEOMETRIC = 2,
                [XmlEnum(Name = "harmonic")] [Description("harmonic")] HARMONIC = 4,
                [XmlEnum(Name = "weighted")] [Description("weighted")] WEIGHTED = 5
            }

            private readonly DECAY_TYPE decay = DECAY_TYPE.NONE;
            private readonly Stopwatch elapsed = new Stopwatch();
            private readonly object LockObject = new object();
            private readonly HashSet<double> times = new HashSet<double>();
            private System.Timers.Timer alarm;

            /// <summary>
            ///     The default constructor using no decay.
            /// </summary>
            public wasAdaptiveAlarm()
            {
                Signal = new ManualResetEvent(false);
            }

            /// <summary>
            ///     The constructor for the wasAdaptiveAlarm class taking as parameter a decay type.
            /// </summary>
            /// <param name="decay">the type of decay: arithmetic, geometric, harmonic, heronian or quadratic</param>
            public wasAdaptiveAlarm(DECAY_TYPE decay)
            {
                Signal = new ManualResetEvent(false);
                this.decay = decay;
            }

            public ManualResetEvent Signal { get; set; }

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            public void Alarm(double deadline)
            {
                lock (LockObject)
                {
                    switch (alarm == null)
                    {
                        case true:
                            alarm = new System.Timers.Timer(deadline);
                            alarm.Elapsed += (o, p) =>
                            {
                                lock (LockObject)
                                {
                                    Signal.Set();
                                    elapsed.Stop();
                                    times.Clear();
                                    alarm = null;
                                }
                            };
                            elapsed.Start();
                            alarm.Start();
                            return;
                        case false:
                            elapsed.Stop();
                            times.Add(elapsed.ElapsedMilliseconds);
                            switch (decay)
                            {
                                case DECAY_TYPE.ARITHMETIC:
                                    alarm.Interval = (deadline + times.Aggregate((a, b) => b + a))/(1f + times.Count);
                                    break;
                                case DECAY_TYPE.GEOMETRIC:
                                    alarm.Interval = Math.Pow(deadline*times.Aggregate((a, b) => b*a),
                                        1f/(1f + times.Count));
                                    break;
                                case DECAY_TYPE.HARMONIC:
                                    alarm.Interval = (1f + times.Count)/
                                                     (1f/deadline + times.Aggregate((a, b) => 1f/b + 1f/a));
                                    break;
                                case DECAY_TYPE.WEIGHTED:
                                    HashSet<double> d = new HashSet<double>(times) {deadline};
                                    double total = d.Aggregate((a, b) => b + a);
                                    alarm.Interval = d.Aggregate((a, b) => Math.Pow(a, 2)/total + Math.Pow(b, 2)/total);
                                    break;
                                default:
                                    alarm.Interval = deadline;
                                    break;
                            }
                            elapsed.Reset();
                            elapsed.Start();
                            break;
                    }
                }
            }

            protected virtual void Dispose(bool dispose)
            {
                if (alarm != null)
                {
                    alarm.Dispose();
                    alarm = null;
                }
            }
        }

        #region KEY-VALUE DATA

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns the value of a key from a key-value data string.
        /// </summary>
        /// <param name="key">the key of the value</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>true if the key was found in data</returns>
        private static string wasKeyValueGet(string key, string data)
        {
            return data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .Where(o => o.k.Equals(key))
                .Select(o => o.v)
                .FirstOrDefault();
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Returns a key-value data string with a key set to a given value.
        /// </summary>
        /// <param name="key">the key of the value</param>
        /// <param name="value">the value to set the key to</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>
        ///     a key-value data string or the empty string if either key or
        ///     value are empty
        /// </returns>
        private static string wasKeyValueSet(string key, string value, string data)
        {
            HashSet<string> output = new HashSet<string>(data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = !o.First().Equals(key) ? o.Last() : value
                }).Select(o => string.Join("=", o.k, o.v)));
            string append = string.Join("=", key, value);
            if (!output.Contains(append))
            {
                output.Add(append);
            }
            return string.Join("&", output.ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Deletes a key-value pair from a string referenced by a key.
        /// </summary>
        /// <param name="key">the key to search for</param>
        /// <param name="data">the key-value data segment</param>
        /// <returns>a key-value pair string</returns>
        private static string wasKeyValueDelete(string key, string data)
        {
            return string.Join("&", data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .Where(o => !o.k.Equals(key))
                .Select(o => string.Join("=", o.k, o.v))
                .ToArray());
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Decodes key-value pair data to a dictionary.
        /// </summary>
        /// <param name="data">the key-value pair data</param>
        /// <returns>a dictionary containing the keys and values</returns>
        private static Dictionary<string, string> wasKeyValueDecode(string data)
        {
            return data.Split('&')
                .AsParallel()
                .Select(o => o.Split('=').ToList())
                .Where(o => o.Count.Equals(2))
                .Select(o => new
                {
                    k = o.First(),
                    v = o.Last()
                })
                .GroupBy(o => o.k)
                .ToDictionary(o => o.Key, p => p.First().v);
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Serialises a dictionary to key-value data.
        /// </summary>
        /// <param name="data">a dictionary</param>
        /// <returns>a key-value data encoded string</returns>
        private static string wasKeyValueEncode(Dictionary<string, string> data)
        {
            return string.Join("&", data.AsParallel().Select(o => string.Join("=", o.Key, o.Value)));
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>Escapes a dictionary's keys and values for sending as POST data.</summary>
        /// <param name="data">A dictionary containing keys and values to be escaped</param>
        private static Dictionary<string, string> wasKeyValueEscape(Dictionary<string, string> data)
        {
            return data.AsParallel().ToDictionary(o => wasOutput(o.Key), p => wasOutput(p.Value));
        }

        #endregion

        #region CRYPTOGRAPHY

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets an array element at a given modulo index.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="index">a positive or negative index of the element</param>
        /// <param name="data">the array</param>
        /// <return>an array element</return>
        public static T wasGetElementAt<T>(T[] data, int index)
        {
            switch (index < 0)
            {
                case true:
                    return data[((index%data.Length) + data.Length)%data.Length];
                default:
                    return data[index%data.Length];
            }
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Gets a sub-array from an array.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="data">the array</param>
        /// <param name="start">the start index</param>
        /// <param name="stop">the stop index (-1 denotes the end)</param>
        /// <returns>the array slice between start and stop</returns>
        public static T[] wasGetSubArray<T>(T[] data, int start, int stop)
        {
            if (stop.Equals(-1))
                stop = data.Length - 1;
            T[] result = new T[stop - start + 1];
            Array.Copy(data, start, result, 0, stop - start + 1);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Delete a sub-array and return the result.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="data">the array</param>
        /// <param name="start">the start index</param>
        /// <param name="stop">the stop index (-1 denotes the end)</param>
        /// <returns>the array without elements between start and stop</returns>
        public static T[] wasDeleteSubArray<T>(T[] data, int start, int stop)
        {
            if (stop.Equals(-1))
                stop = data.Length - 1;
            T[] result = new T[data.Length - (stop - start) - 1];
            Array.Copy(data, 0, result, 0, start);
            Array.Copy(data, stop + 1, result, start, data.Length - stop - 1);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Concatenate multiple arrays.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="arrays">multiple arrays</param>
        /// <returns>a flat array with all arrays concatenated</returns>
        public static T[] wasConcatenateArrays<T>(params T[][] arrays)
        {
            int resultLength = 0;
            foreach (T[] o in arrays)
            {
                resultLength += o.Length;
            }
            T[] result = new T[resultLength];
            int offset = 0;
            for (int x = 0; x < arrays.Length; x++)
            {
                arrays[x].CopyTo(result, offset);
                offset += arrays[x].Length;
            }
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Permutes an array in reverse a given number of times.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="input">the array</param>
        /// <param name="times">the number of times to permute</param>
        /// <returns>the array with the elements permuted</returns>
        private static T[] wasReversePermuteArrayElements<T>(T[] input, int times)
        {
            if (times.Equals(0)) return input;
            T[] slice = new T[input.Length];
            Array.Copy(input, 1, slice, 0, input.Length - 1);
            Array.Copy(input, 0, slice, input.Length - 1, 1);
            return wasReversePermuteArrayElements(slice, --times);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Permutes an array forward a given number of times.
        /// </summary>
        /// <typeparam name="T">the array type</typeparam>
        /// <param name="input">the array</param>
        /// <param name="times">the number of times to permute</param>
        /// <returns>the array with the elements permuted</returns>
        private static T[] wasForwardPermuteArrayElements<T>(T[] input, int times)
        {
            if (times.Equals(0)) return input;
            T[] slice = new T[input.Length];
            Array.Copy(input, input.Length - 1, slice, 0, 1);
            Array.Copy(input, 0, slice, 1, input.Length - 1);
            return wasForwardPermuteArrayElements(slice, --times);
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Encrypt or decrypt a message given a set of rotors, plugs and a reflector.
        /// </summary>
        /// <param name="message">the message to encyrpt or decrypt</param>
        /// <param name="rotors">any combination of: 1, 2, 3, 4, 5, 6, 7, 8, b, g</param>
        /// <param name="plugs">the letter representing the start character for the rotor</param>
        /// <param name="reflector">any one of: B, b, C, c</param>
        /// <returns>either a decrypted or encrypted string</returns>
        private static string wasEnigma(string message, char[] rotors, char[] plugs, char reflector)
        {
            Dictionary<char, char[]> def_rotors = new Dictionary<char, char[]>
            {
                {
                    '1', new[]
                    {
                        'e', 'k', 'm', 'f', 'l',
                        'g', 'd', 'q', 'v', 'z',
                        'n', 't', 'o', 'w', 'y',
                        'h', 'x', 'u', 's', 'p',
                        'a', 'i', 'b', 'r', 'c',
                        'j'
                    }
                },
                {
                    '2', new[]
                    {
                        'a', 'j', 'd', 'k', 's',
                        'i', 'r', 'u', 'x', 'b',
                        'l', 'h', 'w', 't', 'm',
                        'c', 'q', 'g', 'z', 'n',
                        'p', 'y', 'f', 'v', 'o',
                        'e'
                    }
                },
                {
                    '3', new[]
                    {
                        'b', 'd', 'f', 'h', 'j',
                        'l', 'c', 'p', 'r', 't',
                        'x', 'v', 'z', 'n', 'y',
                        'e', 'i', 'w', 'g', 'a',
                        'k', 'm', 'u', 's', 'q',
                        'o'
                    }
                },
                {
                    '4', new[]
                    {
                        'e', 's', 'o', 'v', 'p',
                        'z', 'j', 'a', 'y', 'q',
                        'u', 'i', 'r', 'h', 'x',
                        'l', 'n', 'f', 't', 'g',
                        'k', 'd', 'c', 'm', 'w',
                        'b'
                    }
                },
                {
                    '5', new[]
                    {
                        'v', 'z', 'b', 'r', 'g',
                        'i', 't', 'y', 'u', 'p',
                        's', 'd', 'n', 'h', 'l',
                        'x', 'a', 'w', 'm', 'j',
                        'q', 'o', 'f', 'e', 'c',
                        'k'
                    }
                },
                {
                    '6', new[]
                    {
                        'j', 'p', 'g', 'v', 'o',
                        'u', 'm', 'f', 'y', 'q',
                        'b', 'e', 'n', 'h', 'z',
                        'r', 'd', 'k', 'a', 's',
                        'x', 'l', 'i', 'c', 't',
                        'w'
                    }
                },
                {
                    '7', new[]
                    {
                        'n', 'z', 'j', 'h', 'g',
                        'r', 'c', 'x', 'm', 'y',
                        's', 'w', 'b', 'o', 'u',
                        'f', 'a', 'i', 'v', 'l',
                        'p', 'e', 'k', 'q', 'd',
                        't'
                    }
                },
                {
                    '8', new[]
                    {
                        'f', 'k', 'q', 'h', 't',
                        'l', 'x', 'o', 'c', 'b',
                        'j', 's', 'p', 'd', 'z',
                        'r', 'a', 'm', 'e', 'w',
                        'n', 'i', 'u', 'y', 'g',
                        'v'
                    }
                },
                {
                    'b', new[]
                    {
                        'l', 'e', 'y', 'j', 'v',
                        'c', 'n', 'i', 'x', 'w',
                        'p', 'b', 'q', 'm', 'd',
                        'r', 't', 'a', 'k', 'z',
                        'g', 'f', 'u', 'h', 'o',
                        's'
                    }
                },
                {
                    'g', new[]
                    {
                        'f', 's', 'o', 'k', 'a',
                        'n', 'u', 'e', 'r', 'h',
                        'm', 'b', 't', 'i', 'y',
                        'c', 'w', 'l', 'q', 'p',
                        'z', 'x', 'v', 'g', 'j',
                        'd'
                    }
                }
            };

            Dictionary<char, char[]> def_reflectors = new Dictionary<char, char[]>
            {
                {
                    'B', new[]
                    {
                        'a', 'y', 'b', 'r', 'c', 'u', 'd', 'h',
                        'e', 'q', 'f', 's', 'g', 'l', 'i', 'p',
                        'j', 'x', 'k', 'n', 'm', 'o', 't', 'z',
                        'v', 'w'
                    }
                },
                {
                    'b', new[]
                    {
                        'a', 'e', 'b', 'n', 'c', 'k', 'd', 'q',
                        'f', 'u', 'g', 'y', 'h', 'w', 'i', 'j',
                        'l', 'o', 'm', 'p', 'r', 'x', 's', 'z',
                        't', 'v'
                    }
                },
                {
                    'C', new[]
                    {
                        'a', 'f', 'b', 'v', 'c', 'p', 'd', 'j',
                        'e', 'i', 'g', 'o', 'h', 'y', 'k', 'r',
                        'l', 'z', 'm', 'x', 'n', 'w', 't', 'q',
                        's', 'u'
                    }
                },
                {
                    'c', new[]
                    {
                        'a', 'r', 'b', 'd', 'c', 'o', 'e', 'j',
                        'f', 'n', 'g', 't', 'h', 'k', 'i', 'v',
                        'l', 'm', 'p', 'w', 'q', 'z', 's', 'x',
                        'u', 'y'
                    }
                }
            };

            // Setup rotors from plugs.
            foreach (char rotor in rotors)
            {
                char plug = plugs[Array.IndexOf(rotors, rotor)];
                int i = Array.IndexOf(def_rotors[rotor], plug);
                if (i.Equals(0)) continue;
                def_rotors[rotor] = wasConcatenateArrays(new[] {plug},
                    wasGetSubArray(wasDeleteSubArray(def_rotors[rotor], i, i), i, -1),
                    wasGetSubArray(wasDeleteSubArray(def_rotors[rotor], i + 1, -1), 0, i - 1));
            }

            StringBuilder result = new StringBuilder();
            foreach (char c in message)
            {
                if (!char.IsLetter(c))
                {
                    result.Append(c);
                    continue;
                }

                // Normalize to lower.
                char l = char.ToLower(c);

                Action<char[]> rotate = o =>
                {
                    int i = o.Length - 1;
                    do
                    {
                        def_rotors[o[0]] = wasForwardPermuteArrayElements(def_rotors[o[0]], 1);
                        if (i.Equals(0))
                        {
                            rotors = wasReversePermuteArrayElements(o, 1);
                            continue;
                        }
                        l = wasGetElementAt(def_rotors[o[1]], Array.IndexOf(def_rotors[o[0]], l) - 1);
                        o = wasReversePermuteArrayElements(o, 1);
                    } while (--i > -1);
                };

                // Forward pass through the Enigma's rotors.
                rotate.Invoke(rotors);

                // Reflect
                int x = Array.IndexOf(def_reflectors[reflector], l);
                l = (x + 1)%2 == 0 ? def_reflectors[reflector][x - 1] : def_reflectors[reflector][x + 1];

                // Reverse the order of the rotors.
                Array.Reverse(rotors);

                // Reverse pass through the Enigma's rotors.
                rotate.Invoke(rotors);

                if (char.IsUpper(c))
                {
                    l = char.ToUpper(l);
                }
                result.Append(l);
            }

            return result.ToString();
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Expand the VIGENRE key to the length of the input.
        /// </summary>
        /// <param name="input">the input to expand to</param>
        /// <param name="enc_key">the key to expand</param>
        /// <returns>the expanded key</returns>
        private static string wasVigenereExpandKey(string input, string enc_key)
        {
            string exp_key = string.Empty;
            int i = 0, j = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    exp_key += p;
                    ++i;
                    continue;
                }
                int m = j%enc_key.Length;
                exp_key += enc_key[m];
                ++j;
                ++i;
            } while (i < input.Length);
            return exp_key;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Encrypt using VIGENERE.
        /// </summary>
        /// <param name="input">the input to encrypt</param>
        /// <param name="enc_key">the key to encrypt with</param>
        /// <returns>the encrypted input</returns>
        private static string wasEncryptVIGENERE(string input, string enc_key)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            enc_key = wasVigenereExpandKey(input, enc_key);
            string result = string.Empty;
            int i = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    result += p;
                    ++i;
                    continue;
                }
                char q =
                    wasReversePermuteArrayElements(a, Array.IndexOf(a, enc_key[i]))[
                        Array.IndexOf(a, char.ToLowerInvariant(p))];
                if (char.IsUpper(p))
                {
                    q = char.ToUpperInvariant(q);
                }
                result += q;
                ++i;
            } while (i < input.Length);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2014 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Decrypt using VIGENERE.
        /// </summary>
        /// <param name="input">the input to decrypt</param>
        /// <param name="enc_key">the key to decrypt with</param>
        /// <returns>the decrypted input</returns>
        private static string wasDecryptVIGENERE(string input, string enc_key)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            enc_key = wasVigenereExpandKey(input, enc_key);
            string result = string.Empty;
            int i = 0;
            do
            {
                char p = input[i];
                if (!char.IsLetter(p))
                {
                    result += p;
                    ++i;
                    continue;
                }
                char q =
                    a[
                        Array.IndexOf(wasReversePermuteArrayElements(a, Array.IndexOf(a, enc_key[i])),
                            char.ToLowerInvariant(p))];
                if (char.IsUpper(p))
                {
                    q = char.ToUpperInvariant(q);
                }
                result += q;
                ++i;
            } while (i < input.Length);
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  Copyright (C) Wizardry and Steamworks 2015 - License: GNU GPLv3      //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     An implementation of the ATBASH cypher for latin alphabets.
        /// </summary>
        /// <param name="data">the data to encrypt or decrypt</param>
        /// <returns>the encrypted or decrypted data</returns>
        private static string wasATBASH(string data)
        {
            char[] a =
            {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            };

            char[] input = data.ToArray();

            Parallel.ForEach(Enumerable.Range(0, data.Length), i =>
            {
                char e = input[i];
                if (!char.IsLetter(e)) return;
                int x = 25 - Array.BinarySearch(a, char.ToLowerInvariant(e));
                if (!char.IsUpper(e))
                {
                    input[i] = a[x];
                    return;
                }
                input[i] = char.ToUpperInvariant(a[x]);
            });

            return new string(input);
        }

        #endregion

        #region NAME AND UUID RESOLVERS

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2015 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Tries to build an UUID out of the data string.
        /// </summary>
        /// <param name="data">a string</param>
        /// <returns>an UUID or the supplied string in case data could not be resolved</returns>
        private static object StringOrUUID(string data)
        {
            if (string.IsNullOrEmpty(data))
            {
                return null;
            }
            UUID @UUID;
            if (!UUID.TryParse(data, out @UUID))
            {
                return data;
            }
            return @UUID;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2014 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Updates the current balance by requesting it from the grid.
        /// </summary>
        /// <param name="millisecondsTimeout">timeout for the request in milliseconds</param>
        /// <returns>true if the balance could be retrieved</returns>
        private static bool UpdateBalance(uint millisecondsTimeout)
        {
            ManualResetEvent MoneyBalanceEvent = new ManualResetEvent(false);
            EventHandler<MoneyBalanceReplyEventArgs> MoneyBalanceEventHandler =
                (sender, args) => MoneyBalanceEvent.Set();
            lock (ClientInstanceSelfLock)
            {
                Client.Self.MoneyBalanceReply += MoneyBalanceEventHandler;
                Client.Self.RequestBalance();
                if (!MoneyBalanceEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Self.MoneyBalanceReply -= MoneyBalanceEventHandler;
                    return false;
                }
                Client.Self.MoneyBalanceReply -= MoneyBalanceEventHandler;
            }
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a group name to an UUID by using the directory search.
        /// </summary>
        /// <param name="groupName">the name of the group to resolve</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">an object in which to store the UUID of the group</param>
        /// <returns>true if the group name could be resolved to an UUID</returns>
        private static bool directGroupNameToUUID(string groupName, uint millisecondsTimeout, uint dataTimeout,
            ref UUID groupUUID)
        {
            UUID localGroupUUID = UUID.Zero;
            wasAdaptiveAlarm DirGroupsReceivedAlarm = new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
            EventHandler<DirGroupsReplyEventArgs> DirGroupsReplyDelegate = (sender, args) =>
            {
                DirGroupsReceivedAlarm.Alarm(dataTimeout);
                DirectoryManager.GroupSearchData groupSearchData =
                    args.MatchedGroups.AsParallel()
                        .FirstOrDefault(o => o.GroupName.Equals(groupName, StringComparison.OrdinalIgnoreCase));
                switch (!groupSearchData.Equals(default(DirectoryManager.GroupSearchData)))
                {
                    case true:
                        localGroupUUID = groupSearchData.GroupID;
                        DirGroupsReceivedAlarm.Signal.Set();
                        break;
                }
            };
            Client.Directory.DirGroupsReply += DirGroupsReplyDelegate;
            Client.Directory.StartGroupSearch(groupName, 0);
            if (!DirGroupsReceivedAlarm.Signal.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Directory.DirGroupsReply -= DirGroupsReplyDelegate;
                return false;
            }
            Client.Directory.DirGroupsReply -= DirGroupsReplyDelegate;
            if (localGroupUUID.Equals(UUID.Zero)) return false;
            groupUUID = localGroupUUID;
            return true;
        }

        /// <summary>
        ///     A wrapper for resolving group names to UUIDs by using Corrade's internal cache.
        /// </summary>
        /// <param name="groupName">the name of the group to resolve</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="groupUUID">an object in which to store the UUID of the group</param>
        /// <returns>true if the group name could be resolved to an UUID</returns>
        private static bool GroupNameToUUID(string groupName, uint millisecondsTimeout, uint dataTimeout,
            ref UUID groupUUID)
        {
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Groups @group = Cache.GroupCache.AsParallel().FirstOrDefault(o => o.Name.Equals(groupName));

                if (!@group.Equals(default(Cache.Groups)))
                {
                    groupUUID = @group.UUID;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceDirectoryLock)
            {
                succeeded = directGroupNameToUUID(groupName, millisecondsTimeout, dataTimeout, ref groupUUID);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.GroupCache.Add(new Cache.Groups
                    {
                        Name = groupName,
                        UUID = groupUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a group name to an UUID by using the directory search.
        /// </summary>
        /// <param name="groupName">a string to store the name to</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="groupUUID">the UUID of the group to resolve</param>
        /// <returns>true if the group UUID could be resolved to an name</returns>
        private static bool directGroupUUIDToName(UUID groupUUID, uint millisecondsTimeout,
            ref string groupName)
        {
            string localGroupName = groupName;
            ManualResetEvent GroupProfileReceivedEvent = new ManualResetEvent(false);
            EventHandler<GroupProfileEventArgs> GroupProfileDelegate = (o, s) =>
            {
                localGroupName = s.Group.Name;
                GroupProfileReceivedEvent.Set();
            };
            Client.Groups.GroupProfile += GroupProfileDelegate;
            Client.Groups.RequestGroupProfile(groupUUID);
            if (!GroupProfileReceivedEvent.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Groups.GroupProfile -= GroupProfileDelegate;
                return false;
            }
            Client.Groups.GroupProfile -= GroupProfileDelegate;
            groupName = localGroupName;
            return true;
        }

        /// <summary>
        ///     A wrapper for resolving group names to UUIDs by using Corrade's internal cache.
        /// </summary>
        /// <param name="groupName">a string to store the name to</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="groupUUID">the UUID of the group to resolve</param>
        /// <returns>true if the group UUID could be resolved to an name</returns>
        private static bool GroupUUIDToName(UUID groupUUID, uint millisecondsTimeout,
            ref string groupName)
        {
            lock (Cache.Locks.GroupCacheLock)
            {
                Cache.Groups @group = Cache.GroupCache.AsParallel().FirstOrDefault(o => o.UUID.Equals(groupUUID));

                if (!@group.Equals(default(Cache.Groups)))
                {
                    groupName = @group.Name;
                    return true;
                }
            }
            bool succeeded;
            lock (ClientInstanceGroupsLock)
            {
                succeeded = directGroupUUIDToName(groupUUID, millisecondsTimeout, ref groupName);
            }
            if (succeeded)
            {
                lock (Cache.Locks.GroupCacheLock)
                {
                    Cache.GroupCache.Add(new Cache.Groups
                    {
                        Name = groupName,
                        UUID = groupUUID
                    });
                }
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves an agent name to an agent UUID by searching the directory
        ///     services.
        /// </summary>
        /// <param name="agentFirstName">the first name of the agent</param>
        /// <param name="agentLastName">the last name of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="agentUUID">an object to store the agent UUID</param>
        /// <returns>true if the agent name could be resolved to an UUID</returns>
        private static bool directAgentNameToUUID(string agentFirstName, string agentLastName, uint millisecondsTimeout,
            uint dataTimeout,
            ref UUID agentUUID)
        {
            UUID localAgentUUID = UUID.Zero;
            wasAdaptiveAlarm DirPeopleReceivedAlarm = new wasAdaptiveAlarm(corradeConfiguration.DataDecayType);
            EventHandler<DirPeopleReplyEventArgs> DirPeopleReplyDelegate = (sender, args) =>
            {
                DirPeopleReceivedAlarm.Alarm(dataTimeout);
                DirectoryManager.AgentSearchData agentSearchData =
                    args.MatchedPeople.AsParallel().FirstOrDefault(
                        o =>
                            o.FirstName.Equals(agentFirstName, StringComparison.OrdinalIgnoreCase) &&
                            o.LastName.Equals(agentLastName, StringComparison.OrdinalIgnoreCase));
                switch (!agentSearchData.Equals(default(DirectoryManager.AgentSearchData)))
                {
                    case true:
                        localAgentUUID = agentSearchData.AgentID;
                        DirPeopleReceivedAlarm.Signal.Set();
                        break;
                }
            };
            Client.Directory.DirPeopleReply += DirPeopleReplyDelegate;
            Client.Directory.StartPeopleSearch(
                string.Format(CultureInfo.DefaultThreadCurrentCulture, "{0} {1}", agentFirstName, agentLastName), 0);
            if (!DirPeopleReceivedAlarm.Signal.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Directory.DirPeopleReply -= DirPeopleReplyDelegate;
                return false;
            }
            Client.Directory.DirPeopleReply -= DirPeopleReplyDelegate;
            if (localAgentUUID.Equals(UUID.Zero)) return false;
            agentUUID = localAgentUUID;
            return true;
        }

        /// <summary>
        ///     A wrapper for looking up an agent name using Corrade's internal cache.
        /// </summary>
        /// <param name="agentFirstName">the first name of the agent</param>
        /// <param name="agentLastName">the last name of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="agentUUID">an object to store the agent UUID</param>
        /// <returns>true if the agent name could be resolved to an UUID</returns>
        private static bool AgentNameToUUID(string agentFirstName, string agentLastName, uint millisecondsTimeout,
            uint dataTimeout,
            ref UUID agentUUID)
        {
            Cache.Agents agent = Cache.GetAgent(agentFirstName, agentLastName);
            if (!agent.Equals(default(Cache.Agents)))
            {
                agentUUID = agent.UUID;
                return true;
            }
            bool succeeded;
            lock (ClientInstanceDirectoryLock)
            {
                succeeded = directAgentNameToUUID(agentFirstName, agentLastName, millisecondsTimeout, dataTimeout,
                    ref agentUUID);
            }
            if (succeeded)
            {
                Cache.AddAgent(agentFirstName, agentLastName, agentUUID);
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves an agent UUID to an agent name.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="agentName">an object to store the name of the agent in</param>
        /// <returns>true if the UUID could be resolved to a name</returns>
        private static bool directAgentUUIDToName(UUID agentUUID, uint millisecondsTimeout,
            ref string agentName)
        {
            if (agentUUID.Equals(UUID.Zero))
                return false;
            string localAgentName = string.Empty;
            ManualResetEvent UUIDNameReplyEvent = new ManualResetEvent(false);
            EventHandler<UUIDNameReplyEventArgs> UUIDNameReplyDelegate = (sender, args) =>
            {
                KeyValuePair<UUID, string> UUIDNameReply =
                    args.Names.AsParallel().FirstOrDefault(o => o.Key.Equals(agentUUID));
                if (!UUIDNameReply.Equals(default(KeyValuePair<UUID, string>)))
                    localAgentName = UUIDNameReply.Value;
                UUIDNameReplyEvent.Set();
            };
            Client.Avatars.UUIDNameReply += UUIDNameReplyDelegate;
            Client.Avatars.RequestAvatarName(agentUUID);
            if (!UUIDNameReplyEvent.WaitOne((int) millisecondsTimeout, false))
            {
                Client.Avatars.UUIDNameReply -= UUIDNameReplyDelegate;
                return false;
            }
            Client.Avatars.UUIDNameReply -= UUIDNameReplyDelegate;
            if (string.IsNullOrEmpty(localAgentName)) return false;
            agentName = localAgentName;
            return true;
        }

        /// <summary>
        ///     A wrapper for agent to UUID lookups using Corrade's internal cache.
        /// </summary>
        /// <param name="agentUUID">the UUID of the agent</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="agentName">an object to store the name of the agent in</param>
        /// <returns>true if the UUID could be resolved to a name</returns>
        private static bool AgentUUIDToName(UUID agentUUID, uint millisecondsTimeout,
            ref string agentName)
        {
            Cache.Agents agent = Cache.GetAgent(agentUUID);
            if (!agent.Equals(default(Cache.Agents)))
            {
                agentName = string.Join(" ", agent.FirstName, agent.LastName);
                return true;
            }
            bool succeeded;
            lock (ClientInstanceAvatarsLock)
            {
                succeeded = directAgentUUIDToName(agentUUID, millisecondsTimeout, ref agentName);
            }
            if (succeeded)
            {
                List<string> name = new List<string>(GetAvatarNames(agentName));
                Cache.AddAgent(name.First(), name.Last(), agentUUID);
            }
            return succeeded;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// ///
        /// <summary>
        ///     Resolves a role name to a role UUID.
        /// </summary>
        /// <param name="roleName">the name of the role to be resolved to an UUID</param>
        /// <param name="groupUUID">the UUID of the group to query for the role UUID</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="roleUUID">an UUID object to store the role UUID in</param>
        /// <returns>true if the role could be found</returns>
        private static bool RoleNameToUUID(string roleName, UUID groupUUID, uint millisecondsTimeout,
            ref UUID roleUUID)
        {
            switch (!roleName.Equals(LINDEN_CONSTANTS.GROUPS.EVERYONE_ROLE_NAME, StringComparison.Ordinal))
            {
                case false:
                    roleUUID = UUID.Zero;
                    return true;
            }
            ManualResetEvent GroupRoleDataReceivedAlarm = new ManualResetEvent(false);
            Dictionary<UUID, GroupRole> groupRoles = null;
            EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataReplyDelegate = (sender, args) =>
            {
                groupRoles = args.Roles;
                GroupRoleDataReceivedAlarm.Set();
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupRoleDataReply += GroupRoleDataReplyDelegate;
                Client.Groups.RequestGroupRoles(groupUUID);
                if (!GroupRoleDataReceivedAlarm.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
                    return false;
                }
                Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
            }
            switch (groupRoles != null)
            {
                case true:
                    KeyValuePair<UUID, GroupRole> role = groupRoles.AsParallel()
                        .FirstOrDefault(o => o.Value.Name.Equals(roleName, StringComparison.Ordinal));
                    if (!role.Equals(default(KeyValuePair<UUID, GroupRole>)))
                        roleUUID = role.Key;
                    return true;
            }
            return false;
        }

        ///////////////////////////////////////////////////////////////////////////
        //    Copyright (C) 2013 Wizardry and Steamworks - License: GNU GPLv3    //
        ///////////////////////////////////////////////////////////////////////////
        /// <summary>
        ///     Resolves a role name to a role UUID.
        /// </summary>
        /// <param name="RoleUUID">the UUID of the role to be resolved to a name</param>
        /// <param name="GroupUUID">the UUID of the group to query for the role name</param>
        /// <param name="millisecondsTimeout">timeout for the search in milliseconds</param>
        /// <param name="dataTimeout">timeout for receiving answers from services</param>
        /// <param name="roleName">a string object to store the role name in</param>
        /// <returns>true if the role could be resolved</returns>
        private static bool RoleUUIDToName(UUID RoleUUID, UUID GroupUUID, uint millisecondsTimeout, uint dataTimeout,
            ref string roleName)
        {
            switch (!RoleUUID.Equals(UUID.Zero))
            {
                case false:
                    roleName = LINDEN_CONSTANTS.GROUPS.EVERYONE_ROLE_NAME;
                    return true;
            }
            ManualResetEvent GroupRoleDataReceivedEvent = new ManualResetEvent(false);
            Dictionary<UUID, GroupRole> groupRoles = null;
            EventHandler<GroupRolesDataReplyEventArgs> GroupRoleDataReplyDelegate = (sender, args) =>
            {
                groupRoles = args.Roles;
                GroupRoleDataReceivedEvent.Set();
            };
            lock (ClientInstanceGroupsLock)
            {
                Client.Groups.GroupRoleDataReply += GroupRoleDataReplyDelegate;
                Client.Groups.RequestGroupRoles(GroupUUID);
                if (!GroupRoleDataReceivedEvent.WaitOne((int) millisecondsTimeout, false))
                {
                    Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
                    return false;
                }
                Client.Groups.GroupRoleDataReply -= GroupRoleDataReplyDelegate;
            }
            switch (groupRoles != null)
            {
                case true:
                    KeyValuePair<UUID, GroupRole> role =
                        groupRoles.AsParallel().FirstOrDefault(o => o.Key.Equals(RoleUUID));
                    if (!role.Equals(default(KeyValuePair<UUID, GroupRole>)))
                        roleName = role.Value.Name;
                    return true;
            }
            return false;
        }

        #endregion

        #region RLV STRUCTURES

        /// <summary>
        ///     Holds all the active RLV rules.
        /// </summary>
        private static readonly HashSet<RLVRule> RLVRules = new HashSet<RLVRule>();

        /// <summary>
        ///     Locks down RLV for linear concurrent access.
        /// </summary>
        private static readonly object RLVRulesLock = new object();

        /// <summary>
        ///     RLV Wearables.
        /// </summary>
        private static readonly List<RLVWearable> RLVWearables = new List<RLVWearable>
        {
            new RLVWearable {Name = @"gloves", WearableType = WearableType.Gloves},
            new RLVWearable {Name = @"jacket", WearableType = WearableType.Jacket},
            new RLVWearable {Name = @"pants", WearableType = WearableType.Pants},
            new RLVWearable {Name = @"shirt", WearableType = WearableType.Shirt},
            new RLVWearable {Name = @"shoes", WearableType = WearableType.Shoes},
            new RLVWearable {Name = @"skirt", WearableType = WearableType.Skirt},
            new RLVWearable {Name = @"socks", WearableType = WearableType.Socks},
            new RLVWearable {Name = @"underpants", WearableType = WearableType.Underpants},
            new RLVWearable {Name = @"undershirt", WearableType = WearableType.Undershirt},
            new RLVWearable {Name = @"skin", WearableType = WearableType.Skin},
            new RLVWearable {Name = @"eyes", WearableType = WearableType.Eyes},
            new RLVWearable {Name = @"hair", WearableType = WearableType.Hair},
            new RLVWearable {Name = @"shape", WearableType = WearableType.Shape},
            new RLVWearable {Name = @"alpha", WearableType = WearableType.Alpha},
            new RLVWearable {Name = @"tattoo", WearableType = WearableType.Tattoo},
            new RLVWearable {Name = @"physics", WearableType = WearableType.Physics}
        };

        /// <summary>
        ///     RLV Attachments.
        /// </summary>
        private static readonly List<RLVAttachment> RLVAttachments = new List<RLVAttachment>
        {
            new RLVAttachment {Name = @"none", AttachmentPoint = AttachmentPoint.Default},
            new RLVAttachment {Name = @"chest", AttachmentPoint = AttachmentPoint.Chest},
            new RLVAttachment {Name = @"skull", AttachmentPoint = AttachmentPoint.Skull},
            new RLVAttachment {Name = @"left shoulder", AttachmentPoint = AttachmentPoint.LeftShoulder},
            new RLVAttachment {Name = @"right shoulder", AttachmentPoint = AttachmentPoint.RightShoulder},
            new RLVAttachment {Name = @"left hand", AttachmentPoint = AttachmentPoint.LeftHand},
            new RLVAttachment {Name = @"right hand", AttachmentPoint = AttachmentPoint.RightHand},
            new RLVAttachment {Name = @"left foot", AttachmentPoint = AttachmentPoint.LeftFoot},
            new RLVAttachment {Name = @"right foot", AttachmentPoint = AttachmentPoint.RightFoot},
            new RLVAttachment {Name = @"spine", AttachmentPoint = AttachmentPoint.Spine},
            new RLVAttachment {Name = @"pelvis", AttachmentPoint = AttachmentPoint.Pelvis},
            new RLVAttachment {Name = @"mouth", AttachmentPoint = AttachmentPoint.Mouth},
            new RLVAttachment {Name = @"chin", AttachmentPoint = AttachmentPoint.Chin},
            new RLVAttachment {Name = @"left ear", AttachmentPoint = AttachmentPoint.LeftEar},
            new RLVAttachment {Name = @"right ear", AttachmentPoint = AttachmentPoint.RightEar},
            new RLVAttachment {Name = @"left eyeball", AttachmentPoint = AttachmentPoint.LeftEyeball},
            new RLVAttachment {Name = @"right eyeball", AttachmentPoint = AttachmentPoint.RightEyeball},
            new RLVAttachment {Name = @"nose", AttachmentPoint = AttachmentPoint.Nose},
            new RLVAttachment {Name = @"r upper arm", AttachmentPoint = AttachmentPoint.RightUpperArm},
            new RLVAttachment {Name = @"r forearm", AttachmentPoint = AttachmentPoint.RightForearm},
            new RLVAttachment {Name = @"l upper arm", AttachmentPoint = AttachmentPoint.LeftUpperArm},
            new RLVAttachment {Name = @"l forearm", AttachmentPoint = AttachmentPoint.LeftForearm},
            new RLVAttachment {Name = @"right hip", AttachmentPoint = AttachmentPoint.RightHip},
            new RLVAttachment {Name = @"r upper leg", AttachmentPoint = AttachmentPoint.RightUpperLeg},
            new RLVAttachment {Name = @"r lower leg", AttachmentPoint = AttachmentPoint.RightLowerLeg},
            new RLVAttachment {Name = @"left hip", AttachmentPoint = AttachmentPoint.LeftHip},
            new RLVAttachment {Name = @"l upper leg", AttachmentPoint = AttachmentPoint.LeftUpperLeg},
            new RLVAttachment {Name = @"l lower leg", AttachmentPoint = AttachmentPoint.LeftLowerLeg},
            new RLVAttachment {Name = @"stomach", AttachmentPoint = AttachmentPoint.Stomach},
            new RLVAttachment {Name = @"left pec", AttachmentPoint = AttachmentPoint.LeftPec},
            new RLVAttachment {Name = @"right pec", AttachmentPoint = AttachmentPoint.RightPec},
            new RLVAttachment {Name = @"center 2", AttachmentPoint = AttachmentPoint.HUDCenter2},
            new RLVAttachment {Name = @"top right", AttachmentPoint = AttachmentPoint.HUDTopRight},
            new RLVAttachment {Name = @"top", AttachmentPoint = AttachmentPoint.HUDTop},
            new RLVAttachment {Name = @"top left", AttachmentPoint = AttachmentPoint.HUDTopLeft},
            new RLVAttachment {Name = @"center", AttachmentPoint = AttachmentPoint.HUDCenter},
            new RLVAttachment {Name = @"bottom left", AttachmentPoint = AttachmentPoint.HUDBottomLeft},
            new RLVAttachment {Name = @"bottom", AttachmentPoint = AttachmentPoint.HUDBottom},
            new RLVAttachment {Name = @"bottom right", AttachmentPoint = AttachmentPoint.HUDBottomRight},
            new RLVAttachment {Name = @"neck", AttachmentPoint = AttachmentPoint.Neck},
            new RLVAttachment {Name = @"root", AttachmentPoint = AttachmentPoint.Root}
        };

        /// <summary>
        ///     RLV attachment structure.
        /// </summary>
        private struct RLVAttachment
        {
            public AttachmentPoint AttachmentPoint;
            public string Name;
        }

        /// <summary>
        ///     Enumeration for supported RLV commands.
        /// </summary>
        private enum RLVBehaviour : uint
        {
            [Description("none")] NONE = 0,
            [Description("version")] VERSION,
            [Description("versionnew")] VERSIONNEW,
            [Description("versionnum")] VERSIONNUM,
            [Description("getgroup")] GETGROUP,
            [Description("setgroup")] SETGROUP,
            [Description("getsitid")] GETSITID,
            [Description("getstatusall")] GETSTATUSALL,
            [Description("getstatus")] GETSTATUS,
            [Description("sit")] SIT,
            [Description("unsit")] UNSIT,
            [Description("setrot")] SETROT,
            [Description("tpto")] TPTO,
            [Description("getoutfit")] GETOUTFIT,
            [Description("getattach")] GETATTACH,
            [Description("remattach")] REMATTACH,
            [Description("detach")] DETACH,
            [Description("detachme")] DETACHME,
            [Description("remoutfit")] REMOUTFIT,
            [Description("attach")] ATTACH,
            [Description("attachoverreplace")] ATTACHOVERORREPLACE,
            [Description("attachover")] ATTACHOVER,
            [Description("getinv")] GETINV,
            [Description("getinvworn")] GETINVWORN,
            [Description("getpath")] GETPATH,
            [Description("getpathnew")] GETPATHNEW,
            [Description("findfolder")] FINDFOLDER,
            [Description("clear")] CLEAR,
            [Description("accepttp")] ACCEPTTP,
            [Description("acceptpermission")] ACCEPTPERMISSION
        }

        private struct RLVRule
        {
            public string Behaviour;
            public UUID ObjectUUID;
            public string Option;
            public string Param;
        }

        /// <summary>
        ///     RLV wearable structure.
        /// </summary>
        private struct RLVWearable
        {
            public string Name;
            public WearableType WearableType;
        }

        /// <summary>
        ///     Structure for RLV constants.
        /// </summary>
        private struct RLV_CONSTANTS
        {
            public const string COMMAND_OPERATOR = @"@";
            public const string VIEWER = @"RestrainedLife viewer";
            public const string SHORT_VERSION = @"1.23";
            public const string LONG_VERSION = @"1230100";
            public const string FORCE = @"force";
            public const string FALSE_MARKER = @"0";
            public const string TRUE_MARKER = @"1";
            public const string CSV_DELIMITER = @",";
            public const string DOT_MARKER = @".";
            public const string TILDE_MARKER = @"~";
            public const string PROPORTION_SEPARATOR = @"|";
            public const string SHARED_FOLDER_NAME = @"#RLV";
            public const string AND_OPERATOR = @"&&";
            public const string PATH_SEPARATOR = @"/";
            public const string Y = @"y";
            public const string ADD = @"add";
            public const string N = @"n";
            public const string REM = @"rem";
            public const string STATUS_SEPARATOR = @";";

            /// <summary>
            ///     Regex used to match RLV commands.
            /// </summary>
            public static readonly Regex RLVRegEx = new Regex(@"(?<behaviour>[^:=]+)(:(?<option>[^=]*))?=(?<param>\w+)",
                RegexOptions.Compiled);
        }

        #endregion
    }

    public class NativeMethods
    {
        public enum CtrlType
        {
            CTRL_C_EVENT = 0,
            CTRL_BREAK_EVENT,
            CTRL_CLOSE_EVENT,
            CTRL_LOGOFF_EVENT = 5,
            CTRL_SHUTDOWN_EVENT
        }

        /// <summary>
        ///     Import console handler for windows.
        /// </summary>
        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool SetConsoleCtrlHandler(Corrade.EventHandler handler,
            [MarshalAs(UnmanagedType.U1)] bool add);
    }
}